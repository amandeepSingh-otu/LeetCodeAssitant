[
  {
    "problem_slug": "two-sum",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Hash Table"
    ],
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Example 2: Example 3: Constraints:",
    "solution": "Video Solution Solution Article Approach 1: Brute Force Algorithm The brute force approach is simple. Loop through each element x and find if there is another value that equals to target - x. ImplementationComplexity Analysis * Time complexity: O(n^2). For each element, we try to find its complement by looping through the rest of the array which takes O(n) time. Therefore, the time complexity is O(n^2). * Space complexity: O(1). The space required does not depend on the size of the input array, so only constant space is used. Approach 2: Two-pass Hash Table Intuition To improve our runtime complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to get its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table. We can reduce the lookup time from O(n) to O(1) by trading space for speed. A hash table is well suited for this purpose because it supports fast lookup in *near* constant time. I say \"near\" because if a collision occurred, a lookup could degenerate to O(n) time. However, lookup in a hash table should be amortized O(1) time as long as the hash function was chosen carefully. Algorithm A simple implementation uses two iterations. In the first iteration, we add each element's value as a key and its index as a value to the hash table. Then, in the second iteration, we check if each element's complement (target - nums[i]) exists in the hash table. If it does exist, we return current element's index and its complement's index. Beware that the complement must not be nums[i] itself! ImplementationComplexity Analysis * Time complexity: O(n). We traverse the list containing n elements exactly twice. Since the hash table reduces the lookup time to O(1), the overall time complexity is O(n). * Space complexity: O(n). The extra space required depends on the number of items stored in the hash table, which stores exactly n elements. Approach 3: One-pass Hash Table Algorithm It turns out we can do it in one-pass. While we are iterating and inserting elements into the hash table, we also look back to check if current element's complement already exists in the hash table. If it exists, we have found a solution and return the indices immediately. ImplementationComplexity Analysis * Time complexity: O(n). We traverse the list containing n elements only once. Each lookup in the table costs only O(1) time. * Space complexity: O(n). The extra space required depends on the number of items stored in the hash table, which stores at most n elements.",
    "constraints": [
      "2 <= nums.length <= 104",
      "-109 <= nums[i] <= 109",
      "-109 <= target <= 109",
      "Only one valid answer exists."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "example_text": "Input: nums = [3,2,4], target = 6 Output: [1,2]"
      },
      {
        "example_text": "Input: nums = [3,3], target = 6 Output: [0,1]"
      }
    ]
  },
  {
    "problem_slug": "add-two-numbers",
    "difficulty": "Medium",
    "topics": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1: Example 2: Example 3: Constraints:",
    "solution": "Video Solution Solution Article Approach 1: Elementary Math Intuition Keep track of the carry using a variable and simulate digits-by-digits sum starting from the head of list, which contains the least-significant digit. ![Illustration of Adding two numbers](../Figures/2_add_two_numbers.svg){:width=\"539px\"} *Figure 1. Visualization of the addition of two numbers: 342 + 465 = 807. Each node contains a single digit and the digits are stored in reverse order.* Algorithm Just like how you would sum two numbers on a piece of paper, we begin by summing the least-significant digits, which is the head of l1 and l2. Since each digit is in the range of 0 \\ldots 9, summing two digits may \"overflow\". For example 5 + 7 = 12. In this case, we set the current digit to 2 and bring over the carry = 1 to the next iteration. carry must be either 0 or 1 because the largest possible sum of two digits (including the carry) is 9 + 9 + 1 = 19. The pseudocode is as following: * Initialize current node to dummy head of the returning list. * Initialize carry to 0. * Loop through lists l1 and l2 until you reach both ends and carry is 0. * Set x to node l1's value. If l1 has reached the end of l1, set to 0. * Set y to node l2's value. If l2 has reached the end of l2, set to 0. * Set sum = x + y + carry. * Update carry = sum / 10. * Create a new node with the digit value of (sum \\bmod 10) and set it to current node's next, then advance current node to next. * Advance both l1 and l2. * Return dummy head's next node. Note that we use a dummy head to simplify the code. Without a dummy head, you would have to write extra conditional statements to initialize the head's value. Take extra caution of the following cases: | Test case | Explanation | | - | - | | l1=[0,1]l2=[0,1,2] | When one list is longer than the other. | | l1=[]l2=[0,1] | When one list is null, which means an empty list. | | l1=[9,9]l2=[1] | The sum could have an extra carry of one at the end, which is easy to forget. | ImplementationComplexity Analysis * Time complexity : O(\\max(m, n)). Assume that m and n represents the length of l1 and l2 respectively, the algorithm above iterates at most \\max(m, n) times. * Space complexity : O(1). The length of the new list is at most \\max(m,n) + 1 However, we don't count the answer as part of the space complexity. Follow up What if the the digits in the linked list are stored in non-reversed order? For example: (3 \\to 4 \\to 2) + (4 \\to 6 \\to 5) = 8 \\to 0 \\to 7",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the list represents a number that does not have leading zeros."
    ],
    "examples": [
      {
        "example_text": "Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807."
      },
      {
        "example_text": "Input: l1 = [0], l2 = [0] Output: [0]"
      },
      {
        "example_text": "Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1]"
      }
    ]
  },
  {
    "problem_slug": "longest-substring-without-repeating-characters",
    "difficulty": "Medium",
    "topics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "description": "Given a string s, find the length of the longest substring without duplicate characters. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "0 <= s.length <= 5 * 104",
      "s consists of English letters, digits, symbols and spaces."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3."
      },
      {
        "example_text": "Input: s = \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1."
      },
      {
        "example_text": "Input: s = \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring."
      }
    ]
  },
  {
    "problem_slug": "median-of-two-sorted-arrays",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Binary Search",
      "Divide and Conquer"
    ],
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: Example 2: Constraints:",
    "solution": "Video Solution Solution Overview In this problem, we are given two sorted arrays, `nums1` and `nums2`. We need to return the median of these two arrays. Approach 1: Merge Sort Intuition Let's start with the straightforward approach. If we put the elements of two arrays in one array `A` and arrange them in order. Assume the merged arrays has a length of `n`, then the median is: - `A[n / 2]`, if `n` is odd. - The average of `A[n / 2]` and `A[n / 2 + 1]`, if `n` is even. However, we do not really need to merge and sort these arrays. Note that both arrays are already sorted, so the smallest element is either the first element of `nums1` or the first element of `nums2`. Therefore, we can set two pointers `p1` and `p2` at the start of each array, then we can get the smallest element from the `nums1` and `nums2` by comparing the values `nums1[p1]` and `nums2[p2]`. Please refer to the following slide as an example: !?!../Documents/4/s1.json:601,301!?! Algorithm 1) Get the total size of two arrays `m + n` - If `m + n` is odd, we are looking for the `(m + n) / 2`-th element. - If `m + n` is even, we are looking for the average of the `(m + n) / 2`-th and the `(m + n) / 2 + 1`-th elements. 2) Set two pointers `p1` and `p2` at the beginning of arrays `nums1` and `nums2`. 3) If both `p1` and `p2` are in bounds of the arrays, compare the values at `p1` and `p2`: - If `nums1[p1]` is smaller than `nums2[p2]`, we move `p1` one place to the right. - Otherwise, we move `p2` one place to the right. If `p1` is outside `nums1`, just move `p2` one place to the right. If `p2` is outside `nums2`, just move `p1` one place to the right. 4) Get the target elements and calculate the median: - If `m + n` is odd, repeat step 3 by `(m + n + 1) / 2` times and return the element from the last step. - If `m + n` is even, repeat step 3 by `(m + n) / 2 + 1` times and return the average of the elements from the last two steps. Implementation Complexity Analysis Let m be the size of array `nums1` and n be the size of array `nums2`. * Time complexity: O(m + n) - We get the smallest element by comparing two values at `p1` and `p2`, it takes O(1) to compare two elements and move the corresponding pointer to the right. - We need to traverse half of the arrays before reaching the median element(s). - To sum up, the time complexity is O(m + n). * Space complexity: O(1) - We only need to maintain two pointers `p1` and `p2`. Approach 2: Binary Search, Recursive Intuition Because the inputs are sorted arrays and the problem asks for a logarithmic time limit, we strongly feel that binary search (or a similar approach) is a promising method. While we're not sure how to cast the same pattern as a normal binary search on this problem, let's go over some steps of a regular binary search and see if we can get any inspiration. (If you are not familiar with binary search, you can refer to our [Binary Search Explore Card](https://leetcode.com/explore/learn/card/binary-search/)) Here we use binary search to find `target` in a sorted array `A`: - Locate the middle index (element) of `A`. - Compare the value of the middle element with `target`. - Reduce the search space by cutting the current array in half and discarding the half which is guaranteed not to contain `target`. - Repeat the above process until we either empty the array (move to half a the length of 0) or find `target`. ![img](../Figures/4/bs.png) At each step, the search space is cut in half, so we can quickly get the result. Now back to this problem where we have two sorted arrays. For the sake of convenience, let's call them `A` and `B`. ![img](../Figures/4/2.png) Similarly, we can get and compare their middle values `A_mid` and `B_mid`. Without loss of generality in this example we assume `A_mid <= B_mid` initially, as shown in the yellow boxes. ![img](../Figures/4/3.png) What does this comparison imply? It implies that we can compare sections of `A` and `B`. > For the rest of this article, we will use \\le to represent the relative magnitude of values in arrays. For example, A_{\\text{left}} \\le A_{\\text{right}} means that every element in $A_{\\text{left}}$ is no larger than any element in $A_{\\text{right}}$. We also 'compare' elements in an array with a single element similarly, for example, A_{\\text{left}} \\le A_{\\text{mid}} means that every element in $A_{\\text{left}}$ is no larger than the element $A_{\\text{mid}}$. This may not be the most standard way of expressing it, but is easy enough to understand. Recall that both arrays are sorted, so we know that: - A_{\\text{left}} \\le A_{\\text{mid}} - B_{\\text{mid}} \\le B_{\\text{right}} Combine these observations with the comparison we just made: A_{\\text{mid}} \\le B_{\\text{mid}} We have the following result: A_{\\text{left}} \\le A_{\\text{mid}} \\le B_{\\text{mid}} \\le B_{\\text{right}} Thus, A_{\\text{left}} \\le B_{\\text{right}} As shown in the picture below: ![img](../Figures/4/4.png) Since `A` is sorted, we know that A_{\\text{left}} \\le A_{\\text{right}}. ![img](../Figures/4/5.png) Now we know that `A_left` is smaller than two halves: `A_right` and `B_right`. Although we still don't know where exactly these elements are, what we do know is `A_left` doesn't intersect with `A_right + B_right`! There is an invisible boundary between the `A_left` segment and the mixed segment `A_right + B_right`. As shown in the picture below, the dashed line divides all sorted elements into two halves. ![img](../Figures/4/6.png) We can apply all the same logic to the mixed segment A_{\\text{left}} + B_{\\text{left}} and B_{\\text{right}}, which also do not intersect. You can try to prove it yourself as an exercise. ![img](../Figures/4/7.png) It looks somewhat clearer, we have clearly separated some subarrays. How do we continue to leverage this knowledge and use the cut-in-half method repeatedly?The following step is the most important one. Remember that we are looking for the median of `sorted A + B` which is one or two target values. We regard the index of the target value in the `sorted(A + B)` as `k`. For example: - If the lengths of `A` and `B` are `6` and `5`, the target index is `k = (6 + 5 + 1) / 2 = 6`, we shall look for the 6th smallest element. - If the lengths of `A` and `B` are `6` and `6`, the target indexes are `k = (6 + 6) / 2 = 6` and `k + 1 = 7`, we shall look for the 6th and the 7th smallest elements. Depending on whether the total number of elements is odd or even, we need the k^{th} (and maybe the (k + 1)^{th}) elements. What matters is that we set an index `k` at the beginning and we want to find the k^{th} smallest element using the Binary Search-like algorithm discussed previously (for convenience, we will discuss only the k^{th} element for now). However, during the Binary Search-like algorithm, we keep removing one half of an array, so the index `k` might not stay unchanged. Suppose we removed `3` elements that are smaller than the original k^{th} smallest element, we shall look for the (k-3)^{th} smallest element from the remaining arrays. ![img](../Figures/4/exp_1.png) More specifically: If `k` is larger than half the total number of elements in `sorted(A + B)`, it means that the k^{th} element is in the second (larger) half of `sorted(A + B)`, thus A_{\\text{left}} (or B_{\\text{left}}, the smaller of the two smaller sections according to the comparison) is guaranteed not to contain this element, and we can safely cut this half, and reduce `k` by the length of the removed half. If `k` is not larger than half the total number of elements in `sorted(A + B)`, it means that the k^{th} element is in the first (smaller) half of `sorted(A + B)`, thus B_{\\text{right}} (or A_{\\text{right}}, the larger of the two larger sections according to the comparison) is guaranteed not to contain this element, and we can safely discard it. Note that we don't need to modify `k` this time, since we removed one larger half that doesn't affect the order of the k^{th} smallest element. We can continue our search like above in the remaining arrays. The long arrow that starts from the bottom and points to the top-left indicates that we are repeating the process. Once we cut off part of either `A` or `B`, we regard the remaining arrays as modified `A` and `B` and restart this algorithm. Note that the following picture represents one case only: we consider the case that `a_value < b_value`, thus we remove either the smaller half of `A` or the larger half of `B`. If the comparison result is `a_value >= b_value`, we shall remove either the smaller half of `B` or the larger half of `A`. ![img](../Figures/4/9.png) That's it. We cut one of the two arrays in half at each step, so this approach has a logarithmic time complexity which we will discuss in detail later. > One more thing! In the previous picture, we repeat all processes using the modified arrays, but this is just for the sake of understanding. We won't create copies of two arrays repeatedly, because that would introduce a linear time complexity at least. Instead, we just treat a part of the original array as the modified array for the next step, so that we can repeat the process on the original array without making any duplication. To do this, we need to maintain four pointers, two pointers for each array, e.g., `a_start` and `a_end` represent an inclusive range `[a_start, a_end]` of `A`. Algorithm Let's define a function that helps us find the k^{th} smallest element from two inclusive ranges `[a_start, a_end]` and `[b_start, b_end]` from arrays `A` and `B`. 1) If the range (for example, a range of `A`) is empty, in other words `a_start > a_end`, it means all elements in `A` are passed, we just return the `(k - a_start)`-th element from the other array `B`. Vice versa if `b_start > b_end`. 2) Otherwise, get the middle indexes of the two ranges: `a_index = (a_start + a_end) / 2`, `b_index = (b_start + b_end) / 2`. 3) Get the middle values of the two ranges: `a_value = A[a_index]`, `b_value = B[b_index]`. 4) Cut one array in half, according to: - If `a_index + b_index < k`, cut one smaller half. - If `a_value < b_value`, cut the smaller half of `A`. - Otherwise, cut the smaller half of `B`. - Otherwise, cut one larger half. - If `b_value < a_value`, cut the larger half of `B`. - Otherwise, cut the larger half of `A`. 5) Repeat step 1 using the new starting and ending indexes of `A` and `B`. Then we move on to find the median elements, and get the length of both arrays `na = len(A)` and `nb = len(B)`. - If the total number of elements in `A` and `B` is odd, we just use the above function to find the middle element, that is `k = (na + nb) / 2`. - Otherwise, we use the function to find two middle elements: `k = (na + nb) / 2 - 1` and `k = (na + nb) / 2`, and return their average. Implementation Complexity Analysis Let m be the size of array `nums1` and n be the size of array `nums2`. * Time complexity: O(\\log(m \\cdot n)) - At each step, we cut one half off from either `nums1` or `nums2`. If one of the arrays is emptied, we can directly get the target from the other array in a constant time. Therefore, the total time spent depends on when one of the arrays is cut into an empty array. - In the worst-case scenario, we may need to cut both arrays before finding the target element. - One of the two arrays is cut in half at each step, thus it takes logarithmic time to empty an array. The time to empty two arrays are independent of each other.![img](../Figures/4/tc.png) - Therefore, the time complexity is O(\\log m + \\log n). O(\\log m + \\log n) = O(\\log (m\\cdot n)) * Space complexity: O(\\log m + \\log n) - Similar to the analysis on time complexity, the recursion steps depend on the number of iterations before we cut an array into an empty array. In the worst-case scenario, we need O(\\log m + \\log n) recursion steps. - However, during the recursive self-call, we only need to maintain 4 pointers: `a_start`, `a_end`, `b_start` and `b_end`. The last step of the function is to call itself, so if tail call optimization is implemented, the call stack always has O(1) records. - Please refer to [Tail Call](https://en.wikipedia.org/wiki/Tail_call) for more information on tail call optimization. Approach 3: A Better Binary Search Intuition Recall the previous approach where we perform a binary search over the 'merged' array consisting of `nums1` and `nums2`, resulting in a time complexity of O(\\log(m \\cdot n)). We could further improve the algorithm by performing the binary search only on the smaller array of `nums1` and `nums2`, thus the time complexity is reduced to O(\\log(\\min(m, n))). The main idea is similar to approach 2, where we need to find a point of partition in both arrays such that the maximum of the smaller half is less than or equal to the minimum of the larger half. However, instead of partitioning over the merged arrays, we can only focus on partitioning the smaller array (let's call this array `A`). Suppose the partition index is `partitionA`, we specify that the smaller half contains `(m + n + 1) / 2` elements, and we can use this feature to our advantage by directly making `partitionB` equal to `(m + n + 1) / 2 - partitionA`, thus the smaller halves of both arrays always contain a total of `(m + n + 1) / 2` elements, as shown in the picture below. ![img](../Figures/4/2_0.png) The next step is to compare these edge elements. ![img](../Figures/4/2_1.png) If both `maxLeftA <= minRightB` and `maxLeftB <= minRightA` hold, it means that we have partitioned arrays at the correct place. - The smaller half consists of two sections `A_left` and `B_left` - THe larger half consists of two sections `A_right` and `B_right` We just need to find the maximum value from the smaller half as `max(A[maxLeftA], B[maxLeftB])` and the minimum value from the larger half as `min(A[minRightA], B[minRightB])`. The median value depends on these four boundary values and the total length of the input arrays and we can compute it by situation. ![img](../Figures/4/2_2.png) If `maxLeftA > minRightB`, it implies that `maxLeftA` is too large to be in the smaller half and we should look for a smaller partition value of `A`. ![img](../Figures/4/2_3.png) Otherwise, it denotes that `minRightA` is too small to be in the larger half and we should look for a larger partition value of `A`. ![img](../Figures/4/2_4.png) Algorithm 1) Assuming `nums1` to be the smaller array (If `nums2` is smaller, we can swap them). Let `m, n` represent the size of `nums1` and `nums2`, respectively. 2) Define the search space for the partitioning index `partitionA` by setting boundaries as `left = 0` and `right = m`. 3) While `left <= right` holds, do the following. 4) Compute the partition index of `nums1` as `partitionA = (left + right) / 2`. Consequently, the partition index of `nums2` is `(m + n + 1) / 2 - partitionA`. 5) Obtain the edge elements: - Determine the maximum value of the section `A_left` as `maxLeftA = nums1[partitionA - 1]`. If `partitionA - 1 < 0`, set it as `maxLeftA = float(-inf)`. - Determine the minimum value of the section `A_right` as `minRightA = nums1[partitionA]`. If `partitionA >= m`, set it as `minRightA = float(inf)`. - Determine the maximum value of the section `B_left` as `maxLeftB = nums2[partitionB - 1]`. If `partitionB - 1 < 0`, set it as `maxLeftB = float(-inf)`. - Determine the maximum value of the section `B_right` as `minRightB = nums2[partitionB]`. If `partitionB >= n`, set it as `minRightB = float(inf)`. 6) Compare and recalculate: Compare `maxLeftA` with `minRightB` and `maxLeftB` with `minRightA`. - If `maxLeftA > minRightB`, it means the `maxLeftA` is too large to be in the smaller half, so we update `right = partitionA - 1` to move to the left half of the search space. - If `maxLeftB > minRightA`, it means that we are too far on the left side for `partitionA` and we need to go to the right half of the search space by updating `left = partitionA + 1`. Repeat step 4. 7) When both `maxLeftA <= minRightB` and `maxLeftB <= minRightA` are true: - If `(m + n) % 2 = 0`, the median value is the average of the maximum value of the smaller half and the minimum value of the larger half, given by `answer = (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2`. - Otherwise, the median value is the maximum value of the smaller half, given by `answer = max(maxLeftA, maxLeftB)`. Implementation Complexity Analysis Let m be the size of array `nums1` and n be the size of array `nums2`. * Time complexity: O(\\log(\\min(m, n))) - We perform a binary search over the smaller array of size \\min(m, n). * Space complexity: O(1) - The algorithm only requires a constant amount of additional space to store and update a few parameters during the binary search.",
    "constraints": [
      "nums1.length == m",
      "nums2.length == n",
      "0 <= m <= 1000",
      "0 <= n <= 1000",
      "1 <= m + n <= 2000",
      "-106 <= nums1[i], nums2[i] <= 106"
    ],
    "examples": [
      {
        "example_text": "Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2."
      },
      {
        "example_text": "Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
      }
    ]
  },
  {
    "problem_slug": "longest-palindromic-substring",
    "difficulty": "Medium",
    "topics": [
      "Two Pointers",
      "String",
      "Dynamic Programming"
    ],
    "description": "Given a string s, return the longest palindromic substring in s. Example 1: Example 2: Constraints:",
    "solution": "Video Solution Solution Approach 1: Check All Substrings Intuition We can start with a brute-force approach. We will simply check if each substring is a palindrome, and take the longest one that is. First, let's talk about how we can check if a given string is a palindrome. This is a classic problem and we can do it using two pointers. If a string is a palindrome, the first character is equal to the last character. The second character is equal to the second last character, and so on. ![Palindrome Check](../Figures/5/1.png) We initialize two pointers: one at the start of the string and another at the end of it. We check if the characters at the pointers are equal - if they aren't, we know the string cannot be a palindrome. If they are equal, we move to the next pair of characters by moving the pointers toward each other. We continue until we either find a mismatch or the pointers meet. If the pointers meet, then we have checked all pairs and we know the string is a palindrome. One bonus to using this algorithm is that we frequently exit early on strings that are not palindromes. If you had a string of length `1000` and the third and third last characters did not match, we would exit the algorithm after only 3 iterations. There's another optimization that we can do. Because the problem wants the longest palindrome, we can start by checking the longest-length substrings and iterate toward the shorter-length substrings. This way, the first time we find a substring that is a palindrome, we can immediately return it as the answer. Algorithm 1. Create a helper method `check(i, j)` to determine if a substring is a palindrome. - To save space, we will not pass the substring itself. Instead, we will pass two indices that represent the substring in question. The first character will be `s[i]` and the last character will be `s[j - 1]`. - In this function, declare two pointers `left = i` and `right = j - 1`. - While `left < right`, do the following steps: - If `s[left] != s[right]`, return `false`. - Otherwise, increment `left` and decrement `right`. - If we get through the while loop, return `true`. 2. Use a for loop to iterate a variable `length` starting from `s.length` until `1`. This variable represents the length of the substrings we are currently considering. 3. Use a for loop to iterate a variable `start` starting from `0` until and including `s.length - length`. This variable represents the starting point of the substring we are currently considering. 4. In each inner loop iteration, we are considering the substring starting at `start` until `start + length`. Pass these values into `check` to see if this substring is a palindrome. If it is, return the substring. ImplementationComplexity Analysis Given n as the length of `s`, * Time complexity: O(n^3) The two nested for loops iterate O(n^2) times. We check one substring of length `n`, two substrings of length `n - 1`, three substrings of length `n - 2`, and so on. There are `n` substrings of length 1, but we don't check them all since any substring of length 1 is a palindrome, and we will return immediately. Therefore, the number of substrings that we check in the worst case is `1 + 2 + 3 + ... + n - 1`. This is the partial sum of [this series](https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AFPartial_sums) for `n - 1`, which is equal to \\frac{n \\cdot (n - 1)}{2} = O(n^2). In each iteration of the while loop, we perform a palindrome check. The cost of this check is linear with `n` as well, giving us a time complexity of O(n^3). Note that this time complexity is in the worst case and has a significant constant divisor that is dropped by big O. Due to the optimizations of checking the longer length substrings first and exiting the palindrome check early if we determine that a substring cannot be a palindrome, the practical runtime of this algorithm is not too bad. * Space complexity: O(1) We don't count the answer as part of the space complexity. Thus, all we use are a few integer variables. Approach 2: Dynamic Programming Intuition Let's say that we knew the substring with inclusive bounds `i, j` was a palindrome. If `s[i - 1] == s[j + 1]`, then we know the substring with inclusive bounds `i - 1, j + 1` must also be a palindrome, and this check can be done in constant time. We can flip the direction of this logic as well - if `s[i] == s[j]` and the substring `i + 1, j - 1` is a palindrome, then the substring `i, j` must also be a palindrome. ![DP Example](../Figures/5/2.png) We know that all substrings of length 1 are palindromes. From this, we can check if each substring of length 3 is a palindrome using the above fact. We just need to check every `i, j` pair where `j - i = 2`. Once we know all palindromes of length 3, we can use that information to find all palindromes of length 5, and then 7, and so on. What about even-length palindromes? A substring of length 2 is a palindrome if both characters are equal. That is, `i, i + 1` is a palindrome if `s[i] == s[i + 1]`. From this, we can use the earlier logic to find all palindromes of length 4, then 6, and so on. Let's use a table `dp` with dimensions of `n * n`. `dp[i][j]` is a boolean representing if the substring with inclusive bounds `i, j` is a palindrome. We initialize `dp[i][i] = true` for the substrings of length 1, and then `dp[i][i + 1] = (s[i] == s[i + 1])` for the substrings of length 2. Now, we need to populate the table. We iterate over all `i, j` pairs, starting with pairs that have a difference of 2 (representing substrings of length 3), then pairs with a difference of 3, then 4, and so on. For each `i, j` pair, we check the condition from earlier: `s[i] == s[j] && dp[i + 1][j - 1]` If this condition is true, then the substring with inclusive bounds `i, j` must be a palindrome. We set `dp[i][j] = true`. Because we are starting with the shortest substrings and iterating toward the longest substrings, every time we find a new palindrome, it must be the longest one we have seen so far. We can use this fact to keep track of the answer on the fly. Algorithm 1. Initialize `n = s.length` and a boolean table `dp` with size `n * n`, and all values to `false`. 2. Initialize `ans = [0, 0]`. This will hold the inclusive bounds of the answer. 3. Set all `dp[i][i] = true`. 4. Iterate over all pairs `i, i + 1`. For each one, if `s[i] == s[i + 1]`, then set `dp[i][i + 1] = true` and update `ans = [i, i + 1]`. 5. Now, we populate the `dp` table. Iterate over `diff` from `2` until `n`. This variable represents the difference `j - i`. 6. In a nested for loop, iterate over `i` from `0` until `n - diff`. - Set `j = i + diff`. - Check the condition: if `s[i] == s[j] && dp[i + 1][j - 1]`, we found a palindrome. - In that case, set `dp[i][j] = true` and `ans = [i, j]` 7. Retrieve the answer bounds from `ans` as `i, j`. Return the substring of `s` starting at index `i` and ending with index `j`. ImplementationComplexity Analysis Given n as the length of `s`, * Time complexity: O(n^2) We declare an `n * n` table `dp`, which takes O(n^2) time. We then populate O(n^2) states `i, j` - each state takes O(1) time to compute. * Space complexity: O(n^2) The table `dp` takes O(n^2) space. Approach 3: Expand From Centers Intuition In the first approach, the palindrome check cost O(n). In the second approach, the palindrome check cost O(1). This allowed us to improve the time complexity from O(n^3) to O(n^2). The problem with the second approach is that we always iterated over O(n^2) states of `i, j`. Can we optimize further to minimize the number of iterations required? In the first approach, we implemented a palindrome check using two pointers. We started by checking the first and last characters, then the second and second last characters, and so on. Instead of starting the pointers at the edges and moving inwards, the same logic can be applied when starting the pointers at the center and moving outwards. A palindrome mirrors around its center. Let's say you had `s = \"racecar\"`. If we start both pointers at the middle (`\"e\"`) and move them away from each other, we can see that at every iteration, the characters match: `e -> c -> a -> r`. The previous two approaches focused on the bounds of a substring - `i, j`. There are O(n^2) bounds, but only O(n) centers. For each index `i`, we can consider odd-length palindromes by starting the pointers at `i, i`. To consider the even length palindromes, we can start the pointers at `i, i + 1`. There are n starting points for the odd-length palindromes and n - 1 starting points for the even-length palindromes - that's 2n - 1 = O(n) starting points in total. This is very promising - we can lower the minimum iterations required if we focus on the centers instead of on the bounds. Let's use a helper method `expand(i, j)` that starts two pointers `left = i` and `right = j`. In this method, we will consider `i, j` as a center. When `i == j`, we are considering odd-length palindromes. When `i != j`, we are considering even-length palindromes. We will expand from the center as far as we can to find the longest palindrome, and then return the length of this palindrome. Let's say that we have a center `i, i`. We call `expand` and find a length of `length`. What are the bounds of the palindrome? Because we are centered at `i, i`, it means `length` must be odd. If we perform floor division of `length` by 2, we will get the number of characters `dist` on each side of the palindrome. For example, given `s = \"racecar\"`, we have `length = 7` and `dist = 7 / 2 = 3`. There are 3 characters on each side - `\"rac\"` on the left and `\"car\"` on the right. Therefore, we can determine that the bounds of the palindrome are `i - dist, i + dist`. What about a center at `i, i + 1`? `length` must be even now. If we have a palindrome with length `2`, then `length / 2 = 1`, but there are zero characters on each side of the center. We can see that `dist` is too large by 1. Therefore, we will calculate `dist` as `(length / 2) - 1` instead. Now, `dist` correctly represents the number of characters on each side. The bounds of the palindrome are `i - dist, i + 1 + dist`. Algorithm 1. Create a helper method `expand(i, j)` to find the length of the longest palindrome centered at `i, j`. - Set `left = i` and `right = j`. - While `left` and `right` are both in bounds and `s[left] == s[right]`, move the pointers away from each other. - The formula for the length of a substring starting at `left` and ending at `right` is `right - left + 1`. - However, when the while loop ends, it implies `s[left] != s[right]`. Therefore, we need to subtract `2`. Return `right - left - 1`. 2. Initialize `ans = [0, 0]`. This will hold the inclusive bounds of the answer. 3. Iterate `i` over all indices of `s`. - Find the length of the longest odd-length palindrome centered at `i`: `oddLength = expand(i, i)`. - If `oddLength` is the greatest length we have seen so far, i.e. `oddLength > ans[1] - ans[0] + 1`, update `ans`. - Find the length of the longest even-length palindrome centered at `i`: `evenLength = expand(i, i + 1)`. - If `evenLength` is the greatest length we have seen so far, update `ans`. 4. Retrieve the answer bounds from `ans` as `i, j`. Return the substring of `s` starting at index `i` and ending with index `j`. ImplementationComplexity Analysis Given n as the length of `s`, * Time complexity: O(n^2) There are 2n - 1 = O(n) centers. For each center, we call `expand`, which costs up to O(n). Although the time complexity is the same as in the DP approach, the average/practical runtime of the algorithm is much faster. This is because most centers will not produce long palindromes, so most of the O(n) calls to `expand` will cost far less than n iterations. The worst case scenario is when every character in the string is the same. * Space complexity: O(1) We don't use any extra space other than a few integers. This is a big improvement on the DP approach. Approach 4: Manacher's Algorithm Believe it or not, this problem can be solved in linear time. [Manacher's algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substringManacher's_algorithm) finds the longest palindromic substring in O(n) time and space. Note: this algorithm is completely out of scope for coding interviews. Because of this, we will not be talking about the algorithm in detail. This approach has been included for the sake of completeness and for those who are curious about algorithms beyond the scope of interviews. If you wish to learn more about Manacher's algorithm, please reference the above link. ImplementationComplexity Analysis Given n as the length of `s`, * Time complexity: O(n) From Wikipedia (the implementation they describe is slightly different from the above code, but it's the same algorithm): > The algorithm runs in linear time. This can be seen by noting that Center strictly increases after each outer loop and the sum Center + Radius is non-decreasing. Moreover, the number of operations in the first inner loop is linear in the increase of the sum Center + Radius while the number of operations in the second inner loop is linear in the increase of Center. Since Center \\leq 2n+1 and Radius \\leq n, the total number of operations in the first and second inner loops is O(n) and the total number of operations in the outer loop, other than those in the inner loops, is also O(n). The overall running time is therefore O(n). * Space complexity: O(n) We use `sPrime` and `palindromeRadii`, both of length O(n).",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consist of only digits and English letters."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"babad\" Output: \"bab\" Explanation: \"aba\" is also a valid answer."
      },
      {
        "example_text": "Input: s = \"cbbd\" Output: \"bb\""
      }
    ]
  },
  {
    "problem_slug": "zigzag-conversion",
    "difficulty": "Medium",
    "topics": [
      "String"
    ],
    "description": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of English letters (lower-case and upper-case), ',' and '.'.",
      "1 <= numRows <= 1000"
    ],
    "examples": [
      {
        "example_text": "P A H N A P L S I I G Y I R"
      },
      {
        "example_text": "string convert(string s, int numRows);"
      },
      {
        "example_text": "Input: s = \"PAYPALISHIRING\", numRows = 3 Output: \"PAHNAPLSIIGYIR\""
      },
      {
        "example_text": "Input: s = \"PAYPALISHIRING\", numRows = 4 Output: \"PINALSIGYAHRPI\" Explanation: P I N A L S I G Y A H R P I"
      },
      {
        "example_text": "Input: s = \"A\", numRows = 1 Output: \"A\""
      }
    ]
  },
  {
    "problem_slug": "reverse-integer",
    "difficulty": "Medium",
    "topics": [
      "Math"
    ],
    "description": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0. Assume the environment does not allow you to store 64-bit integers (signed or unsigned). Example 1: Example 2: Example 3: Constraints:",
    "solution": "Video Solution Solution Article Approach 1: Pop and Push Digits & Check before Overflow Intuition We can build up the reverse integer one digit at a time. While doing so, we can check beforehand whether or not appending another digit would cause overflow. Algorithm Reversing an integer can be done similarly to reversing a string. We want to repeatedly \"pop\" the last digit off of x and \"push\" it to the back of the \\text{rev}. In the end, \\text{rev} will be the reverse of the x. To \"pop\" and \"push\" digits without the help of some auxiliary stack/array, we can use math. ```cpp // pop operation: pop = x % 10; x /= 10; // push operation: temp = rev * 10 + pop; rev = temp; ``` However, this approach is dangerous, because the statement \\text{temp} = \\text{rev} \\cdot 10 + \\text{pop} can cause overflow. Luckily, it is easy to check beforehand whether or this statement would cause an overflow. To explain, lets assume that \\text{rev} is positive. 1. If temp = \\text{rev} \\cdot 10 + \\text{pop} causes overflow, then it must be that \\text{rev} \\geq \\frac{INTMAX}{10} 2. If \\text{rev} > \\frac{INTMAX}{10}, then temp = \\text{rev} \\cdot 10 + \\text{pop} is guaranteed to overflow. 3. If \\text{rev} == \\frac{INTMAX}{10}, then temp = \\text{rev} \\cdot 10 + \\text{pop} will overflow if and only if \\text{pop} > 7 Similar logic can be applied when \\text{rev} is negative.Complexity Analysis * Time Complexity: O(\\log(x)). There are roughly \\log_{10}(x) digits in x. * Space Complexity: O(1).",
    "constraints": [
      "-231 <= x <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: x = 123 Output: 321"
      },
      {
        "example_text": "Input: x = -123 Output: -321"
      },
      {
        "example_text": "Input: x = 120 Output: 21"
      }
    ]
  },
  {
    "problem_slug": "string-to-integer-atoi",
    "difficulty": "Medium",
    "topics": [
      "String"
    ],
    "description": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer. The algorithm for myAtoi(string s) is as follows: Return the integer as the final result. Example 1: Example 2: Example 3: Example 4: Example 5: Constraints:",
    "solution": "",
    "constraints": [
      "0 <= s.length <= 200",
      "s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'."
    ],
    "examples": [
      {
        "example_text": "The underlined characters are what is read in and the caret is the current reader position. Step 1: \"42\" (no characters read because there is no leading whitespace) ^ Step 2: \"42\" (no characters read because there is neither a '-' nor '+') ^ Step 3: \"42\" (\"42\" is read in) ^"
      },
      {
        "example_text": "Step 1: \" -042\" (leading whitespace is read and ignored) ^ Step 2: \" -042\" ('-' is read, so the result should be negative) ^ Step 3: \" -042\" (\"042\" is read in, leading zeros ignored in the result) ^"
      },
      {
        "example_text": "Step 1: \"1337c0d3\" (no characters read because there is no leading whitespace) ^ Step 2: \"1337c0d3\" (no characters read because there is neither a '-' nor '+') ^ Step 3: \"1337c0d3\" (\"1337\" is read in; reading stops because the next character is a non-digit) ^"
      },
      {
        "example_text": "Step 1: \"0-1\" (no characters read because there is no leading whitespace) ^ Step 2: \"0-1\" (no characters read because there is neither a '-' nor '+') ^ Step 3: \"0-1\" (\"0\" is read in; reading stops because the next character is a non-digit) ^"
      }
    ]
  },
  {
    "problem_slug": "palindrome-number",
    "difficulty": "Easy",
    "topics": [
      "Math"
    ],
    "description": "Given an integer x, return true if x is a palindrome, and false otherwise. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "-231 <= x <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: x = 121 Output: true Explanation: 121 reads as 121 from left to right and from right to left."
      },
      {
        "example_text": "Input: x = -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome."
      },
      {
        "example_text": "Input: x = 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome."
      }
    ]
  },
  {
    "problem_slug": "regular-expression-matching",
    "difficulty": "Hard",
    "topics": [
      "String",
      "Dynamic Programming",
      "Recursion"
    ],
    "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where: The matching should cover the entire input string (not partial). Example 1: Example 2: Example 3: Constraints:",
    "solution": "Solution Approach 1: Recursion Intuition If there were no Kleene stars (the `*` wildcard character for regular expressions), the problem would be easier - we simply check from left to right if each character of the text matches the pattern. When a star is present, we may need to check many different suffixes of the text and see if they match the rest of the pattern. A recursive solution is a straightforward way to represent this relationship. Algorithm Without a Kleene star, our solution would look like this:If a star is present in the pattern, it will be in the second position \\text{pattern[1]}. Then, we may ignore this part of the pattern, or delete a matching character in the text. If we have a match on the remaining strings after any of these operations, then the initial inputs matched.Complexity Analysis * Time Complexity: Let T, P be the lengths of the text and the pattern respectively. In the worst case, a call to `match(text[i:], pattern[2j:])` will be made \\binom{i+j}{i} times, and strings of the order O(T - i) and O(P - 2*j) will be made. Thus, the complexity has the order \\sum_{i = 0}^T \\sum_{j = 0}^{P/2} \\binom{i+j}{i} O(T+P-i-2j). With some effort outside the scope of this article, we can show this is bounded by O\\big((T+P)2^{T + \\frac{P}{2}}\\big). * Space Complexity: For every call to `match`, we will create those strings as described above, possibly creating duplicates. If memory is not freed, this will also take a total of O\\big((T+P)2^{T + \\frac{P}{2}}\\big) space, even though there are only order O(T^2 + P^2) unique suffixes of P and T that are actually required. Approach 2: Dynamic Programming Intuition As the problem has an optimal substructure, it is natural to cache intermediate results. We ask the question \\text{dp(i, j)}: does \\text{text[i:]} and \\text{pattern[j:]} match? We can describe our answer in terms of answers to questions involving smaller strings. Algorithm We proceed with the same recursion as in [Approach 1](approach-1-recursion), except because calls will only ever be made to `match(text[i:], pattern[j:])`, we use \\text{dp(i, j)} to handle those calls instead, saving us expensive string-building operations and allowing us to cache the intermediate results. *Top-Down VariationBottom-Up Variation*Complexity Analysis * Time Complexity: Let T, P be the lengths of the text and the pattern respectively. The work for every call to `dp(i, j)` for i=0, ... ,T; j=0, ... ,P is done once, and it is O(1) work. Hence, the time complexity is O(TP). * Space Complexity: The only memory we use is the O(TP) boolean entries in our cache. Hence, the space complexity is O(TP).",
    "constraints": [
      "1 <= s.length <= 20",
      "1 <= p.length <= 20",
      "s contains only lowercase English letters.",
      "p contains only lowercase English letters, '.', and '*'.",
      "It is guaranteed for each appearance of the character '*', there will be a previous valid character to match."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"aa\", p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\"."
      },
      {
        "example_text": "Input: s = \"aa\", p = \"a*\" Output: true Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\"."
      },
      {
        "example_text": "Input: s = \"ab\", p = \".*\" Output: true Explanation: \".*\" means \"zero or more (*) of any character (.)\"."
      }
    ]
  },
  {
    "problem_slug": "container-with-most-water",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "n == height.length",
      "2 <= n <= 105",
      "0 <= height[i] <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49."
      },
      {
        "example_text": "Input: height = [1,1] Output: 1"
      }
    ]
  },
  {
    "problem_slug": "integer-to-roman",
    "difficulty": "Medium",
    "topics": [
      "Hash Table",
      "Math",
      "String"
    ],
    "description": "Seven different symbols represent Roman numerals with the following values: Roman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules: Given an integer, convert it to a Roman numeral. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= num <= 3999"
    ],
    "examples": [
      {
        "example_text": "3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M) 700 = DCC as 500 (D) + 100 (C) + 100 (C) 40 = XL as 10 (X) less of 50 (L) 9 = IX as 1 (I) less of 10 (X) Note: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places"
      },
      {
        "example_text": "50 = L 8 = VIII"
      },
      {
        "example_text": "1000 = M 900 = CM 90 = XC 4 = IV"
      }
    ]
  },
  {
    "problem_slug": "roman-to-integer",
    "difficulty": "Easy",
    "topics": [
      "Hash Table",
      "Math",
      "String"
    ],
    "description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: Given a roman numeral, convert it to an integer. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 15",
      "s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').",
      "It is guaranteed that s is a valid roman numeral in the range [1, 3999]."
    ],
    "examples": [
      {
        "example_text": "Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000"
      },
      {
        "example_text": "Input: s = \"III\" Output: 3 Explanation: III = 3."
      },
      {
        "example_text": "Input: s = \"LVIII\" Output: 58 Explanation: L = 50, V= 5, III = 3."
      },
      {
        "example_text": "Input: s = \"MCMXCIV\" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4."
      }
    ]
  },
  {
    "problem_slug": "longest-common-prefix",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "String",
      "Trie"
    ],
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". Example 1: Example 2: Constraints:",
    "solution": "Video Solution Solution Article Approach 1: Horizontal scanning Intuition For a start we will describe a simple way of finding the longest prefix shared by a set of strings LCP(S_1 \\ldots S_n). We will use the observation that : LCP(S_1 \\ldots S_n) = LCP(LCP(LCP(S_1, S_2),S_3),\\ldots S_n) Algorithm To employ this idea, the algorithm iterates through the strings [S_1 \\ldots S_n], finding at each iteration i the longest common prefix of strings LCP(S_1 \\ldots S_i) When LCP(S_1 \\ldots S_i) is an empty string, the algorithm ends. Otherwise after n iterations, the algorithm returns LCP(S_1 \\ldots S_n). ![Finding the longest common prefix](https://leetcode.com/media/original_images/14_basic.png){:width=\"539px\"} *Figure 1. Finding the longest common prefix (Horizontal scanning)* Implementation Complexity Analysis * Time complexity : O(S) , where S is the sum of all characters in all strings. In the worst case all n strings are the same. The algorithm compares the string S1 with the other strings [S_2 \\ldots S_n] There are S character comparisons, where S is the sum of all characters in the input array. * Space complexity : O(1). We only used constant extra space. Approach 2: Vertical scanning Algorithm Imagine a very short string is the common prefix at the end of the array. The above approach will still do S comparisons. One way to optimize this case is to do vertical scanning. We compare characters from top to bottom on the same column (same character index of the strings) before moving on to the next column. Implementation Complexity Analysis * Time complexity : O(S) , where S is the sum of all characters in all strings. In the worst case there will be n equal strings with length m and the algorithm performs S = m \\cdot n character comparisons. Even though the worst case is still the same as [Approach 1](approach-1-horizontal-scanning), in the best case there are at most n \\cdot minLen comparisons where minLen is the length of the shortest string in the array. * Space complexity : O(1). We only used constant extra space. Approach 3: Divide and conquer Intuition The idea of the algorithm comes from the associative property of LCP operation. We notice that : LCP(S_1 \\ldots S_n) = LCP(LCP(S_1 \\ldots S_k), LCP (S_{k+1} \\ldots S_n)) , where LCP(S_1 \\ldots S_n) is the longest common prefix in set of strings [S_1 \\ldots S_n] , 1 < k < n Algorithm To apply the observation above, we use divide and conquer technique, where we split the LCP(S_i \\ldots S_j) problem into two subproblems LCP(S_i \\ldots S_{mid}) and LCP(S_{mid+1} \\ldots S_j), where `mid` is \\frac{i + j}{2}. We use their solutions `lcpLeft` and `lcpRight` to construct the solution of the main problem LCP(S_i \\ldots S_j). To accomplish this we compare one by one the characters of `lcpLeft` and `lcpRight` till there is no character match. The found common prefix of `lcpLeft` and `lcpRight` is the solution of the LCP(S_i \\ldots S_j). ![Finding the longest common prefix](https://leetcode.com/media/original_images/14_lcp_diviso_et_lmpera.png){:width=\"539px\"} *Figure 2. Finding the longest common prefix of strings using divide and conquer technique* Implementation Complexity Analysis In the worst case we have n equal strings with length m * Time complexity : O(S), where S is the number of all characters in the array, S = m \\cdot n Time complexity is 2 \\cdot T\\left ( \\frac{n}{2} \\right ) + O(m). Therefore time complexity is O(S). In the best case this algorithm performs O(minLen \\cdot n) comparisons, where minLen is the shortest string of the array * Space complexity : O(m \\cdot \\log n) There is a memory overhead since we store recursive calls in the execution stack. There are \\log n recursive calls, each store need m space to store the result, so space complexity is O(m \\cdot \\log n) Approach 4: Binary search Intuition The idea is to apply binary search method to find the string with maximum value `L`, which is common prefix of all of the strings. The algorithm searches space is the interval (0 \\ldots minLen), where `minLen` is minimum string length and the maximum possible common prefix. Each time search space is divided in two equal parts, one of them is discarded, because it is sure that it doesn't contain the solution. There are two possible cases: * `S[1...mid]` is not a common string. This means that for each `j > i S[1..j]` is not a common string and we discard the second half of the search space. * `S[1...mid]` is common string. This means that for each `i < j S[1..i]` is a common string and we discard the first half of the search space, because we try to find longer common prefix. ![Finding the longest common prefix](https://leetcode.com/media/original_images/14_lcp_binary_search.png){:width=\"539px\"} *Figure 3. Finding the longest common prefix of strings using binary search technique* Implementation Complexity Analysis In the worst case we have n equal strings with length m * Time complexity : O(S \\cdot \\log m), where S is the sum of all characters in all strings. The algorithm makes \\log m iterations, for each of them there are S = m \\cdot n comparisons, which gives in total O(S \\cdot \\log m) time complexity. * Space complexity : O(1). We only used constant extra space. Further Thoughts / Follow up Let's take a look at a slightly different problem: > Given a set of keys S = [S_1,S_2 \\ldots S_n], find the longest common prefix among a string `q` and S. This LCP query will be called frequently. We could optimize LCP queries by storing the set of keys S in a Trie. For more information about Trie, please see this article [Implement a trie (Prefix trie)](https://leetcode.com/articles/implement-trie-prefix-tree/). In a Trie, each node descending from the root represents a common prefix of some keys. But we need to find the longest common prefix of a string `q` and all key strings. This means that we have to find the deepest path from the root, which satisfies the following conditions: * it is prefix of query string `q` * each node along the path must contain only one child element. Otherwise the found path will not be a common prefix among all strings. * the path doesn't comprise of nodes which are marked as end of key. Otherwise the path couldn't be a prefix a of key which is shorter than itself. Algorithm The only question left, is how to find the deepest path in the Trie, that fulfills the requirements above. The most effective way is to build a trie from [S_1 \\ldots S_n] strings. Then find the prefix of query string `q` in the Trie. We traverse the Trie from the root, till it is impossible to continue the path in the Trie because one of the conditions above is not satisfied. ![Finding the longest common prefix using Trie](../Figures/14/14_lcp_trie_fix.png) *Figure 4. Finding the longest common prefix of strings using Trie* Implementation Complexity Analysis In the worst case query q has length m and it is equal to all n strings of the array. * Time complexity : preprocessing O(S), where S is the number of all characters in the array, LCP query O(m). Trie build has O(S) time complexity. To find the common prefix of q in the Trie takes in the worst case O(m). * Space complexity : O(S). We only used additional S extra space for the Trie.",
    "constraints": [
      "1 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "strs[i] consists of only lowercase English letters if it is non-empty."
    ],
    "examples": [
      {
        "example_text": "Input: strs = [\"flower\",\"flow\",\"flight\"] Output: \"fl\""
      },
      {
        "example_text": "Input: strs = [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings."
      }
    ]
  },
  {
    "problem_slug": "3sum",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "3 <= nums.length <= 3000",
      "-105 <= nums[i] <= 105"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2]. Notice that the order of the output and the order of the triplets does not matter."
      },
      {
        "example_text": "Input: nums = [0,1,1] Output: [] Explanation: The only possible triplet does not sum up to 0."
      },
      {
        "example_text": "Input: nums = [0,0,0] Output: [[0,0,0]] Explanation: The only possible triplet sums up to 0."
      }
    ]
  },
  {
    "problem_slug": "3sum-closest",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "description": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "3 <= nums.length <= 500",
      "-1000 <= nums[i] <= 1000",
      "-104 <= target <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [-1,2,1,-4], target = 1 Output: 2 Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2)."
      },
      {
        "example_text": "Input: nums = [0,0,0], target = 1 Output: 0 Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0)."
      }
    ]
  },
  {
    "problem_slug": "letter-combinations-of-a-phone-number",
    "difficulty": "Medium",
    "topics": [
      "Hash Table",
      "String",
      "Backtracking"
    ],
    "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "0 <= digits.length <= 4",
      "digits[i] is a digit in the range ['2', '9']."
    ],
    "examples": [
      {
        "example_text": "Input: digits = \"23\" Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
      },
      {
        "example_text": "Input: digits = \"\" Output: []"
      },
      {
        "example_text": "Input: digits = \"2\" Output: [\"a\",\"b\",\"c\"]"
      }
    ]
  },
  {
    "problem_slug": "4sum",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "description": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: You may return the answer in any order. Example 1: Example 2: Constraints:",
    "solution": "Solution This problem is a follow-up of [3Sum](https://leetcode.com/articles/3sum/), so take a look at that problem first if you haven't. 4Sum and 3Sum are very similar; the difference is that we are looking for unique quadruplets instead of triplets. As you see, 3Sum just wraps Two Sum in an outer loop. As it iterates through each value `v`, it finds all pairs whose sum is equal to `target - v` using one of these approaches: 1. [Two Sum](https://leetcode.com/articles/two-sum/) uses a hash set to check for a matching value. 2. [Two Sum II](https://leetcode.com/articles/two-sum-ii-input-array-is-sorted/) uses the two pointers pattern in a sorted array. Following a similar logic, we can implement 4Sum by wrapping 3Sum in another loop. But wait - there is a catch. If an interviewer asks you to solve 4Sum, they can follow-up with 5Sum, 6Sum, and so on. What they are really expecting at this point is a kSum solution. Therefore, we will focus on a generalized implementation here. Approach 1: Two Pointers Intuition The two pointers pattern requires the array to be sorted, so we do that first. Also, it's easier to deal with duplicates if the array is sorted: repeated values are next to each other and easy to skip. For 3Sum, we enumerate each value in a single loop, and use the two pointers pattern for the rest of the array. For kSum, we will have `k - 2` nested loops to enumerate all combinations of `k - 2` values. !?!../Documents/18_4Sum.json:1200,440!?! Algorithm We can implement `k - 2` loops using a recursion. We will pass the starting point and `k` as the parameters. When `k == 2`, we will call `twoSum`, terminating the recursion. 1. For the main function: - Sort the input array `nums`. - Call `kSum` with `start = 0`, `k = 4`, and `target`, and return the result. 2. For `kSum` function: - At the start of the `kSum` function, we will check three conditions: 1. Have we run out of numbers to choose from? 2. Is the smallest number remaining greater than `target / k`?If so, then any `k` numbers we choose will be too large. 3. Is the largest number remaining smaller than `target / k`?If so, then any `k` numbers we choose will be too small. - If any of these conditions is true, there is no need to continue as no combination of the remaining elements can sum to `target`. - If `k` equals `2`, call `twoSum` and return the result. - Iterate `i` through the array from `start`: - If the current value is the same as the one before, skip it. - Recursively call `kSum` with `start = i + 1`, `k = k - 1`, and `target - nums[i]`. - For each returned `subset` of values: - Include the current value `nums[i]` into `subset`. - Add `subset` to the result `res`. - Return the result `res`. 3. For `twoSum` function: - Set the low pointer `lo` to `start`, and high pointer `hi` to the last index. - While low pointer is smaller than high: - If the sum of `nums[lo]` and `nums[hi]` is less than `target`, increment `lo`. - Also increment `lo` if the value is the same as for `lo - 1`. - If the sum is greater than `target`, decrement `hi`. - Also decrement `hi` if the value is the same as for `hi + 1`. - Otherwise, we found a pair: - Add it to the result `res`. - Decrement `hi` and increment `lo`. - Return the result `res`. ImplementationComplexity Analysis - Time Complexity: O(n^{k - 1}), or O(n^3) for 4Sum. We have k - 2 loops, and `twoSum` is O(n). Note that for k > 2, sorting the array does not change the overall time complexity. - Space Complexity: O(n). We need O(k) space for the recursion. k can be the same as n in the worst case for the generalized algorithm. Note that, for the purpose of complexity analysis, we ignore the memory required for the output. Approach 2: Hash Set Intuition Since elements must sum up to the exact target value, we can also use the [Two Sum: One-pass Hash Table](https://leetcode.com/articles/two-sum/approach-3-one-pass-hash-table) approach. In [3Sum: Hash Set](https://leetcode.com/articles/3sum/approach-2-hash-set), we solved the problem without sorting the array. To do that, we needed to sort values within triplets, and track them in a hash set. Doing the same for k values could be impractical. So, for this approach, we will also sort the array and skip duplicates the same way as in the Two Pointers approach above. Thus, the code will only differ in the `twoSum` implementation. Algorithm `twoSum` implementation here is almost the same as in [Two Sum: One-pass Hash Table](https://leetcode.com/articles/two-sum/approach-3-one-pass-hash-table). The only difference is the check to avoid duplicates. Since the array is sorted, we can just compare the found pair with the last one in the result `res`. ImplementationComplexity Analysis - Time Complexity: O(n^{k - 1}), or O(n^3) for 4Sum. We have k - 2 loops iterating over n elements, and `twoSum` is O(n). Note that for k > 2, sorting the array does not change the overall time complexity. - Space Complexity: O(n) for the hash set. The space needed for the recursion will not exceed O(n).",
    "constraints": [
      "1 <= nums.length <= 200",
      "-109 <= nums[i] <= 109",
      "-109 <= target <= 109"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,0,-1,0,-2,2], target = 0 Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]"
      },
      {
        "example_text": "Input: nums = [2,2,2,2,2], target = 8 Output: [[2,2,2,2]]"
      }
    ]
  },
  {
    "problem_slug": "remove-nth-node-from-end-of-list",
    "difficulty": "Medium",
    "topics": [
      "Linked List",
      "Two Pointers"
    ],
    "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head. Example 1: Example 2: Example 3: Constraints: Follow up: Could you do this in one pass?",
    "solution": "",
    "constraints": [
      "The number of nodes in the list is sz.",
      "1 <= sz <= 30",
      "0 <= Node.val <= 100",
      "1 <= n <= sz"
    ],
    "examples": [
      {
        "example_text": "Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5]"
      },
      {
        "example_text": "Input: head = [1], n = 1 Output: []"
      },
      {
        "example_text": "Input: head = [1,2], n = 1 Output: [1]"
      }
    ]
  },
  {
    "problem_slug": "valid-parentheses",
    "difficulty": "Easy",
    "topics": [
      "String",
      "Stack"
    ],
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Example 1: Example 2: Example 3: Example 4: Example 5: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 104",
      "s consists of parentheses only '()[]{}'."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"()\" Output: true"
      },
      {
        "example_text": "Input: s = \"()[]{}\" Output: true"
      },
      {
        "example_text": "Input: s = \"(]\" Output: false"
      },
      {
        "example_text": "Input: s = \"([])\" Output: true"
      },
      {
        "example_text": "Input: s = \"([)]\" Output: false"
      }
    ]
  },
  {
    "problem_slug": "merge-two-sorted-lists",
    "difficulty": "Easy",
    "topics": [
      "Linked List",
      "Recursion"
    ],
    "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50].",
      "-100 <= Node.val <= 100",
      "Both list1 and list2 are sorted in non-decreasing order."
    ],
    "examples": [
      {
        "example_text": "Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4]"
      },
      {
        "example_text": "Input: list1 = [], list2 = [] Output: []"
      },
      {
        "example_text": "Input: list1 = [], list2 = [0] Output: [0]"
      }
    ]
  },
  {
    "problem_slug": "generate-parentheses",
    "difficulty": "Medium",
    "topics": [
      "String",
      "Dynamic Programming",
      "Backtracking"
    ],
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "example_text": "Input: n = 3 Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]"
      },
      {
        "example_text": "Input: n = 1 Output: [\"()\"]"
      }
    ]
  },
  {
    "problem_slug": "merge-k-sorted-lists",
    "difficulty": "Hard",
    "topics": [
      "Linked List",
      "Divide and Conquer",
      "Heap (Priority Queue)",
      "Merge Sort"
    ],
    "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "k == lists.length",
      "0 <= k <= 104",
      "0 <= lists[i].length <= 500",
      "-104 <= lists[i][j] <= 104",
      "lists[i] is sorted in ascending order.",
      "The sum of lists[i].length will not exceed 104."
    ],
    "examples": [
      {
        "example_text": "Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are: [ 1->4->5, 1->3->4, 2->6 ] merging them into one sorted linked list: 1->1->2->3->4->4->5->6"
      },
      {
        "example_text": "Input: lists = [] Output: []"
      },
      {
        "example_text": "Input: lists = [[]] Output: []"
      }
    ]
  },
  {
    "problem_slug": "swap-nodes-in-pairs",
    "difficulty": "Medium",
    "topics": [
      "Linked List",
      "Recursion"
    ],
    "description": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.) Example 1: Example 2: Example 3: Example 4: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the list is in the range [0, 100].",
      "0 <= Node.val <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: head = [1,2,3,4] Output: [2,1,4,3] Explanation:"
      },
      {
        "example_text": "Input: head = [] Output: []"
      },
      {
        "example_text": "Input: head = [1] Output: [1]"
      },
      {
        "example_text": "Input: head = [1,2,3] Output: [2,1,3]"
      }
    ]
  },
  {
    "problem_slug": "reverse-nodes-in-k-group",
    "difficulty": "Hard",
    "topics": [
      "Linked List",
      "Recursion"
    ],
    "description": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed. Example 1: Example 2: Constraints: Follow-up: Can you solve the problem in O(1) extra memory space?",
    "solution": "",
    "constraints": [
      "The number of nodes in the list is n.",
      "1 <= k <= n <= 5000",
      "0 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "example_text": "Input: head = [1,2,3,4,5], k = 2 Output: [2,1,4,3,5]"
      },
      {
        "example_text": "Input: head = [1,2,3,4,5], k = 3 Output: [3,2,1,4,5]"
      }
    ]
  },
  {
    "problem_slug": "remove-duplicates-from-sorted-array",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Two Pointers"
    ],
    "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things: Custom Judge: The judge will test your solution with the following code: If all assertions pass, then your solution will be accepted. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 3 * 104",
      "-100 <= nums[i] <= 100",
      "nums is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "example_text": "int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i < k; i++) { assert nums[i] == expectedNums[i]; }"
      },
      {
        "example_text": "Input: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores)."
      },
      {
        "example_text": "Input: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores)."
      }
    ]
  },
  {
    "problem_slug": "remove-element",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Two Pointers"
    ],
    "description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val. Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things: Custom Judge: The judge will test your solution with the following code: If all assertions pass, then your solution will be accepted. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "0 <= nums.length <= 100",
      "0 <= nums[i] <= 50",
      "0 <= val <= 100"
    ],
    "examples": [
      {
        "example_text": "int[] nums = [...]; // Input array int val = ...; // Value to remove int[] expectedNums = [...]; // The expected answer with correct length. // It is sorted with no values equaling val. int k = removeElement(nums, val); // Calls your implementation assert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i < actualLength; i++) { assert nums[i] == expectedNums[i]; }"
      },
      {
        "example_text": "Input: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,_,_] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores)."
      },
      {
        "example_text": "Input: nums = [0,1,2,2,3,0,4,2], val = 2 Output: 5, nums = [0,1,4,0,3,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned k (hence they are underscores)."
      }
    ]
  },
  {
    "problem_slug": "find-the-index-of-the-first-occurrence-in-a-string",
    "difficulty": "Easy",
    "topics": [
      "Two Pointers",
      "String",
      "String Matching"
    ],
    "description": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= haystack.length, needle.length <= 104",
      "haystack and needle consist of only lowercase English characters."
    ],
    "examples": [
      {
        "example_text": "Input: haystack = \"sadbutsad\", needle = \"sad\" Output: 0 Explanation: \"sad\" occurs at index 0 and 6. The first occurrence is at index 0, so we return 0."
      },
      {
        "example_text": "Input: haystack = \"leetcode\", needle = \"leeto\" Output: -1 Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1."
      }
    ]
  },
  {
    "problem_slug": "divide-two-integers",
    "difficulty": "Medium",
    "topics": [
      "Math",
      "Bit Manipulation"
    ],
    "description": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator. The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2. Return the quotient after dividing dividend by divisor. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [231, 231  1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "-231 <= dividend, divisor <= 231 - 1",
      "divisor != 0"
    ],
    "examples": [
      {
        "example_text": "Input: dividend = 10, divisor = 3 Output: 3 Explanation: 10/3 = 3.33333.. which is truncated to 3."
      },
      {
        "example_text": "Input: dividend = 7, divisor = -3 Output: -2 Explanation: 7/-3 = -2.33333.. which is truncated to -2."
      }
    ]
  },
  {
    "problem_slug": "substring-with-concatenation-of-all-words",
    "difficulty": "Hard",
    "topics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "description": "You are given a string s and an array of strings words. All the strings of words are of the same length. A concatenated string is a string that exactly contains all the strings of any permutation of words concatenated. Return an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 104",
      "1 <= words.length <= 5000",
      "1 <= words[i].length <= 30",
      "s and words[i] consist of lowercase English letters."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: The substring starting at 0 is \"barfoo\" . It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words . The substring starting at 9 is \"foobar\" . It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words ."
      },
      {
        "example_text": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] Explanation: There is no concatenated substring."
      },
      {
        "example_text": "Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"] Output: [6,9,12] Explanation: The substring starting at 6 is \"foobarthe\" . It is the concatenation of [\"foo\",\"bar\",\"the\"] . The substring starting at 9 is \"barthefoo\" . It is the concatenation of [\"bar\",\"the\",\"foo\"] . The substring starting at 12 is \"thefoobar\" . It is the concatenation of [\"the\",\"foo\",\"bar\"] ."
      }
    ]
  },
  {
    "problem_slug": "next-permutation",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Two Pointers"
    ],
    "description": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. Example 1: Example 2: Example 3: Constraints:",
    "solution": "Video Solution Solution Article Approach 1: Brute Force Algorithm In this approach, we find out every possible permutation of list formed by the elements of the given array and find out the permutation which is just larger than the given one. But this one will be a very naive approach, since it requires us to find out every possible permutation which will take really long time and the implementation is complex. Thus, this approach is not acceptable at all. Hence, we move on directly to the correct approach. Complexity Analysis * Time complexity : O(n!). Total possible permutations is n!. * Space complexity : O(n). Since an array will be used to store the permutations. Approach 2: Single Pass Approach Algorithm First, we observe that for any given sequence that is in descending order, no next larger permutation is possible. For example, no next permutation is possible for the following array: ``` [9, 5, 4, 3, 1] ``` We need to find the first pair of two successive numbers a[i] and a[i-1], from the right, which satisfy a[i] > a[i-1]. Now, no rearrangements to the right of a[i-1] can create a larger permutation since that subarray consists of numbers in descending order. Thus, we need to rearrange the numbers to the right of a[i-1] including itself. Now, what kind of rearrangement will produce the next larger number? We want to create the permutation just larger than the current one. Therefore, we need to replace the number a[i-1] with the number which is just larger than itself among the numbers lying to its right section, say a[j]. ![ Next Permutation ](https://leetcode.com/media/original_images/31_nums_graph.png) We swap the numbers a[i-1] and a[j]. We now have the correct number at index i-1. But still the current permutation isn't the permutation that we are looking for. We need the smallest permutation that can be formed by using the numbers only to the right of a[i-1]. Therefore, we need to place those numbers in ascending order to get their smallest permutation. But, recall that while scanning the numbers from the right, we simply kept decrementing the index until we found the pair a[i] and a[i-1] where, a[i] > a[i-1]. Thus, all numbers to the right of a[i-1] were already sorted in descending order. Furthermore, swapping a[i-1] and a[j] didn't change that order. Therefore, we simply need to reverse the numbers following a[i-1] to get the next smallest lexicographic permutation. The following animation will make things clearer: ![Next Permutation](https://leetcode.com/media/original_images/31_Next_Permutation.gif)Complexity Analysis Let $n$ be the size of the `nums` array. - Time complexity: $O(n)$ The first `while` loop runs at most $n$ iterations, decrementing the variable `i` as it searches for the first decreasing element from the right. In the worst case, it checks all elements, so it takes $O(n)$ time. The second `while` loop also runs at most $n$ iterations, decrementing the variable `j` as it searches for the smallest element larger than `nums[i]`. Similarly, it can take $O(n)$ time. The `reverse` function is called on a portion of the array, from index `i + 1` to the end. In the worst case, this can cover the entire array, leading to a time complexity of $O(n)$. The `swap` function runs in constant time, $O(1)$, since it only exchanges two elements. Therefore, the overall time complexity is $O(n)$. - Space complexity: $O(1)$ The function operates in-place on the `nums` array, meaning no extra space is used for storing additional data. Only a few constant space variables (`i`, `j`, and `temp`) are used. The built-in `swap` and `reverse` functions do not require additional space beyond what is already present in the input array. Hence, the space complexity is $O(1)$.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,2,3] Output: [1,3,2]"
      },
      {
        "example_text": "Input: nums = [3,2,1] Output: [1,2,3]"
      },
      {
        "example_text": "Input: nums = [1,1,5] Output: [1,5,1]"
      }
    ]
  },
  {
    "problem_slug": "longest-valid-parentheses",
    "difficulty": "Hard",
    "topics": [
      "String",
      "Dynamic Programming",
      "Stack"
    ],
    "description": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "0 <= s.length <= 3 * 104",
      "s[i] is '(', or ')'."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"(()\" Output: 2 Explanation: The longest valid parentheses substring is \"()\"."
      },
      {
        "example_text": "Input: s = \")()())\" Output: 4 Explanation: The longest valid parentheses substring is \"()()\"."
      },
      {
        "example_text": "Input: s = \"\" Output: 0"
      }
    ]
  },
  {
    "problem_slug": "search-in-rotated-sorted-array",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Binary Search"
    ],
    "description": "There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-104 <= nums[i] <= 104",
      "All values of nums are unique.",
      "nums is an ascending array that is possibly rotated.",
      "-104 <= target <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4"
      },
      {
        "example_text": "Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1"
      },
      {
        "example_text": "Input: nums = [1], target = 0 Output: -1"
      }
    ]
  },
  {
    "problem_slug": "find-first-and-last-position-of-element-in-sorted-array",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Binary Search"
    ],
    "description": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "0 <= nums.length <= 105",
      "-109 <= nums[i] <= 109",
      "nums is a non-decreasing array.",
      "-109 <= target <= 109"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]"
      },
      {
        "example_text": "Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]"
      },
      {
        "example_text": "Input: nums = [], target = 0 Output: [-1,-1]"
      }
    ]
  },
  {
    "problem_slug": "search-insert-position",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Binary Search"
    ],
    "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 104",
      "-104 <= nums[i] <= 104",
      "nums contains distinct values sorted in ascending order.",
      "-104 <= target <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,3,5,6], target = 5 Output: 2"
      },
      {
        "example_text": "Input: nums = [1,3,5,6], target = 2 Output: 1"
      },
      {
        "example_text": "Input: nums = [1,3,5,6], target = 7 Output: 4"
      }
    ]
  },
  {
    "problem_slug": "valid-sudoku",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "description": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Note: Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "board.length == 9",
      "board[i].length == 9",
      "board[i][j] is a digit 1-9 or '.'."
    ],
    "examples": [
      {
        "example_text": "Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] Output: true"
      },
      {
        "example_text": "Input: board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid."
      }
    ]
  },
  {
    "problem_slug": "sudoku-solver",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Hash Table",
      "Backtracking",
      "Matrix"
    ],
    "description": "Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: The '.' character indicates empty cells. Example 1: Constraints:",
    "solution": "",
    "constraints": [
      "board.length == 9",
      "board[i].length == 9",
      "board[i][j] is a digit or '.'.",
      "It is guaranteed that the input board has only one solution."
    ],
    "examples": [
      {
        "example_text": "Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] Output: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]] Explanation: The input board is shown above and the only valid solution is shown below:"
      }
    ]
  },
  {
    "problem_slug": "count-and-say",
    "difficulty": "Medium",
    "topics": [
      "String"
    ],
    "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula: Run-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string \"3322251\" we replace \"33\" with \"23\", replace \"222\" with \"32\", replace \"5\" with \"15\" and replace \"1\" with \"11\". Thus the compressed string becomes \"23321511\". Given a positive integer n, return the nth element of the count-and-say sequence. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 30"
    ],
    "examples": [
      {
        "example_text": "countAndSay(1) = \"1\" countAndSay(2) = RLE of \"1\" = \"11\" countAndSay(3) = RLE of \"11\" = \"21\" countAndSay(4) = RLE of \"21\" = \"1211\""
      }
    ]
  },
  {
    "problem_slug": "combination-sum",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Backtracking"
    ],
    "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= candidates.length <= 30",
      "2 <= candidates[i] <= 40",
      "All elements of candidates are distinct.",
      "1 <= target <= 40"
    ],
    "examples": [
      {
        "example_text": "Input: candidates = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations."
      },
      {
        "example_text": "Input: candidates = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]]"
      },
      {
        "example_text": "Input: candidates = [2], target = 1 Output: []"
      }
    ]
  },
  {
    "problem_slug": "combination-sum-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Backtracking"
    ],
    "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations. Example 1: Example 2: Constraints:",
    "solution": "Solution Overview This is one of the problems in the series of combination sums. All these problems can be solved with the same backtracking algorithm. We recommend trying these similar problems before tackling this one: [Combination Sum](https://leetcode.com/problems/combination-sum/description/) and [Combination Sum III](https://leetcode.com/problems/combination-sum-iii/description/), which are arguably easier and one can tweak the solution a bit to solve this problem. We also listed some follow-up problems at the end of the article if you are interested in exploring the bactracking algorithm further. Approach: Backtracking Intuition In this problem, we need to generate unique combinations with the given sum value. In the worst case, we might need to generate the sum of all combinations in the array. Backtracking can be effectively used to generate all the possible combinations recursively. Backtracking incrementally builds candidates to the solutions and abandons a candidate (backtracks) as soon as it determines that this candidate can't lead to a final solution. For example, in the given problem, we can discard the candidate solution when it exceeds the sum value, provided the array contains non-negative values. Refer to this [backtracking explore card](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/) to read more about backtracking. Using backtracking, we could incrementally build the combinations. When we find the current combination is not valid, we backtrack and try another option. For the first option, we add the current array element to the current combination array and move this combination to the next index recursively. Similarly, for the second option, we remove the element from the current combination array and move this combination to the next index. Therefore, for every index, we explored two possibilities of including and excluding that value and calculated the combination sum of the maintained combination array. If the desired sum is reached, we can append the list to the answer list. To demonstrate the idea, we showcase how it works with a concrete example in the following tree: ![fig](../Figures/40/40.png) Are there any optimizations to reduce the backtracking calls? Since we need to return unique combinations, we can group equal values of the array together. The simplest way to group all elements together is by sorting them. Now, suppose the frequency of an element is `freq`, and you need to make backtracking calls for all its possible frequencies between `0` and `freq`, then we can simply pick them from the beginning of its group in the sorted array. Algorithm - Create a list `list` to store all the unique combinations that sum up to the target. - Sort the `candidates` array to handle duplicates and facilitate the backtracking process. - Call the `backtrack` function with the following parameters: - `answer`: List to store the final combinations. - `tempList`: Temporary list to store the current combination. - `candidates`: Input array of numbers. - `totalLeft`: Remaining sum to reach the target. - `index`: Starting index for the current recursion. - Within the `backtrack` function: - If `totalLeft` is less than 0, return immediately (invalid path). - If `totalLeft` equals 0: - Add a copy of `tempList` to `answer` (valid combination found). - Otherwise: - Iterate over `candidates` starting from `index`: - Skip duplicate numbers by checking if `candidates[i] == candidates[i - 1]` for `i > index`. - Add `candidates[i]` to `tempList`. - Recursively call `backtrack` with: - Updated `totalLeft` reduced by `candidates[i]`. - Updated `index` as `i + 1` to avoid reusing the same element. - Remove the last element from `tempList` to backtrack and explore other possibilities. - Return `list` containing all unique combinations after the recursive calls complete. Implementation Complexity Analysis Let $N$ be the number of $candidates$ in the array. - Time complexity: $O(2^N)$ In the worst case, our algorithm will exhaust all possible combinations from the input array. Again, in the worst case, let us assume that each number is unique. The number of combinations for an array of size $N$ would be $2^N$, i.e. each number is included or excluded in a combination. Additionally, it takes $O(N)$ time to build a counter table out of the input array. Therefore, the overall time complexity of the algorithm is dominated by the backtracking process, which is $O(2^N)$. You must think about how the solution passes the test cases when the value of $N$ goes up to 100. [Pruning](https://en.wikipedia.org/wiki/Decision_tree_pruning) is the process of writing some additional conditions within our recursion code that help us to reduce the size of our recursion trees by removing redundant sections. For example, in this problem, the maximum value of any `candidates` element is given by 50, whereas the maximum `target` value is 30. So, we can stop the recursion when the value of candidates exceeds the `target` value. Sorting the array is another way to prune the recursion tree. Checkout the image for an explanation: ![fig](../Figures/40/image.png) - Space complexity: $O(N)$ We first create a `tempList`, which in the worst case will consume $O(N)$ space to keep track of the combinations. In addition, we apply recursion in the algorithm, which will incur additional memory consumption in the function call stack. In the worst case, the stack will pile up to $O(N)$ space. To sum up, the overall space complexity of the algorithm is $O(N)$. Note: we did not take into account the space needed to hold the final results of the combination in the above analysis. Here are a series of problems you can solve, with some tweaks of the backtracking algorithm presented in this article. [Subsets](https://leetcode.com/problems/subsets/description/) [Subsets II](https://leetcode.com/problems/subsets-ii/description/) [Permutations](https://leetcode.com/problems/permutations/description/) [Permutations II](https://leetcode.com/problems/permutations-ii/description/) [Combinations](https://leetcode.com/problems/combinations/description/) [Combination Sum](https://leetcode.com/problems/combination-sum/description/) [Combination Sum III](https://leetcode.com/problems/combination-sum-iii/description/) [Palindrome Partition](https://leetcode.com/problems/palindrome-partitioning/description/)",
    "constraints": [
      "1 <= candidates.length <= 100",
      "1 <= candidates[i] <= 50",
      "1 <= target <= 30"
    ],
    "examples": [
      {
        "example_text": "Input: candidates = [10,1,2,7,6,1,5], target = 8 Output: [ [1,1,6], [1,2,5], [1,7], [2,6] ]"
      },
      {
        "example_text": "Input: candidates = [2,5,2,1,2], target = 5 Output: [ [1,2,2], [5] ]"
      }
    ]
  },
  {
    "problem_slug": "first-missing-positive",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Hash Table"
    ],
    "description": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums. You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space. Example 1: Example 2: Example 3: Constraints:",
    "solution": "Solution Overview The task is to find the smallest positive integer that is not present in `nums`. Note that positive integers are greater than zero. Let's discuss the two main cases: 1. No Missing Integer in `nums`: | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | |||||||||| `nums` contains `9` elements. The smallest missing positive integer is `10`. For an array of length `n`, if the array contains all of the integers in the range `1` to `n`, the smallest missing positive integer is `n + 1`. 2. Missing Integer in `nums`: |-10 | 1 | 2 | 2 | 3 | 4 | 6 | 6 | 8 | |-||||||||| `nums` contains `9` elements. The smallest missing positive integer is `5`. For an array of length `n`, if the array does not contain all of the integers in the range `1` to `n`, the smallest missing positive integer is the first integer missing from that range. Let's also discuss the constraints: > You must implement an algorithm that runs in $O(n)$ time and uses $O(1)$ auxiliary space. 1. Time Complexity: Hint number three reminds us that $O(2n) = O(n)$. While we know that one does not equal two, $O$ notation describes an algorithm's limiting behavior as the input size grows toward infinity. 2. Space Complexity: The optimized approaches in this article use in-place solutions. Does in-place mean a constant space complexity? By [definition](https://en.wikipedia.org/wiki/In-place_algorithm), an in-place algorithm transforms the input using no auxiliary data structures proportional to the input size. An in-place algorithm does not necessarily mean constant space complexity; for example, an in-place recursive algorithm uses the recursion stack, so the space is not constant. The problem specifically asks us to use constant *auxiliary* space, so in-place solutions meet this criterion. Approach 1: Boolean Array Intuition We can solve the problem by iterating through the numbers `1` to `n`, and use linear search to determine whether each number is in the array. The first number we cannot find is the smallest missing integer. This approach would result in a quadratic time complexity. We need to determine whether an element is in the array in constant time. Array indexing provides constant lookup time. We need to check the existence of a relatively small range of values, positive numbers between `1` and `n`, so we can use an array like a hash table by using the index as a key and the value as a presence indicator. The default value is `false`, which represents a missing number, and we set the value to `true` for keys that exist in `nums`. Numbers not in the range `1` to `n` are not relevant in the search for the first missing positive, so we do not mark them in the `seen` array. To solve the problem, we can create an array of size `n + 1`. For each positive number less than `n` in `nums`, we set `seen[num]` to `true`. Then, we iterate through the integers `1` to `n` and return the first number that is not marked as seen in the array. If the array contains all of the elements `1` to `n`, we return `n + 1`. > Note: This approach does not meet the problem constraint of solving the problem using constant auxiliary space. It is included to make the solution accessible, and it can provide valuable background for solving the problem within the space constraints. Other approaches that do not meet the time and/or space constraints are not included as they are less relevant to understanding the following approaches. Algorithm 1. Initialize a variable `n` to the length of `nums`. 2. Initialize an array `seen` to size `n + 1`. 3. Mark the elements in `nums` as seen in the array `seen`. - For each `num` in `nums`, if `num` is greater than `0` and less than or equal to `n`, set `seen[num]` to `true`. 4. Find the smallest missing positive number: - For `i` from `1` to `n`, If `seen[i]` is not `true`, return `i`, the smallest missing integer. 5. If `seen` contains all elements `1` to `n`, return `n + 1` as the smallest missing positive number. Implementation Complexity Analysis Let $n$ be the length of `nums`. * Time complexity: $O(n)$ Marking the values from `nums` in `seen` takes $O(n)$. We check for values `1` to `n` in `seen`, which takes $O(n)$. The total time complexity will be $O(2n)$, which we can simplify to $O(n)$. * Space complexity: $O(n)$ We initialize the array `seen`, which is size `n + 1`, so the space complexity is $O(n)$. Approach 2: Index as a Hash Key Intuition Data Clean Up Our search for the first missing positive focuses on the elements with values `1` through `n`. Negative numbers, zeros, and numbers larger than `n` are not relevant. Let's replace all these with `1`s. ![max_first](../Figures/41/41_replace.png) To ensure that the first missing positive is not `1`, we also have to track whether `1` exists in the original array. Solving In-Place Now we have an array that contains only positive numbers in a range from `1` to `n`, and the goal is to find the first missing positive in linear time and constant auxiliary space. In the above approach, using the `seen` array introduced extra space. We can utilize `nums` itself to track which positive integers occur in the array since the range of numbers we have now is the same as the length of the array. We can use the index as a hash key for a positive number, and the sign of the element as a presence indicator. For example, the negative sign of `nums[5]` means that the number `5` is present in `nums`. The positive sign of `nums[6]` means that the number `6` is not present (missing) in `nums`. ![max_first](../Figures/41/41_true_solution.png) To determine the smallest missing positive, we traverse the array, check each element value `value`, and change the sign of element `nums[value]` to negative to mark the number `value` as present in `nums`. We must be careful with duplicates and ensure that the sign is changed only once. > Interview Tip: In-place Algorithms > > This approach modifies the input by changing values of `nums`. In-place algorithms overwrite the input to save space, but sometimes this can cause problems. > > Here are a couple of situations where an in-place algorithm might not be suitable. > > 1. The algorithm needs to run in a multi-threaded environment, without exclusive access to the array. Other threads might need to read the array too, and might not expect it to be modified. > > 2. Even if there is only a single thread, or the algorithm has exclusive access to the array while running, the array might need to be reused later or by another thread once the lock has been released. > > In an interview, you should always check whether the interviewer minds you overwriting the input. Be ready to explain the pros and cons of doing so if asked! Algorithm 1. Initialize a variable `n` to the length of `nums`, and a boolean `contains1` to `false`. 2. Traverse `nums`, check whether `1` occurs, and replace negative numbers, zeros, and numbers larger than `n` with `1`. For each element in nums: - If the element equals `1`, set `contains1` to `true`. - If the element is less than or equal to `0` or greater than `n`, replace it with `1`. 3. If the original `nums` array does not contain `1`, return `1`. 4. Traverse `nums` using a `for` loop from `i` equals `0` to `n`. When `value` is encountered, flip the sign of the number at index `value` to negative to indicate that it is present in the array. Use absolute value to prevent duplicate occurrences of `value` from flipping the sign back to positive. - Set an integer `value` to the absolute value of `nums[i]`. - If `value` equals `n`, we use index `0` to save information about the presence of the number `n` since index `n` is not available. Set `nums[0]` to the negative of the absolute value of `nums[0]`. - Otherwise, we use index `value` to store information about the presence of the number `value`. Set `nums[value]` to the negative of the absolute value of `nums[value]`. 5. Find the smallest missing positive number: - Iterate through the integers `1` to `n` using iterator `i`. If `nums[i]` is positive, return `i`. 6. If `nums[0]` is greater than `0` return `n`. 7. If `nums` contains all elements `1` to `n`, return `n + 1` as the smallest missing positive number. !?!../Documents/41_LIS.json:1000,589!?! Implementation Complexity Analysis Let $n$ be the length of `nums`, * Time complexity: $O(n)$ We traverse `nums` using a `for` loop three separate times, so the time complexity is $O(n)$. * Space complexity: $O(n)$ We modify the array `nums` and use it to determine the answer, so the space complexity is $O(n)$. `nums` is the input array, so the *auxiliary* space used is $O(1)$. Approach 3: Cycle Sort Intuition In the first approach, we discussed that we can solve the problem by iterating through the numbers `1` to `n` and searching for each in the array. If `nums` were sorted, this search process could be done in linear time. The built-in sorting functions in most major languages use linear or logarithmic auxiliary space. We need a way to sort the array in-place, in constant time. The numbers we need to check for are in the range `1` to `n`, so we can utilize [cycle sort](https://en.wikipedia.org/wiki/Cycle_sort). Cycle sort is a sorting algorithm that can sort a given sequence in a range from `a` to `n` by putting each element at the index that corresponds to its value. `nums` is a zero-indexed array, so an element with the value `x` will be located at index `x - 1`. For example, `1` goes at index `0` in the array, `2` goes at index `1`, and `100` goes at index `99`. For each element `x` in `nums`, if it is a positive integer between `1` and `n`, we place it at index `nums[x - 1]`. Elements smaller than `1` or larger than `n` will reside at indexes that do not have a corresponding value in `nums`. Then, to determine the smallest positive integer, we iterate through `nums`, and return the first element that is not equal to its index plus one. If we iterate through the whole sorted array without returning a value, the array consists of the sequence of numbers `1` through `n`, so we return `n + 1`. > Notes: > - This approach modifies the input. It changes the order of `nums`, but not the values of `nums`. In-place algorithms overwrite the input to save space, but sometimes this can cause problems. Always check with your interviewer before modifying the input. > > - We use a simplified version of cycle sort because it is not a problem if the duplicate of a value is not in the correct position. Algorithm 1. Initialize a variable `n` to the length of `nums`. 2. Use cycle sort to place positive elements smaller than `n` at the correct index. - Initialize a variable `i` to `0`. - Iterate through the elements in `nums`: - Set a variable `correctIdx` to `nums[i] - 1`. - If the `nums[i]` is greater than zero, less than or equal to `n`, and does not equal `nums[correctIdx]`, swap the element at `nums[i]` with the element at `nums[correctIdx]`. - Otherwise, increment `i`. 3. Iterate through sorted `nums` and return the smallest missing positive number. - For each element in `nums`, if `nums[i]` does not equal `i + 1`, return `i + 1`, the smallest missing positive number. 4. Return `n + 1`, the smallest missing positive number when each number in `nums` is in the correct position. !?!../Documents/41/41_slideshow.json:960,540!?! Implementation> Note: The variable `correctIdx` is included in the Python3 and Java implementations for readability. The C++ version directly uses `nums[i] - 1` to prevent integer overflow. Complexity Analysis Let $n$ be the length of `nums`. * Time complexity: $O(n)$ We loop through the elements in `nums` once, swapping elements to sort the array. Swapping takes constant time. Sorting `nums` using cycle sort takes $O(n)$ time. Iterating through the sorted array and finding the first missing positive can take up to $O(n)$. The total time complexity is $O(2n)$, which simplifies to $O(n)$. * Space complexity: $O(n)$ We modify the array `nums` and use it to determine the answer, so the space complexity is $O(n)$. `nums` is the input array, so the *auxiliary* space used is $O(1)$.",
    "constraints": [
      "1 <= nums.length <= 105",
      "-231 <= nums[i] <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,2,0] Output: 3 Explanation: The numbers in the range [1,2] are all in the array."
      },
      {
        "example_text": "Input: nums = [3,4,-1,1] Output: 2 Explanation: 1 is in the array but 2 is missing."
      },
      {
        "example_text": "Input: nums = [7,8,9,11,12] Output: 1 Explanation: The smallest positive integer 1 is missing."
      }
    ]
  },
  {
    "problem_slug": "trapping-rain-water",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Two Pointers",
      "Dynamic Programming",
      "Stack",
      "Monotonic Stack"
    ],
    "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "n == height.length",
      "1 <= n <= 2 * 104",
      "0 <= height[i] <= 105"
    ],
    "examples": [
      {
        "example_text": "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped."
      },
      {
        "example_text": "Input: height = [4,2,0,3,2,5] Output: 9"
      }
    ]
  },
  {
    "problem_slug": "multiply-strings",
    "difficulty": "Medium",
    "topics": [
      "Math",
      "String",
      "Simulation"
    ],
    "description": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Note: You must not use any built-in BigInteger library or convert the inputs to integer directly. Example 1: Example 2: Constraints:",
    "solution": "Solution Overview We are given two non-negative integers that are represented as strings and asked to return the product of the two integers, also in the form of a string. There are a few subtle challenges and edge cases that we must consider to solve this problem. So, before determining how to multiply two numbers in string format, let's first consider a simpler variation of the problem: adding two numbers in string format. We can add two numbers represented as strings by adding digits from the given numbers in each place. The sum of two digits must be between 0 and 18. The ones place is added to the result while the tens place is carried and summed with the next pair of digits. When summing two numbers, the carried digit will always be zero or one. This process can be repeated for each digit, as shown below. ![image](../Figures/43/Slide31.JPG) Why does learning how to add two integers represented as strings help us solve this problem? As we will soon see, addition is a subproblem of multiplication. Thus we will need to be able to solve the problem of adding two numbers as strings before we can solve the problem of multiplying two numbers as strings. If this type of problem is new to you and you would like to practice by solving similar problems, we have provided the list below: 1. [66. Plus One](https://leetcode.com/problems/plus-one/) 2. [67. Add Binary](https://leetcode.com/problems/add-binary/) 3. [415. Add Strings](https://leetcode.com/problems/add-strings/) 4. [989. Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/) Approach 1: Elementary Math Intuition Our goal is to multiply two integer numbers that are represented as strings. However, we are not allowed to use a built-in BigInteger library or convert the inputs to integers directly. So how can we multiply the two input strings? We can try to break the problem down into manageable chunks, as is done in elementary mathematics. Thus, we will focus on one digit at a time, just like in the addition example, except here we will be multiplying both numbers digit by digit. Now, let's recall the process for multiplying two numbers. We take the ones place digit of the second number, then multiply it with all digits of the first number consequently going backward, and write the result. We need to remember about carry as well. Note that for multiplication, carry may be any digit between 0 and 8. ![image](../Figures/43/Slide1.JPG)Then we take the tens place digit of the second number and multiply it with all digits of the first number. Since we used the tens place digit, we will multiply this result by 10. Then we write this result below the previous result, signifying that we will add it to the previous result later. ![image](../Figures/43/Slide2.JPG)Then we continue the same way with hundreds place digit, then with thousands place digit of the second number, and so on, until we have visited every digit in the second number. ![image](../Figures/43/Slide3.JPG)As is evident from the above diagram, this process is equivalent to multiplying each digit of the second number by the entire first number and appending zeros at the end of each intermediate result based on the place in the second number that the digit came from. Then we add all the results together to get the final product of the first and second numbers. ![image](../Figures/43/Slide4.JPG)Let's look at an example. Consider 123 * 456, it can be written as, \\implies (123 * (6 + 50 + 400)) \\implies (123 * 6) + (123 * 50) + (123 * 400) \\implies (123 * 6) + (123 * 5 * 10) + (123 * 4 * 100) \\implies \\Sigma \\space ( firstNumber * j^{th} \\space digit \\space of \\space secondNumber * 10^{(index \\space j \\space of \\space digit \\space counting \\space from \\space the \\space end)} ) The results of the multiplication of each digit of the second number with the first number can be stored in an array of strings, and then we can add all these strings to get the final product. Algorithm Multiplication of both numbers starts from the ones place digit (the right-most digit), so we should start our multiplication from index `num2.size() - 1` and go to index `0`. Alternatively, we can reverse both inputs and iterate from index `0` to index `num2.size() - 1`. For each digit in `num2` that we multiply by `num1` we will get a new intermediate result. This intermediate result (`currentResult`) will be stored in a list, string, or StringBuilder, depending on the language of choice. To calculate each intermediate result, we will start by inserting the appropriate number of zeros according to the current digit's place in the second number (i.e. if it is the hundreds place, we append 2 zeros). Then we will perform the multiplication step as demonstrated in the above diagrams. During this step, we will insert the lower place digits into the `currentResult` before the higher place digits. Because we are pushing the lower place digits first and always appending to the end, our result will be in reverse order, so once the multiplication and addition steps are complete, we will need to reverse `answer` before returning. Let's walk through the steps one by one: 1. Reverse both numbers. 2. For each digit in `secondNumber`: - Keep a `carry` variable, initially equal to `0`. - Initialize `currentResult` array beginning with the appropriate number of zeros according to the place of the `secondNumber` digit. - For each digit in `firstNumber`: - Multiply the `secondNumber`'s digit and the `firstNumber`'s digit and add `carry` to the `multiplication`. - Take the remainder of `multiplication` with `10` to get the last digit. - Append the last digit to the `currentResult`. - Divide `multiplication` by `10` to get the new value for `carry`. - Append the remaining value for `carry` (if any) to the `currentResult`. - Push the `currentResult` into the `results` array. 3. Compute the cumulative sum over all the obtained arrays using the `ans` as an answer. 4. Reverse `ans` and return it. !?!../Documents/43/slideshow1.json:960,540!?! Implementation Complexity Analysis Here N and M are the number of digits in `num1` and `num2` respectively. * Time complexity: O(M^2 + M \\cdot N). During multiplication, we perform N operations for each of the M digits of the second number; this requires O(M \\cdot N) time. Then we add each of the M multiplication results (of length O(N + M)) to the answer string; this requires O(M \\cdot (M + N)) time. > When we multiply a number with one digit, the result's maximum length can be at most one more than the number's length _(We can see that when we multiply the max integer of `d` digits, i.e., `9...99` with `9`)_ and there can be at most (M-1) zeroes initially appended to the result. Hence, each result is of order O(N + M). Summing the results requires iterating over the length of the current answer for each result. Since the length of two numbers multiplied together cannot be longer than the sum of the lengths of the two numbers, iterating over each digit in the answer will take O(M + N) time and we will do so M - 1 times (for all but one of the M results). So this step takes O(M \\cdot (M + N)) time. Finally, reversing the answer will require O(M + N) time. Taking all steps into consideration, the total time complexity is O(M^2 + M \\cdot N). * Space complexity: O(M^2 + M \\cdot N). We store each result of multiplication for each digit of `num2` with `num1` in the results array. Each multiplication result can have at most N + M length, and there will be M such results. Thus the space complexity is O(M \\cdot (M + N)). Approach 2: Elementary math using less intermediate space Intuition Notice that we are storing the multiplication result for every digit in `num2`. If we know the maximum size of the answer array ahead of time, we can add each multiplication result directly to the final answer. Thus, we can avoid using the extra space required by the `results` array. First, let's determine what the maximum size of the answer array would be. Try a few test cases on your own, multiply two numbers, count how many digits are in the result, and compare that to the number of digits in each number. Notice that whenever two numbers with the number of digits N and M are multiplied, the result never exceeds (N+M) digits. We could readily accept thatnum1.length + num2.length  (num1  num2).lengthwithout rigorous proof. However, it never hurts to verify a relationship that was derived from observation before accepting it as a fact. Don't worry, you will not be expected to provide a proof like this during the interview, hence you can skip it if you want.The proof that the length of the product of two numbers is always less than or equal to the sum of lengths of the two numbers is as follows: (click to show/hide)> A number n has digits, d = 1 + \\lfloor log_{10}(n) \\rfloor . Its proof is: > Suppose that n has d digits, then 10^{d-1} \\leq n < 10^{d} , because 10^{d} is the smallest integer with d+1 digits. Now take log base 10, then the inequality becomes (d-1) \\leq \\log_{10}(n) < d . Now everything between the range (d-1, \\space d) is decimal part, so taking floor of \\log_{10}(n) we can eliminate all the decimal part and get, (d-1) = \\lfloor \\log_{10}(n) \\rfloor .Thus, d = \\lfloor \\log_{10}(n) \\rfloor + 1.Let firstNumber have N digits and secondNumber have M digits. Let product = firstNumber \\cdot secondNumber have X digits. So, number of digits in product is, \\implies X = 1 + \\lfloor log_{10}(result) \\rfloor \\implies X = 1 + \\lfloor log_{10}(firstNumber \\cdot secondNumber) \\rfloor \\implies X = 1 + \\lfloor log_{10}(firstNumber) + log_{10}(secondNumber) \\rfloor > A real number a can have two parts in it, integral (I) and fractional (F). a = I_{a} + F_{a}. Now, let's say we have two real numbers a = I_{a} + F_{a} and b = I_{b} + F_{b}. \\lfloor a + b \\rfloor = \\lfloor I_{a} + F_{a} + I_{b} + F_{b} \\rfloor = I_{a} + I_{b} + \\lfloor F_{a} + F_{b} \\rfloor F_{a}, F_{b} are fractional parts both always less than 1. 0 \\leq F_{a} + F_{b} < 2 . 0 \\leq \\lfloor F_{a} + F_{b} \\rfloor <= 1 .> So, I_{a} + I_{b} \\leq \\lfloor a + b \\rfloor \\leq I_{a} + I_{b} + 1.But, \\lfloor a \\rfloor + \\lfloor b \\rfloor = \\lfloor I_{a} + F_{a} \\rfloor + \\lfloor I_{b} + F_{b} \\rfloor = I_{a} + I_{b} + \\lfloor F_{a} \\rfloor + \\lfloor F_{b} \\rfloor F_{a}, F_{b} are fractional parts both always less than 1 . 0 \\leq F_{a}, \\space F_{b} < 1 . Hence, \\lfloor F_{a} \\rfloor + \\lfloor F_{b} \\rfloor = 0 .> So, \\lfloor a \\rfloor + \\lfloor b \\rfloor = I_{a} + I_{b} . > Hence we can conclude here that,> \\lfloor a \\rfloor + \\lfloor b \\rfloor \\leq \\lfloor a + b \\rfloor \\leq \\lfloor a \\rfloor + \\lfloor b \\rfloor + 1 Number of digits in, firstNumber = N, \\space secondNumber = M, \\space product = X If a = log_{10}(firstNumber) and b = log_{10}(secondNumber) . N = \\lfloor log_{10} (firstNumber) \\rfloor + 1 = \\lfloor a \\rfloor + 1 M = \\lfloor log_{10} (secondNumber) \\rfloor + 1 = \\lfloor b \\rfloor + 1 X = \\lfloor log_{10} (firstNumber) + log_{10} (secondNumber) \\rfloor + 1 = \\lfloor a + b \\rfloor + 1 \\lfloor a \\rfloor = N - 1, \\space \\lfloor b \\rfloor = M - 1, \\space \\lfloor a + b \\rfloor = X - 1, as, \\lfloor a \\rfloor + \\lfloor b \\rfloor \\leq \\lfloor a + b \\rfloor \\leq \\lfloor a \\rfloor + \\lfloor b \\rfloor + 1 \\implies (N-1) + (M-1) \\leq (X - 1) \\leq (N-1) + (M-1) + 1 \\implies (N + M - 1) \\leq X \\leq (N + M) > Hence, X can never exceed (N + M) .So an answer string of size N + M is guaranteed to be large enough to hold our final result. Let's create one and initialize all of its values as zero. Instead of storing all results of multiplication of each digit of num2 with num1 like we did in Approach 1, we can directly add the current result to the answer string. Algorithm 1. Reverse both numbers. 2. Initialize `ans` array with (N+M) zeros. 3. For each digit in `secondNumber`: - Keep a `carry` variable, initially equal to `0`. - Initialize an array (`currentResult`) that begins with some zeros based on the place of the digit in `secondNumber`. - For each digit of `firstNumber`: - Multiply `secondNumber's` digit and `firstNumber's` digit and add previous `carry` to the `multiplication`. - Take the remainder of `multiplication` with `10` to get the last digit. - Append the last digit to `currentResult` array. - Divide the `multiplication` by `10` to obtain the new value for `carry`. - After iterating over each digit in the first number, if `carry` is not zero, append `carry` to the `currentResult`. - Add `currentResult` to the `ans`. 4. If the last digit in `ans` is zero, before reversing `ans`, we must pop the zero from `ans`. Otherwise, there would be a leading zero in the final answer. 5. Reverse `ans` and return it. !?!../Documents/43/slideshow2.json:960,540!?! Implementation Complexity Analysis Here N and M are the number of elements in num 1 and num 2 strings. * Time complexity: O(M \\cdot (N+M)). - During multiplication, we perform `N` operations for each of the `M` digits of the second number, so we need O(M \\cdot N) time for it. - We add the multiplication result to the `ans` string that has a length of N+M. There will be M such additions since we have M multiplication results. Therefore, the time consumed here will be O(M \\cdot (N+M)). - It takes linear time to reverse the strings. - Overall, this solution takes O(M \\cdot N + M \\cdot (N+M) + M + N) = O(M \\cdot (N+M)) time. * Space complexity: O(N + M). - The answer string and multiplication results will have at most N + M length. Approach 3: Sum the products from all pairs of digits Intuition As we have seen in the previous approaches, when we multiply two digits, one from the first number and one from the second number, then their product will have some zeros appended at the end. The number of zeros depends on the place of each digit, and (as demonstrated in the image below) when the result is added to the answer, the trailing zeros do not affect the answer (because any number plus zero is itself). So it is not necessary for us to append zeros at the end of each result before adding the result to the final answer. Instead, we can directly add the multiplication result at the place where the least significant digit will shift to after to appending some zeros. As an example, when we multiply two tens place digits, two zeros are appended at the end of the multiplication result, and the result will be added at the hundreds place in the final answer. One more example for clarity, if we multiplied a digit in the thousands place (3 trailing zeros) by a digit in the hundreds place (2 trailing zeros), the product will have 5 trailing zeros (the sum of trailing zeros of each digit) so the result will only affect the hundred thousands place and the millions place in the final answer. ![image](../Figures/43/Slide32.JPG)In the previous solution, including the extra zeros was quite costly. For instance, `multiplyOneDigit` stored these extra zeros for every intermediate result which required an additional O(N) space and time for each multiplication, where N is the number of digits in `num2`. Furthermore, every time we called `multiplyOneDigit` we added the result to the current `answer`. This involved iterating over all M + N digits in answer each time we added a new result to the current answer. So let's get a better idea of how we can solve this problem without iterating over all the extra zeros. Take a moment to study the above example. Notice that we multiply each digit in `num2` by each digit in `num1` just like before. Each time we will get a 2-digit result with some zeros after it. Since we know how many zeros will follow the product of the two digits based on their places, we know which two places in `answer` to update. So, instead of updating all M + N elements in `answer` for each of the N digits in `num2`, we only need to update 2 digits in `answer` for each of the M \\cdot N pairs of digits. The above example highlights the two digits from each result that we will add to the answer and the below example shows precisely how this will be done. Thus, for each pair of digits, we multiply them together to get a 2-digit result. The ones place of the result will be added at the correct position in `answer` (based on the place of each of the digits). The tens place of the result will be added to the next place in `answer`. This step is effectively the same as carrying the tens place digit in the previous approaches. Note that the `answer` array will be reversed just like before. So when we multiply a digit in the i^{th} place of the first number by a digit in the j^{th} place of the second number, then the ones place of the result will add to the (i+j)^{th} place in the final answer and the tens place of the result (carry) will be added to the (i+j+1)^{th} place in the final answer. Algorithm 1. Reverse both numbers. 2. Initialize `answer` with N + M zeros. 3. For each digit at position `i` in `secondNumber`: - For each digit at position `j` in `firstNumber`: - Multiply the digit from `secondNumber` by the digit from `firstNumber` and add previously carried value to the `multiplication` result. The previously carried value can be found at position `i + j` in the `answer`. - Take the remainder of `multiplication` with `10` to get the ones place digit of the `multiplication` result. - Put the last digit at current position (position `i + j`) in `answer`. - Divide the `multiplication` by `10` to get the new value for carry and add it to `answer` at the next position. Note, the next position is located at `(i + j + 1)`. 4. If the last digit in `answer` is zero, before reversing `answer`, we must pop the zero from `answer`. Otherwise, there would be a leading zero in the final answer. 5. Reverse `answer` and return it. !?!../Documents/43/slideshow3.json:960,540!?! Implementation Complexity Analysis Here N and M are the number of digits in `num1` and `num2` respectively. * Time complexity: O(M \\cdot N). During multiplication, we perform `N` operations for each of the `M` digits of the second number, so we need M \\cdot N time for it. * Space complexity: O(M + N). The space used to store the output is not included in the space complexity. However, because strings are immutable in Python, Java, and Javascript, a temporary data structure, using O(M + N) space, is required to store the answer while it is updated. On the other hand, in C++, strings are mutable, so we do not need a temporary data structure to store answer and can update answer directly. Thus, the C++ approach is a constant space solution.",
    "constraints": [
      "1 <= num1.length, num2.length <= 200",
      "num1 and num2 consist of digits only.",
      "Both num1 and num2 do not contain any leading zero, except the number 0 itself."
    ],
    "examples": [
      {
        "example_text": "Input: num1 = \"2\", num2 = \"3\" Output: \"6\""
      },
      {
        "example_text": "Input: num1 = \"123\", num2 = \"456\" Output: \"56088\""
      }
    ]
  },
  {
    "problem_slug": "wildcard-matching",
    "difficulty": "Hard",
    "topics": [
      "String",
      "Dynamic Programming",
      "Greedy",
      "Recursion"
    ],
    "description": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where: The matching should cover the entire input string (not partial). Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "0 <= s.length, p.length <= 2000",
      "s contains only lowercase English letters.",
      "p contains only lowercase English letters, '?' or '*'."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"aa\", p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\"."
      },
      {
        "example_text": "Input: s = \"aa\", p = \"*\" Output: true Explanation: '*' matches any sequence."
      },
      {
        "example_text": "Input: s = \"cb\", p = \"?a\" Output: false Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'."
      }
    ]
  },
  {
    "problem_slug": "jump-game-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where: Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1]. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 104",
      "0 <= nums[i] <= 1000",
      "It's guaranteed that you can reach nums[n - 1]."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index."
      },
      {
        "example_text": "Input: nums = [2,3,0,1,4] Output: 2"
      }
    ]
  },
  {
    "problem_slug": "permutations",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Backtracking"
    ],
    "description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 6",
      "-10 <= nums[i] <= 10",
      "All the integers of nums are unique."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
      },
      {
        "example_text": "Input: nums = [0,1] Output: [[0,1],[1,0]]"
      },
      {
        "example_text": "Input: nums = [1] Output: [[1]]"
      }
    ]
  },
  {
    "problem_slug": "permutations-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Backtracking",
      "Sorting"
    ],
    "description": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order. Example 1: Example 2: Constraints:",
    "solution": "Solution Overview As the name of the problem suggests, this problem is an extension of the [Permutation](https://leetcode.com/problems/permutations/) problem. The problem is different from the previous permutation problem on the condition that the input array can contain _duplicates_. The key to solve the problem is still the _backtracking_ algorithm. However, we need some adaptation to ensure that the _enumerated_ solutions generated from our backtracking exploration do not have any duplicates. >As a reminder, [backtracking](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/) is a general algorithm for finding all (or some) solutions to some problems with constraints. It incrementally builds candidates to the solutions, and abandons a candidate as soon as it determines that the candidate cannot possibly lead to a solution. In this article, we will present a yet another backtracking solution to solve the problem. Approach 1: Backtracking with Groups of Numbers Intuition First of all, let us review the general idea of permutation with an example. Given the input array `[1, 1, 2]`, to generate a permutation of the array, we could follow the _Depth-First Search_ (DFS) approach, or more precisely the backtracking technique as one will see later. >The idea is that we pick the numbers one by one. For a permutation of length N, we would then need N stages to generate a valid permutation. At each stage, we need to pick one number into the permutation, out of the remaining available numbers. Later at the same stage, we will try out all available choices. By trying out, we progressively build up candidates to the solution, and revert each choice with another alternative until there is no more choice. Let us walk through the example with paper and pencil, as follows: - Given the input of `[1, 1, 2]`, at the first stage, we have 2 choices to pick a number as the first number in the final permutation, _i.e._ `1` and `2`. Suppose that we pick the number `1`, now the remaining numbers would become `[1, 2]`. Note: The reason that we have only 2 choices instead of 3, is that there is a duplicate in the given input. Picking any of the duplicate numbers as the first number of the permutation would lead us to the same permutation at the end. Should the numbers in the array be all unique, we would then have the same number of choices as the length of the array. - At the second stage, we now then have again 2 choices, _i.e._ `[1, 2]`. Let us pick again the number `1`, which leaves us the only remaining number `2`. - Now at the third stage, we have only one candidate number left, _i.e._ `[2]`. We then pick the last remaining number, which leads to a final permutation sequence of `[1, 1, 2]`. - Moreover, we need to _revisit_ each of the above stages, and make a different choice in order to try out all possibilities. The reversion of the choices is what we call __*backtracking*__. We illustrate all potential exploration in the following graph where each node represents a choice at a specific stage: ![permutation tree](../Figures/47/47_permutations.png) >A key insight to avoid generating any _redundant_ permutation is that at each step rather than viewing each number as a candidate, we consider each _unique_ number as the true candidate. For instance, at the very beginning, given in the input of `[1, 1, 2]`, we have only two true candidates instead of three. Algorithm Given the above insight, in order to find out all the unique numbers at each stage, we can build a _hash table_ (denoted as `counter`), with each unique number as the key and its occurrence as the corresponding value. To implement the algorithm, first we define a function called `backtrack(comb, counter)` which generates all permutations, starting from the current combination (`comb`) and the remaining numbers (`counter`). Once the function is implemented, it suffices to invoke the function with the initial empty combination and the hash table we built out of the input array, to solve the problem. Here are some sample implementations.Note: for a backtracking algorithm, usually there are some explorations that would lead to a *dead end*, and we have to abandon those explorations in the middle. However, due to the specificity of this problem and our exploration strategy, each exploration will result in a valid permutation, _i.e._ none of the efforts is in vain. This insight would prove to be useful in the following complexity analysis. Complexity Analysis Let N be the length of the input array. Hence, the number of permutations would be at maximum N!, _i.e._ N \\cdot (N-1) \\cdot (N-2) ... 1, when each number in the array is unique. - Time Complexity: \\mathcal{O}\\big(\\sum_{k = 1}^{N}{P(N, k)}\\big) where P(N, k) = \\frac{N!}{(N - k)!} = N (N - 1) ... (N - k + 1) is so-called [_k-permutations_of_N_ or _partial permutation_](https://en.wikipedia.org/wiki/Permutationk-permutations_of_n). - As one can see in the exploration graph we have shown earlier, the execution of the backtracking algorithm will unfold itself as a tree, where each node is an invocation of the recursive function `backtrack(comb, counter)`. The total number of steps to complete the exploration is _exactly_ the number of nodes in the tree. Therefore, the time complexity of the algorithm is linked directly with the size of the tree. - It now boils down to estimating the number of nodes in the tree. As we know now, each level of the tree corresponds to a specific _stage_ of the exploration. At each stage, the number of candidates to explore is bounded. For instance, at the first stage, _at most_ we would have N candidates to explore, _i.e._ the number of nodes at this level would be N. Moving on to the next stage, for each of the nodes in the first stage, we would have N-1 child nodes. Therefore, the number of nodes at this stage would be N \\cdot (N-1). So on and so forwards. ![number of nodes](../Figures/47/47_number_of_nodes.png) - By summing up all the nodes across the stages, we would then obtain the total number of nodes as \\sum_{k = 1}^{N}{P(N, k)} where P(N, k) = \\frac{N!}{(N - k)!} = N (N - 1) ... (N - k + 1). As a result, the exact time complexity of the algorithm is \\mathcal{O}\\big(\\sum_{k = 1}^{N}{P(N, k)}\\big). - The above complexity might appear a bit too abstract to comprehend. Here we could provide another __*loose upper bound*__ on the complexity. - It takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take us N \\cdot N! steps to generate all permutations, simply assuming that there is no overlapping effort (which is not true). - Space Complexity: \\mathcal{O}(N) - First of all, we build a hash table out of the input numbers. In the worst case where each number is unique, we would need \\mathcal{O}(N) space for the table. - Since we applied recursion in the algorithm which consumes some extra space in the function call stack, we would need another \\mathcal{O}(N) space for the recursion. - During the exploration, we keep a candidate of permutation along the way, which takes yet another \\mathcal{O}(N). - To sum up, the total space complexity would be \\mathcal{O}(N) + \\mathcal{O}(N) + \\mathcal{O}(N) = \\mathcal{O}(N). - Note, we did not take into account the space needed to hold the results. Otherwise, the space complexity would become \\mathcal{O}(N \\cdot N!).",
    "constraints": [
      "1 <= nums.length <= 8",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,1,2] Output: [[1,1,2], [1,2,1], [2,1,1]]"
      },
      {
        "example_text": "Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
      }
    ]
  },
  {
    "problem_slug": "rotate-image",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Math",
      "Matrix"
    ],
    "description": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "n == matrix.length == matrix[i].length",
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "example_text": "Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]]"
      },
      {
        "example_text": "Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
      }
    ]
  },
  {
    "problem_slug": "group-anagrams",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Hash Table",
      "String",
      "Sorting"
    ],
    "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= strs.length <= 104",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters."
    ],
    "examples": [
      {
        "example_text": "Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] Explanation:"
      },
      {
        "example_text": "Input: strs = [\"\"] Output: [[\"\"]]"
      },
      {
        "example_text": "Input: strs = [\"a\"] Output: [[\"a\"]]"
      }
    ]
  },
  {
    "problem_slug": "powx-n",
    "difficulty": "Medium",
    "topics": [
      "Math",
      "Recursion"
    ],
    "description": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn). Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "-100.0 < x < 100.0",
      "-231 <= n <= 231-1",
      "n is an integer.",
      "Either x is not zero or n > 0.",
      "-104 <= xn <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: x = 2.00000, n = 10 Output: 1024.00000"
      },
      {
        "example_text": "Input: x = 2.10000, n = 3 Output: 9.26100"
      },
      {
        "example_text": "Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25"
      }
    ]
  },
  {
    "problem_slug": "n-queens",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Backtracking"
    ],
    "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 9"
    ],
    "examples": [
      {
        "example_text": "Input: n = 4 Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above"
      },
      {
        "example_text": "Input: n = 1 Output: [[\"Q\"]]"
      }
    ]
  },
  {
    "problem_slug": "n-queens-ii",
    "difficulty": "Hard",
    "topics": [
      "Backtracking"
    ],
    "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 9"
    ],
    "examples": [
      {
        "example_text": "Input: n = 4 Output: 2 Explanation: There are two distinct solutions to the 4-queens puzzle as shown."
      },
      {
        "example_text": "Input: n = 1 Output: 1"
      }
    ]
  },
  {
    "problem_slug": "maximum-subarray",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Divide and Conquer",
      "Dynamic Programming"
    ],
    "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum. Example 1: Example 2: Example 3: Constraints: Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 105",
      "-104 <= nums[i] <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "example_text": "Input: nums = [1] Output: 1 Explanation: The subarray [1] has the largest sum 1."
      },
      {
        "example_text": "Input: nums = [5,4,-1,7,8] Output: 23 Explanation: The subarray [5,4,-1,7,8] has the largest sum 23."
      }
    ]
  },
  {
    "problem_slug": "spiral-matrix",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 10",
      "-100 <= matrix[i][j] <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5]"
      },
      {
        "example_text": "Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7]"
      }
    ]
  },
  {
    "problem_slug": "jump-game",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "description": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 104",
      "0 <= nums[i] <= 105"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
      },
      {
        "example_text": "Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index."
      }
    ]
  },
  {
    "problem_slug": "merge-intervals",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Sorting"
    ],
    "description": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Example 1: Example 2: Constraints:",
    "solution": "Video Solution Solution Article Approach 1: Connected Components Intuition If we draw a graph (with intervals as nodes) that contains undirected edges between all pairs of intervals that overlap, then all intervals in each *connected component* of the graph can be merged into a single interval. Algorithm With the above intuition in mind, we can represent the graph as an adjacency list, inserting directed edges in both directions to simulate undirected edges. Then, to determine which connected component each node is in, we perform graph traversals from arbitrary unvisited nodes until all nodes have been visited. To do this efficiently, we store visited nodes in a `Set`, allowing for constant time containment checks and insertion. Finally, we consider each connected component, merging all of its intervals by constructing a new `Interval` with `start` equal to the minimum start among them and `end` equal to the maximum end. This algorithm is correct simply because it is basically the brute force solution. We compare every interval to every other interval, so we know exactly which intervals overlap. The reason for the connected component search is that two intervals may not directly overlap, but might overlap indirectly via a third interval. See the example below to see this more clearly. ![Components Example](../Figures/56/component.png) Although (1, 5) and (6, 10) do not directly overlap, either would overlap with the other if first merged with (4, 7). There are two connected components, so if we merge their nodes, we expect to get the following two merged intervals: (1, 10), (15, 20)Complexity Analysis * Time complexity : O(n^2) Building the graph costs O(V + E) = O(V) + O(E) = O(n) + O(n^2) = O(n^2) time, as in the worst case all intervals are mutually overlapping. Traversing the graph has the same cost (although it might appear higher at first) because our `visited` set guarantees that each node will be visited exactly once. Finally, because each node is part of exactly one component, the merge step costs O(V) = O(n) time. This all adds up as follows: O(n^2) + O(n^2) + O(n) = O(n^2) * Space complexity : O(n^2) As previously mentioned, in the worst case, all intervals are mutually overlapping, so there will be an edge for every pair of intervals. Therefore, the memory footprint is quadratic in the input size. Approach 2: Sorting Intuition If we sort the intervals by their `start` value, then each set of intervals that can be merged will appear as a contiguous \"run\" in the sorted list. Algorithm First, we sort the list as described. Then, we insert the first interval into our `merged` list and continue considering each interval in turn as follows: If the current interval begins *after* the previous interval ends, then they do not overlap and we can append the current interval to `merged`. Otherwise, they do overlap, and we merge them by updating the `end` of the previous interval if it is less than the `end` of the current interval. A simple proof by contradiction shows that this algorithm always produces the correct answer. First, suppose that the algorithm at some point fails to merge two intervals that should be merged. This would imply that there exists some triple of indices i, j, and k in a list of intervals \\text{ints} such that i < j < k and (\\text{ints[i]}, \\text{ints[k]}) can be merged, but neither (\\text{ints[i]}, \\text{ints[j]}) nor (\\text{ints[j]}, \\text{ints[k]}) can be merged. From this scenario follow several inequalities: \\begin{aligned} \\text{ints[i].end} < \\text{ints[j].start} \\\\ \\text{ints[j].end} < \\text{ints[k].start} \\\\ \\text{ints[i].end} \\geq \\text{ints[k].start} \\\\ \\end{aligned} We can chain these inequalities (along with the following inequality, implied by the well-formedness of the intervals: \\text{ints[j].start} \\leq \\text{ints[j].end}) to demonstrate a contradiction: \\begin{aligned} \\text{ints[i].end} < \\text{ints[j].start} \\leq \\text{ints[j].end} < \\text{ints[k].start} \\\\ \\text{ints[i].end} \\geq \\text{ints[k].start} \\end{aligned} Therefore, all mergeable intervals must occur in a contiguous run of the sorted list. ![Sorting Example](../Figures/56/sort.png) Consider the example above, where the intervals are sorted, and then all mergeable intervals form contiguous blocks.Complexity Analysis * Time complexity : O(n\\log{}n) Other than the `sort` invocation, we do a simple linear scan of the list, so the runtime is dominated by the O(n\\log{}n) complexity of sorting. * Space complexity : O(\\log N) (or O(n)) If we can sort `intervals` in place, we do not need more than constant additional space, although the sorting itself takes O(\\log n) space. Otherwise, we must allocate linear space to store a copy of `intervals` and sort that.",
    "constraints": [
      "1 <= intervals.length <= 104",
      "intervals[i].length == 2",
      "0 <= starti <= endi <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]."
      },
      {
        "example_text": "Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping."
      }
    ]
  },
  {
    "problem_slug": "insert-interval",
    "difficulty": "Medium",
    "topics": [
      "Array"
    ],
    "description": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion. Note that you don't need to modify intervals in-place. You can make a new array and return it. Example 1: Example 2: Constraints:",
    "solution": "Solution Overview We are given a sorted list of non-overlapping `intervals` and a `newInterval`. The task is to insert the `newInterval` into the `intervals` while maintaining sorted order and ensuring no overlapping intervals. If there is any overlap, the overlapping intervals should be merged. In the end, return the intervals list with the addition of the new intervals. Two key observations are crucial for this problem: 1. The given intervals are already sorted in ascending order based on the start values. 2. Initially, the intervals are non-overlapping, but inserting a new interval might lead to overlaps that need resolution by merging while maintaining sorted order. To solve this problem, we break it into three cases when comparing the current interval with the new interval: Case 1. The current interval ends before the new interval starts. Case 2. There is an overlap, and the intervals need merging. Case 3. The current interval starts after the new interval ends. A visual representation below illustrates all three scenarios: ![img](../Figures/57_re/1.png) Now let us consider the given problem description example with `intervals` and a `newInterval`: ``` intervals = [[1, 3], [6, 9]] newInterval = [2, 5] ``` The first interval starts at 1 and ends at 3, while the second interval starts at 6 and ends at 9. The goal is to insert the `newInterval` into the existing list of `intervals`, maintaining sorted order. Upon analysis, we observe that the `newInterval` [2, 5] overlaps with the first interval [1, 3] because 2 is less than 3. Now, since we know the intervals need to be merged, we must ensure the merged interval covers the entire overlapping region. To achieve this, we take the maximum of the end of the first interval and the end of the new interval, as well as the minimum of the start of the first interval and the start of the new interval. Therefore, the merged interval becomes `[min(1, 2), max(3, 5)] = [1, 5]`. Moving on to the second interval [6, 9], its starting point (6) comes after the new interval's ending point (5). There is no overlap between them. Therefore, the second interval remains unchanged. | Original Intervals | New Interval | Action | Resulting Intervals | |-- |--|- |-| | [1,3] | [2,5] | New interval overlaps with the first interval [1,3]. Merge intervals by taking [min(1, 2), max(3, 5)] = [1, 5]. | [1,5] | | [6,9] | | No overlap with the new interval [2,5]. Interval remains unchanged. | [6,9] | In conclusion, the final result is [[1, 5], [6, 9]], representing the intervals after inserting and merging the new interval [2, 5]. In a concrete business context, this problem may be presented as follows: Suppose we have an array representing video watch times, where each segment consists of the start and stop times of a user watching a video. The task is to calculate the total number of unique minutes watched across all the video segments. This is fundamentally the same question. > We recommend solving [Merge Intervals](https://leetcode.com/problems/merge-intervals/) problem before attempting this question, as it provides valuable insights into pattern recognition. This question is an extension of the Merge Intervals concept, building upon the same principles. Approach 1: Linear Search Intuition We can do a linear search by iterating through all the intervals and checking which one of the three conditions the intervals fall under: 1. No Overlaps before Merging: - This occurs when the current interval ends before the new interval starts. 2. Overlapping and Merging: - This occurs when the starting point of the current interval is less than or equal to the ending point of the new interval (`newInterval[1]`), indicating an overlap. We can merge the current interval with the new interval by updating the start and end values of the new interval. 3. No Overlapping after Merging: - This occurs when the current interval starts after the new interval ends. 1. Identifying Non-Overlapping Intervals Before Merging: We iterate through all intervals, checking whether the endpoint of the current interval (`intervals[i][1]`) is less than the starting point of the new interval (`newInterval[0]`). If this condition holds true, it indicates there is no overlap before merging, and we add the current interval to the result. 2. Identifying and Merging Overlapping Intervals: During the iteration, we identify overlap by comparing the endpoint of the new interval (`newInterval[1]`) with the starting point of the current interval (`intervals[i][0]`). When an overlap is detected, we merge the intervals by updating the start and end values of the new interval. The index (`i`) is then incremented to move to the next interval. After merging, the new interval is added to the result. 3. Identifying Non-Overlapping Intervals After Merging: As we have already added the non-overlapping intervals before `newInterval` and merged overlapping ones, the remaining intervals after are guaranteed not to overlap with the newly merged interval. We simply add these remaining intervals to the result. The following slideshow illustrates how the linear search algorithm is employed: !?!../Documents/57/57_LS.json:945,480!?! Algorithm - Initialize variables `n` and `i` to store the size of intervals and the current index, respectively, and an empty array `res` to store the result. - Case 1: No Overlap Before Insertion: - Loop through intervals while `i` is less than `n` and the current interval's endpoint (`intervals[i][1]`) is less than the new interval's start point (`newInterval[0]`). - Add the current interval from intervals to the `res` array. - Increment `i` to move to the next interval. - Case 2: Overlap and Merge: - Loop through intervals while `i` is less than `n` and the new interval's endpoint (`newInterval[1]`) is greater than or equal to the current interval's start point (`intervals[i][0]`). - Update the newInterval's start point to the minimum of its current start and the current interval's start. - Update the newInterval's endpoint to the maximum of its current end and the current interval's end. - This essentially merges overlapping intervals into a single larger interval. - Increment `i` to move to the next interval. - Add the updated `newInterval` to the `res` array, representing the merged interval. - Case 3: No overlap after insertion: - Loop through the remaining intervals (from index `i`) and add them to the `res` array. - This includes intervals that occur after the new interval and those that don't overlap, as they have already been correctly inserted in the previous iterations (previous two cases). - Return the `res` array containing all intervals with the new interval inserted correctly. Implementation Complexity Analysis Let $N$ be the number of intervals. * Time complexity: $O(N)$ We iterate through the intervals once, and each interval is considered and processed only once. * Space complexity: $O(1)$ We only use the result (`res`) array to store output, so this could be considered $O(1)$. Approach 2: Binary Search Intuition To apply binary search to a problem, a crucial requirement is that the input should have a monotonically increasing or decreasing nature. In our given scenario, it is explicitly stated that the input is already sorted with respect to the start value, indicating a monotonically increasing order. Therefore, we can confidently consider applying binary search. 1. Finding the Insertion Position As the intervals are sorted by start value, we perform a binary search comparing the starting point of the current interval (`intervals[mid][0]`) with the starting point of the new interval (`target`). If `intervals[mid][0]` is less than the target, it indicates that the insertion point should be to the right of the current position. Consequently, we update `left` to `mid + 1`. If it's greater, the insertion point should be to the left, so we update `right` to `mid - 1`. This process continues until `left` becomes greater than `right`, revealing the correct insertion position. 2. Handling Merging 1. If `res` is empty or the end of the last interval in `res` is less than the starting point of the current interval, it indicates there is no overlap before merging. The current interval is directly added to `res` in such cases. 2. If an overlap is detected, signifying the need for merging, the current interval is merged with the last interval in `res`. The end of the last interval in `res` is updated to the maximum of its current end and the end of the current interval. The following slideshow illustrates how the binary search algorithm is employed: !?!../Documents/57/57_BS.json:930,315!?! Algorithm - If `intervals` is empty, it means there are no existing intervals, so we can simply return a array containing the `newInterval`. - Perform a binary search to find the correct position to insert the new interval in the `intervals` array. It updates the values of `left` and `right` based on the comparison of the target value with the first element of the interval at the middle index. - Initialize the variables `target` with the starting point of `newInterval` (i.e., `newInterval[0]`), `left` with 0, and `right` with `n - 1` to define the search space in the `intervals` array. - Perform a binary search by repeatedly dividing the search space in half until `left` is greater than `right`. - Calculate the middle index `mid` as the average of `left` and `right`. - If the start of the interval at index `mid` is less than the target value, update `left` to `mid + 1` to search the right half of the search space. Otherwise, update `right` to `mid - 1` to search the left half of the search space. - The search updates `left` and `right` until they converge to the correct position. Repeat until `left` is greater than `right`. - Use `intervals.insert(intervals.begin() + left, newInterval)` to insert the `newInterval` at the correct position. - Initialize an empty array `res` to store the result. - Iterate through the sorted intervals. - Check if `res` is empty or if the end of the last interval in `res` is less than the start of the current interval. If either condition is true, add the current interval to `res`. - If there is an overlap, update the endpoint of the last interval in `res` to cover the current interval. This step ensures that non-overlapping intervals are added directly, and overlapping intervals are merged. - The final merged and inserted intervals are stored in the `res` array, which is then returned. Implementation Complexity Analysis Let $N$ be the number of intervals. * Time complexity: $O(N)$ The binary search for finding the position to insert the `newInterval` has a time complexity of $O(\\log N)$. However, the insertion of the `newInterval` into the list may take $O(N)$ time in the worst case, as it could involve shifting elements within the list. Consequently, the overall time complexity is $O(N + \\log N)$, which simplifies to $O(N)$. * Space complexity: $O(N)$ We use the additional space to store the result (`res`) and perform calculations using `res,` so it does count towards the space complexity. In the worst case, the size of `res` will be proportional to the number of intervals in the input list.",
    "constraints": [
      "0 <= intervals.length <= 104",
      "intervals[i].length == 2",
      "0 <= starti <= endi <= 105",
      "intervals is sorted by starti in ascending order.",
      "newInterval.length == 2",
      "0 <= start <= end <= 105"
    ],
    "examples": [
      {
        "example_text": "Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]"
      },
      {
        "example_text": "Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]."
      }
    ]
  },
  {
    "problem_slug": "length-of-last-word",
    "difficulty": "Easy",
    "topics": [
      "String"
    ],
    "description": "Given a string s consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 104",
      "s consists of only English letters and spaces ' '.",
      "There will be at least one word in s."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"Hello World\" Output: 5 Explanation: The last word is \"World\" with length 5."
      },
      {
        "example_text": "Input: s = \" fly me to the moon \" Output: 4 Explanation: The last word is \"moon\" with length 4."
      },
      {
        "example_text": "Input: s = \"luffy is still joyboy\" Output: 6 Explanation: The last word is \"joyboy\" with length 6."
      }
    ]
  },
  {
    "problem_slug": "spiral-matrix-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "description": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order. Example 1: Example 2: Constraints:",
    "solution": "Solution Overview There are various problems in spiral matrix series with some variations like [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/) and [Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/). In order to solve such questions, the core idea is to decode the underlying pattern. This can be done by simulating the pattern and finding a generic representation that would work for any given n. Let's discuss a few approaches. Approach 1: Traverse Layer by Layer in Spiral Form Intuition If we try to build a pattern for a given n, we observe that the pattern repeats after completing one circular traversal around the matrix. Let's call this one circular traversal as _layer_. We start traversing from the outer layer and move towards inner layers on every iteration. ![img](../Figures/59/spiral_layers.png) Algorithm Let's devise an algorithm for the spiral traversal: - We can observe that, for any given n, the total number of layers is given by : \\lfloor \\frac{n+1}{2} \\rfloor This works for both even and odd n. _Example_ For n = 3, layers = 2 For n = 6, total layers = 3 - Also, for each layer, we traverse in _at most_ 4 directions : ![img](../Figures/59/spiral_traverse.png) In every direction, either row or column remains constant and other parameter changes (increments/decrements). _Direction 1: From top left corner to top right corner._ The row remains constant as \\text{layer} and column increments from \\text{layer} to n-\\text{layer}-1 _Direction 2: From top right corner to the bottom right corner._ The column remains constant as n-layer-1 and row increments from \\text{layer}+1 to n-\\text{layer}. _Direction 3: From bottom right corner to bottom left corner._ The row remains constant as n-\\text{layer}-1 and column decrements from n-\\text{layer}-2 to \\text{layer}. _Direction 4: From bottom left corner to top left corner._ The column remains constant as \\text{layer} and column decrements from n-\\text{layer}-2 to \\text{layer}+1. This process repeats (n+1)/2 times until all layers are traversed. ![img](../Figures/59/spiral_detailed_fix.png)Complexity Analysis * Time Complexity: \\mathcal{O}(n^2). Here, n is given input and we are iterating over n\\cdot n matrix in spiral form. * Space Complexity: \\mathcal{O}(1) We use constant extra space for storing cnt. Approach 2: Optimized spiral traversal Intuition Our main aim is to walk in a spiral form and fill the array in a particular pattern. In the previous approach, we used a separate loop for each direction. Here, we discuss another optimized to achieve the same result. Algorithm - We have to walk in 4 directions forming a layer. We use an array dir that stores the changes in x and y co-ordinates in each direction. _Example_ In left to right walk ( _direction 1_ ), x co-ordinates remains same and y increments (x = 0, y = 1). In right to left walk ( _direction 3_ ), x remains same and y decrements (x = 0, y = -1). Using this intuition, we pre-define an array dir having x and y co-ordinate changes for each direction. There are a total of 4 directions as discussed in the previous approach. - The \\text{row} and col variables represent the current x and y co-ordinates respectively. It updates based on the direction in which we are moving. _How do we know when we have to change the direction?_ When we find the next row or column in a particular direction has a non-zero value, we are sure it is already traversed and we change the direction. Let d be the current direction index. We go to next direction in array dir using (d+ 1) \\% 4. Using this we could go back to direction 1 after completing one circular traversal from direction 1 to direction 4 . > It must be noted that we use `floorMod` in Java instead of modulo \\% to handle mod of negative numbers. This is required because row and column values might go negative and using \\% won't give desired results in such cases.Complexity Analysis * Time Complexity: \\mathcal{O}(n^2). Here, n is given input and we are iterating over n\\cdot n matrix in spiral form. * Space Complexity: \\mathcal{O}(1) We use constant extra space for storing cnt.",
    "constraints": [
      "1 <= n <= 20"
    ],
    "examples": [
      {
        "example_text": "Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]]"
      },
      {
        "example_text": "Input: n = 1 Output: [[1]]"
      }
    ]
  },
  {
    "problem_slug": "permutation-sequence",
    "difficulty": "Hard",
    "topics": [
      "Math",
      "Recursion"
    ],
    "description": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: Given n and k, return the kth permutation sequence. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 9",
      "1 <= k <= n!"
    ],
    "examples": [
      {
        "example_text": "Input: n = 3, k = 3 Output: \"213\""
      },
      {
        "example_text": "Input: n = 4, k = 9 Output: \"2314\""
      },
      {
        "example_text": "Input: n = 3, k = 1 Output: \"123\""
      }
    ]
  },
  {
    "problem_slug": "rotate-list",
    "difficulty": "Medium",
    "topics": [
      "Linked List",
      "Two Pointers"
    ],
    "description": "Given the head of a linked list, rotate the list to the right by k places. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the list is in the range [0, 500].",
      "-100 <= Node.val <= 100",
      "0 <= k <= 2 * 109"
    ],
    "examples": [
      {
        "example_text": "Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3]"
      },
      {
        "example_text": "Input: head = [0,1,2], k = 4 Output: [2,0,1]"
      }
    ]
  },
  {
    "problem_slug": "unique-paths",
    "difficulty": "Medium",
    "topics": [
      "Math",
      "Dynamic Programming",
      "Combinatorics"
    ],
    "description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: m = 3, n = 7 Output: 28"
      },
      {
        "example_text": "Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -> Down -> Down 2. Down -> Down -> Right 3. Down -> Right -> Down"
      }
    ]
  },
  {
    "problem_slug": "unique-paths-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "description": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle. Return the number of possible unique paths that the robot can take to reach the bottom-right corner. The testcases are generated so that the answer will be less than or equal to 2 * 109. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "m == obstacleGrid.length",
      "n == obstacleGrid[i].length",
      "1 <= m, n <= 100",
      "obstacleGrid[i][j] is 0 or 1."
    ],
    "examples": [
      {
        "example_text": "Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right"
      },
      {
        "example_text": "Input: obstacleGrid = [[0,1],[0,0]] Output: 1"
      }
    ]
  },
  {
    "problem_slug": "minimum-path-sum",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "description": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 200",
      "0 <= grid[i][j] <= 200"
    ],
    "examples": [
      {
        "example_text": "Input: grid = [[1,3,1],[1,5,1],[4,2,1]] Output: 7 Explanation: Because the path 1  3  1  1  1 minimizes the sum."
      },
      {
        "example_text": "Input: grid = [[1,2,3],[4,5,6]] Output: 12"
      }
    ]
  },
  {
    "problem_slug": "valid-number",
    "difficulty": "Hard",
    "topics": [
      "String"
    ],
    "description": "Given a string s, return whether s is a valid number. For example, all the following are valid numbers: \"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\", while the following are not valid numbers: \"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\". Formally, a valid number is defined using one of the following definitions: An integer number is defined with an optional sign '-' or '+' followed by digits. A decimal number is defined with an optional sign '-' or '+' followed by one of the following definitions: An exponent is defined with an exponent notation 'e' or 'E' followed by an integer number. The digits are defined as one or more digits. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 20",
      "s consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"0\" Output: true"
      },
      {
        "example_text": "Input: s = \"e\" Output: false"
      },
      {
        "example_text": "Input: s = \".\" Output: false"
      }
    ]
  },
  {
    "problem_slug": "plus-one",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Math"
    ],
    "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's. Increment the large integer by one and return the resulting array of digits. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= digits.length <= 100",
      "0 <= digits[i] <= 9",
      "digits does not contain any leading 0's."
    ],
    "examples": [
      {
        "example_text": "Input: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124. Thus, the result should be [1,2,4]."
      },
      {
        "example_text": "Input: digits = [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. Incrementing by one gives 4321 + 1 = 4322. Thus, the result should be [4,3,2,2]."
      },
      {
        "example_text": "Input: digits = [9] Output: [1,0] Explanation: The array represents the integer 9. Incrementing by one gives 9 + 1 = 10. Thus, the result should be [1,0]."
      }
    ]
  },
  {
    "problem_slug": "add-binary",
    "difficulty": "Easy",
    "topics": [
      "Math",
      "String",
      "Bit Manipulation",
      "Simulation"
    ],
    "description": "Given two binary strings a and b, return their sum as a binary string. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= a.length, b.length <= 104",
      "a and b consist only of '0' or '1' characters.",
      "Each string does not contain leading zeros except for the zero itself."
    ],
    "examples": [
      {
        "example_text": "Input: a = \"11\", b = \"1\" Output: \"100\""
      },
      {
        "example_text": "Input: a = \"1010\", b = \"1011\" Output: \"10101\""
      }
    ]
  },
  {
    "problem_slug": "text-justification",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "String",
      "Simulation"
    ],
    "description": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left-justified, and no extra space is inserted between words. Note: Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= words.length <= 300",
      "1 <= words[i].length <= 20",
      "words[i] consists of only English letters and symbols.",
      "1 <= maxWidth <= 100",
      "words[i].length <= maxWidth"
    ],
    "examples": [
      {
        "example_text": "Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16 Output: [ \"This is an\", \"example of text\", \"justification. \" ]"
      },
      {
        "example_text": "Input: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16 Output: [ \"What must be\", \"acknowledgment \", \"shall be \" ] Explanation: Note that the last line is \"shall be \" instead of \"shall be\", because the last line must be left-justified instead of fully-justified. Note that the second line is also left-justified because it contains only one word."
      },
      {
        "example_text": "Input: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20 Output: [ \"Science is what we\", \"understand well\", \"enough to explain to\", \"a computer. Art is\", \"everything else we\", \"do \" ]"
      }
    ]
  },
  {
    "problem_slug": "sqrtx",
    "difficulty": "Easy",
    "topics": [
      "Math",
      "Binary Search"
    ],
    "description": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well. You must not use any built-in exponent function or operator. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "0 <= x <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: x = 4 Output: 2 Explanation: The square root of 4 is 2, so we return 2."
      },
      {
        "example_text": "Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned."
      }
    ]
  },
  {
    "problem_slug": "climbing-stairs",
    "difficulty": "Easy",
    "topics": [
      "Math",
      "Dynamic Programming",
      "Memoization"
    ],
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "example_text": "Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps"
      },
      {
        "example_text": "Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step"
      }
    ]
  },
  {
    "problem_slug": "simplify-path",
    "difficulty": "Medium",
    "topics": [
      "String",
      "Stack"
    ],
    "description": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Your task is to transform this absolute path into its simplified canonical path. The rules of a Unix-style file system are as follows: The simplified canonical path should follow these rules: Return the simplified canonical path. Example 1: Example 2: Example 3: Example 4: Example 5: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= path.length <= 3000",
      "path consists of English letters, digits, period '.', slash '/' or '_'.",
      "path is a valid absolute Unix path."
    ],
    "examples": [
      {
        "example_text": "Input: path = \"/home/\" Output: \"/home\" Explanation: The trailing slash should be removed."
      },
      {
        "example_text": "Input: path = \"/home//foo/\" Output: \"/home/foo\" Explanation: Multiple consecutive slashes are replaced by a single one."
      },
      {
        "example_text": "Input: path = \"/home/user/Documents/../Pictures\" Output: \"/home/user/Pictures\" Explanation: A double period \"..\" refers to the directory up a level (the parent directory)."
      },
      {
        "example_text": "Input: path = \"/../\" Output: \"/\" Explanation: Going one level up from the root directory is not possible."
      },
      {
        "example_text": "Input: path = \"/.../a/../b/c/../d/./\" Output: \"/.../b/d\" Explanation: \"...\" is a valid name for a directory in this problem."
      }
    ]
  },
  {
    "problem_slug": "edit-distance",
    "difficulty": "Medium",
    "topics": [
      "String",
      "Dynamic Programming"
    ],
    "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "0 <= word1.length, word2.length <= 500",
      "word1 and word2 consist of lowercase English letters."
    ],
    "examples": [
      {
        "example_text": "Input: word1 = \"horse\", word2 = \"ros\" Output: 3 Explanation: horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e')"
      },
      {
        "example_text": "Input: word1 = \"intention\", word2 = \"execution\" Output: 5 Explanation: intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u')"
      }
    ]
  },
  {
    "problem_slug": "set-matrix-zeroes",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "description": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's. You must do it in place. Example 1: Example 2: Constraints: Follow up:",
    "solution": "",
    "constraints": [
      "m == matrix.length",
      "n == matrix[0].length",
      "1 <= m, n <= 200",
      "-231 <= matrix[i][j] <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]]"
      },
      {
        "example_text": "Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]"
      }
    ]
  },
  {
    "problem_slug": "search-a-2d-matrix",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Binary Search",
      "Matrix"
    ],
    "description": "You are given an m x n integer matrix matrix with the following two properties: Given an integer target, return true if target is in matrix or false otherwise. You must write a solution in O(log(m * n)) time complexity. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 100",
      "-104 <= matrix[i][j], target <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: true"
      },
      {
        "example_text": "Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 Output: false"
      }
    ]
  },
  {
    "problem_slug": "sort-colors",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function. Example 1: Example 2: Constraints: Follow up: Could you come up with a one-pass algorithm using only constant extra space?",
    "solution": "",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 300",
      "nums[i] is either 0, 1, or 2."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2]"
      },
      {
        "example_text": "Input: nums = [2,0,1] Output: [0,1,2]"
      }
    ]
  },
  {
    "problem_slug": "minimum-window-substring",
    "difficulty": "Hard",
    "topics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "description": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\". The testcases will be generated such that the answer is unique. Example 1: Example 2: Example 3: Constraints: Follow up: Could you find an algorithm that runs in O(m + n) time?",
    "solution": "",
    "constraints": [
      "m == s.length",
      "n == t.length",
      "1 <= m, n <= 105",
      "s and t consist of uppercase and lowercase English letters."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"ADOBECODEBANC\", t = \"ABC\" Output: \"BANC\" Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t."
      },
      {
        "example_text": "Input: s = \"a\", t = \"a\" Output: \"a\" Explanation: The entire string s is the minimum window."
      },
      {
        "example_text": "Input: s = \"a\", t = \"aa\" Output: \"\" Explanation: Both 'a's from t must be included in the window. Since the largest window of s only has one 'a', return empty string."
      }
    ]
  },
  {
    "problem_slug": "combinations",
    "difficulty": "Medium",
    "topics": [
      "Backtracking"
    ],
    "description": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n]. You may return the answer in any order. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 20",
      "1 <= k <= n"
    ],
    "examples": [
      {
        "example_text": "Input: n = 4, k = 2 Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] Explanation: There are 4 choose 2 = 6 total combinations. Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination."
      },
      {
        "example_text": "Input: n = 1, k = 1 Output: [[1]] Explanation: There is 1 choose 1 = 1 total combination."
      }
    ]
  },
  {
    "problem_slug": "subsets",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Backtracking",
      "Bit Manipulation"
    ],
    "description": "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. Example 1: Example 2: Constraints:",
    "solution": "Video Solution Solution Article Overview: Solution Pattern Let us first review the problems of Permutations / Combinations / Subsets, since they are quite similar to each other and there are some common strategies to solve them. First, their solution space is often quite large: - [Permutations](https://en.wikipedia.org/wiki/Permutationk-permutations_of_n): N!. - [Combinations](https://en.wikipedia.org/wiki/CombinationNumber_of_k-combinations): C_N^k = \\frac{N!}{(N - k)! k!} - Subsets: 2^N, since each element could be absent or present. Given their exponential solution space, it is tricky to ensure that the generated solutions are _complete_ and _non-redundant_. It is essential to have a clear and easy-to-reason strategy. There are generally three strategies to do it: - Iterative - Recursion/Backtracking - Lexicographic generation based on the mapping between binary bitmasks and the corresponding permutations / combinations / subsets. As one would see later, the third method could be a good candidate for the interview because it simplifies the problem to the generation of binary numbers, therefore it is easy to implement and verify that no solution is missing. Besides, as a bonus, it generates lexicographically sorted output for the sorted inputs. Approach 1: Cascading Intuition Let's start from an empty subset in the output list. At each step, one takes a new integer into consideration and generates new subsets from the existing ones. ![diff](../Figures/78/recursion.png) Implementation Complexity Analysis * Time complexity: \\mathcal{O}(N \\times 2^N) to generate all subsets and then copy them into the output list. * Space complexity: \\mathcal{O}(N \\times 2^N). This is exactly the number of solutions for subsets multiplied by the number N of elements to keep for each subset. - For a given number, it could be present or absent (_i.e._ binary choice) in a subset solution. As a result, for N numbers, we would have in total 2^N choices (solutions). Approach 2: Backtracking Algorithm >Power set is all possible combinations of all possible _lengths_, from 0 to n. Given the definition, the problem can also be interpreted as finding the _power set_ from a sequence. So, this time let us loop over the length of combination, rather than the candidate numbers, and generate all combinations for a given length with the help of _backtracking_ technique. ![diff](../Figures/78/combinations.png) >[Backtracking](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/) is an algorithm for finding all solutions by exploring all potential candidates. If the solution candidate turns out to be _not_ a solution (or at least not the _last_ one), the backtracking algorithm discards it by making some changes on the previous step, *i.e.* _backtracks_ and then tries again. ![diff](../Figures/78/backtracking.png) Algorithm We define a backtrack function named `backtrack(first, curr)` that takes the index of the first element to add and a current combination as arguments. - If the current combination is done, we add the combination to the final output. - Otherwise, we iterate over the indexes `i` from `first` to the length of the entire sequence `n`. - Add integer `nums[i]` into the current combination `curr`. - Proceed to add more integers into the combination: `backtrack(i + 1, curr)`. - Backtrack by removing `nums[i]` from `curr`. Implementation Complexity Analysis * Time complexity: \\mathcal{O}(N \\times 2^N) to generate all subsets and then copy them into the output list. * Space complexity: \\mathcal{O}(N). We are using O(N) space to maintain `curr`, and are modifying `curr` in-place with backtracking. Note that for space complexity analysis, we do not count space that is *only* used for the purpose of returning output, so the `output` array is ignored. Approach 3: Lexicographic (Binary Sorted) Subsets Intuition The idea of this solution is originated from [Donald E. Knuth](https://www-cs-faculty.stanford.edu/~knuth/taocp.html). >The idea is that we map each subset to a bitmask of length n, where `1` on the i*th* position in bitmask means the presence of `nums[i]` in the subset, and `0` means its absence. ![diff](../Figures/78/bitmask4.png) For instance, the bitmask `0..00` (all zeros) corresponds to an empty subset, and the bitmask `1..11` (all ones) corresponds to the entire input array `nums`. Hence to solve the initial problem, we just need to generate n bitmasks from `0..00` to `1..11`. It might seem simple at first glance to generate binary numbers, but the real problem here is how to deal with [zero left padding](https://en.wikipedia.org/wiki/Padding_(cryptography)Zero_padding), because one has to generate bitmasks of fixed length, _i.e._ `001` and not just `1`. For that one could use standard bit manipulation trick:or keep it simple stupid and shift iteration limits: Algorithm - Generate all possible binary bitmasks of length n. - Map a subset to each bitmask: `1` on the i*th* position in bitmask means the presence of `nums[i]` in the subset, and `0` means its absence. - Return output list. Implementation Complexity Analysis * Time complexity: \\mathcal{O}(N \\times 2^N) to generate all subsets and then copy them into output list. * Space complexity: \\mathcal{O}(N) to store the bitset of length N. Note that for space complexity analysis, we do not count space that is *only* used for the purpose of returning output, so the `output` array is ignored.",
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10",
      "All the numbers of nums are unique."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
      },
      {
        "example_text": "Input: nums = [0] Output: [[],[0]]"
      }
    ]
  },
  {
    "problem_slug": "word-search",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "String",
      "Backtracking",
      "Depth-First Search",
      "Matrix"
    ],
    "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Example 1: Example 2: Example 3: Constraints: Follow up: Could you use search pruning to make your solution faster with a larger board?",
    "solution": "",
    "constraints": [
      "m == board.length",
      "n = board[i].length",
      "1 <= m, n <= 6",
      "1 <= word.length <= 15",
      "board and word consists of only lowercase and uppercase English letters."
    ],
    "examples": [
      {
        "example_text": "Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\" Output: true"
      },
      {
        "example_text": "Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\" Output: true"
      },
      {
        "example_text": "Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\" Output: false"
      }
    ]
  },
  {
    "problem_slug": "remove-duplicates-from-sorted-array-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Two Pointers"
    ],
    "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Custom Judge: The judge will test your solution with the following code: If all assertions pass, then your solution will be accepted. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 3 * 104",
      "-104 <= nums[i] <= 104",
      "nums is sorted in non-decreasing order."
    ],
    "examples": [
      {
        "example_text": "int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i < k; i++) { assert nums[i] == expectedNums[i]; }"
      },
      {
        "example_text": "Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_] Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores)."
      },
      {
        "example_text": "Input: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3,_,_] Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores)."
      }
    ]
  },
  {
    "problem_slug": "search-in-rotated-sorted-array-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Binary Search"
    ],
    "description": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values). Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4]. Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums. You must decrease the overall operation steps as much as possible. Example 1: Example 2: Constraints: Follow up: This problem is similar to Search in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-104 <= nums[i] <= 104",
      "nums is guaranteed to be rotated at some pivot.",
      "-104 <= target <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true"
      },
      {
        "example_text": "Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false"
      }
    ]
  },
  {
    "problem_slug": "remove-duplicates-from-sorted-list-ii",
    "difficulty": "Medium",
    "topics": [
      "Linked List",
      "Two Pointers"
    ],
    "description": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the list is in the range [0, 300].",
      "-100 <= Node.val <= 100",
      "The list is guaranteed to be sorted in ascending order."
    ],
    "examples": [
      {
        "example_text": "Input: head = [1,2,3,3,4,4,5] Output: [1,2,5]"
      },
      {
        "example_text": "Input: head = [1,1,1,2,3] Output: [2,3]"
      }
    ]
  },
  {
    "problem_slug": "remove-duplicates-from-sorted-list",
    "difficulty": "Easy",
    "topics": [
      "Linked List"
    ],
    "description": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the list is in the range [0, 300].",
      "-100 <= Node.val <= 100",
      "The list is guaranteed to be sorted in ascending order."
    ],
    "examples": [
      {
        "example_text": "Input: head = [1,1,2] Output: [1,2]"
      },
      {
        "example_text": "Input: head = [1,1,2,3,3] Output: [1,2,3]"
      }
    ]
  },
  {
    "problem_slug": "largest-rectangle-in-histogram",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Stack",
      "Monotonic Stack"
    ],
    "description": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= heights.length <= 105",
      "0 <= heights[i] <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units."
      },
      {
        "example_text": "Input: heights = [2,4] Output: 4"
      }
    ]
  },
  {
    "problem_slug": "maximal-rectangle",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Stack",
      "Matrix",
      "Monotonic Stack"
    ],
    "description": "Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "rows == matrix.length",
      "cols == matrix[i].length",
      "1 <= row, cols <= 200",
      "matrix[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "example_text": "Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] Output: 6 Explanation: The maximal rectangle is shown in the above picture."
      },
      {
        "example_text": "Input: matrix = [[\"0\"]] Output: 0"
      },
      {
        "example_text": "Input: matrix = [[\"1\"]] Output: 1"
      }
    ]
  },
  {
    "problem_slug": "partition-list",
    "difficulty": "Medium",
    "topics": [
      "Linked List",
      "Two Pointers"
    ],
    "description": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the list is in the range [0, 200].",
      "-100 <= Node.val <= 100",
      "-200 <= x <= 200"
    ],
    "examples": [
      {
        "example_text": "Input: head = [1,4,3,2,5,2], x = 3 Output: [1,2,2,4,3,5]"
      },
      {
        "example_text": "Input: head = [2,1], x = 2 Output: [1,2]"
      }
    ]
  },
  {
    "problem_slug": "scramble-string",
    "difficulty": "Hard",
    "topics": [
      "String",
      "Dynamic Programming"
    ],
    "description": "We can scramble a string s to get a string t using the following algorithm: Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false. Example 1: Example 2: Example 3: Constraints:",
    "solution": "Solution Approach: Dynamic Programming Intuition We have a recursive definition of scrambling a string `s`. First, we divide `s` into `x` and `y`. Then we either keep `s` as `x + y` or swap them and get `y + x`. After that, we scramble `x` and `y` independently. Let `x'` denote the scrambled `x` and `y'` denote the scrambled `y`. `s` will eventually become `x' + y'` or `y' + x'`. ![split](../Figures/87/diagram2.drawio.png) How do we check whether a given string `t` is a scrambled string of `s`? First, we choose an index and cut `s` into `x` and `y` (`s = x + y`). Then, we see if we can cut `t` into `x'` and `y'` (`t = x' + y'` if we do not swap or `t = y' + x'` if we do). Since verifying that `x'` is a scrambled `x` and `y'` is scrambled `y` are smaller subproblems, we will solve the problem using dynamic programming. We have two strings `s1` and `s2`. For each given dp state, we need 3 variables: `length`, `i`, and `j`. Each state will focus on two substrings. The first one will be a substring of `s1`, starting at index `i` with length equal to `length` - let's call this substring `s`. The second one will be a substring of `s2`, starting at index `j` with `length` - let's call this substring `t`. Let `dp[length][i][j]` be a boolean representing whether `t` is a scrambled version of `s`. The base case, as defined by the problem is when `length = 1`. Here we do not have to split strings into smaller ones, so we can easily compare the corresponding characters: `dp[1][i][j]` is `true` when `s1[i]` equals `s2[j]`, and `false` otherwise. Now we need to write down the transitions of `dp`. We will use the following image as an example during the explanations. ![split](../Figures/87/diagram.drawio.png) At each state, we need to perform a split on `s1`. We will consider all possible splits. If we are currently considering a substring with a length of `length`, then we could perform a split at any index `newLength`, where `0 < newLength < length`. (Here, `newLength` represents the length of the left string after the split). A split gives us two new strings: - A substring of `s1` starting at index `i` and ending with index `i + newLength - 1`. This string has a length of `newLength` (Blue in the picture) - A substring of `s1` starting at index `i + newLength` and ending at index `i + length - 1`. This string has a length of `length - newLength`. (Yellow in the picture) For each split, we have two cases: * Do not swap the blue and yellow parts. The corresponding substrings of `s2` must be scrambled versions of the substrings we just created by splitting `s1`. This means both `dp[newLength][i][j]` (representing the blue parts) and `dp[length - newLength][i + newLength][j + newLength]` (representing the yellow parts) must be true. * Swap the blue and yellow parts. As you can see in the image, this misaligns the blue and yellow parts between `s1` and `s2`, but we still need the parts to match (we still need the blue part of `s1` to be a scrambled version of the blue part of `s2`, same with the yellow part). What are the new starting indices? For blue, it's `s1` starting with `i` and `s2` starting with `j + length - newLength`. For yellow, it's `s1` starting with `i + newLength` and `s2` starting with `j`. Thus, we need both `dp[newLength][i][j+length-newLength]` and `dp[length-newLength][i+newLength][j]` to be `true`. Now we can formally write down the transitions. For `length > 1`, `dp[length][i][j]` is `true` if and only if for at least one `newLength` where `0 < newLength < length`: `(dp[newLength][i][j] && dp[length-newLength][i+newLength][j+newLength]) || (dp[newLength][i][j+length-newLength] && dp[length-newLength][i+newLength][j])` is `true`. Let `n` denote the length of the input strings. The answer to the problem is `dp[n][0][0]`, as starting at index `0` with length `n` is considering the entire input string. Algorithm 1. Iterate `i` from `0` to `n-1`. * Iterate `j` from `0` to `n-1`. * Set `dp[1][i][j]` to the boolean value of `s1[i] == s2[j]`. (The base case of the DP). 2. Iterate `length` from `2` to `n`. * Iterate `i` from `0` to `n + 1 - length`. * Iterate `j` from `0` to `n + 1 - length`. * Iterate `newLength` from `1` to `length - 1`. * If `dp[newLength][i][j] && dp[length-newLength][i+newLength][j+newLength]) || (dp[newLength][i][j+l-newLength] && dp[l-newLength][i+newLength][j]` is `true`, set `dp[length][i][j]` to `true`. 3. Return `dp[n][0][0]`. Implementation Complexity Analysis * Time complexity: $O(n^4)$. We have four nested for loops (for `length`, `i`, `j`, `newLength`), each doing $O(n)$ iterations. * Space complexity: $O(n^3)$. We store the matrix `dp[n+1][n][n]` for dynamic programming.",
    "constraints": [
      "s1.length == s2.length",
      "1 <= s1.length <= 30",
      "s1 and s2 consist of lowercase English letters."
    ],
    "examples": [
      {
        "example_text": "Input: s1 = \"great\", s2 = \"rgeat\" Output: true Explanation: One possible scenario applied on s1 is: \"great\" --> \"gr/eat\" // divide at random index. \"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order. \"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them. \"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order. \"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\". \"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order. The algorithm stops now, and the result string is \"rgeat\" which is s2. As one possible scenario led s1 to be scrambled to s2, we return true."
      },
      {
        "example_text": "Input: s1 = \"abcde\", s2 = \"caebd\" Output: false"
      },
      {
        "example_text": "Input: s1 = \"a\", s2 = \"a\" Output: true"
      }
    ]
  },
  {
    "problem_slug": "merge-sorted-array",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Two Pointers",
      "Sorting"
    ],
    "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. Example 1: Example 2: Example 3: Constraints: Follow up: Can you come up with an algorithm that runs in O(m + n) time?",
    "solution": "",
    "constraints": [
      "nums1.length == m + n",
      "nums2.length == n",
      "0 <= m, n <= 200",
      "1 <= m + n <= 200",
      "-109 <= nums1[i], nums2[j] <= 109"
    ],
    "examples": [
      {
        "example_text": "Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1."
      },
      {
        "example_text": "Input: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]."
      },
      {
        "example_text": "Input: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1."
      }
    ]
  },
  {
    "problem_slug": "gray-code",
    "difficulty": "Medium",
    "topics": [
      "Math",
      "Backtracking",
      "Bit Manipulation"
    ],
    "description": "An n-bit gray code sequence is a sequence of 2n integers where: Given an integer n, return any valid n-bit gray code sequence. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 16"
    ],
    "examples": [
      {
        "example_text": "Input: n = 2 Output: [0,1,3,2] Explanation: The binary representation of [0,1,3,2] is [00,01,11,10]. - 00 and 01 differ by one bit - 01 and 11 differ by one bit - 11 and 10 differ by one bit - 10 and 00 differ by one bit [0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01]. - 00 and 10 differ by one bit - 10 and 11 differ by one bit - 11 and 01 differ by one bit - 01 and 00 differ by one bit"
      },
      {
        "example_text": "Input: n = 1 Output: [0,1]"
      }
    ]
  },
  {
    "problem_slug": "subsets-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Backtracking",
      "Bit Manipulation"
    ],
    "description": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]"
      },
      {
        "example_text": "Input: nums = [0] Output: [[],[0]]"
      }
    ]
  },
  {
    "problem_slug": "decode-ways",
    "difficulty": "Medium",
    "topics": [
      "String",
      "Dynamic Programming"
    ],
    "description": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping: \"1\" -> 'A' \"2\" -> 'B' ... \"25\" -> 'Y' \"26\" -> 'Z' However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\"2\" and \"5\" vs \"25\"). For example, \"11106\" can be decoded into: Note: there may be strings that are impossible to decode. Given a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0. The test cases are generated so that the answer fits in a 32-bit integer. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 100",
      "s contains only digits and may contain leading zero(s)."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"12\" Output: 2 Explanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12)."
      },
      {
        "example_text": "Input: s = \"226\" Output: 3 Explanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)."
      },
      {
        "example_text": "Input: s = \"06\" Output: 0 Explanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). In this case, the string is not a valid encoding, so return 0."
      }
    ]
  },
  {
    "problem_slug": "reverse-linked-list-ii",
    "difficulty": "Medium",
    "topics": [
      "Linked List"
    ],
    "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the list is n.",
      "1 <= n <= 500",
      "-500 <= Node.val <= 500",
      "1 <= left <= right <= n"
    ],
    "examples": [
      {
        "example_text": "Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5]"
      },
      {
        "example_text": "Input: head = [5], left = 1, right = 1 Output: [5]"
      }
    ]
  },
  {
    "problem_slug": "restore-ip-addresses",
    "difficulty": "Medium",
    "topics": [
      "String",
      "Backtracking"
    ],
    "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order. Example 1: Example 2: Example 3: Constraints:",
    "solution": "Solution Approach 1: Backtracking Intuition Since a valid IP address consists of 4 integers, that means we need to place 3 dots. We can try putting dots at all possible different positions using backtracking. If an invalid number is formed then we backtrack to try out another combination. > Backtracking can be defined as a general algorithmic technique that considers searching every possible combination to solve a computational problem. It incrementally builds candidates to the solution and abandons a candidate (\"backtracks\") when it determines that the candidate cannot lead to the solution. We will recursively enumerate all the possibilities and whenever we get a new integer because of a dot (or 2 integers for the last dot), we check whether the integer(s) is valid, i.e the integer cannot have leading 0s other than being 0 itself and it's no larger than 255. There are 3 possibilities to add each dot, namely it can be added after 1, 2, or 3 digits from the last dot or the beginning of the string, so there are at most $3 ^ 3 = 27$ possibilities to add all 3 dots. An optimization is to return an empty result if the input string's length is longer than 12 since each integer can have 3 digits at most (any more and it would either have leading zeroes or be greater than 255). We can create a helper function `valid(s, start, length)` to check whether the substring from index `start` to `start + length` is a valid number from range 0-255. The logic is to check both the conditions (the caller guarantees that the length is in the range of [1, 3]): 1. If the substring's first character is `0` (i.e. `s[start]` is '0'), then `length` must be 1. 2. If `length` is `3`, the substring should no larger than \"255\" lexically. If the length is 1 or 2 and the first case was not triggered, then it will be in the acceptable range. Algorithm Create a function `helper` which takes the original string `s`, the processing index `startIndex` (i.e we only consider the substring starting from `startIndex` and the prefix part is already separated into valid integers.), a list of integers `dots` which saves distances for the dots we have added so far and a list of strings `ans` to save the answers. 1. Set `remainingLength` to `length of s - startIndex` which is the string length we want to process. 2. Set `remainingNumberOfIntegers` to `4 - dots.length`. This is how many integers we have left to form. 3. Return if `remainingLength` is larger than `remainingNumberOfIntegers * 3` or smaller than `remainingNumberOfIntegers`, since each integer has 1-3 digits. Also note that this catches the case where `s.length() > 12` since at the very beginning `remainingLength` is `s.length()` and `remainingNumberOfIntegers` is 4. 4. If `remainingNumberOfIntegers = 1`, * if the last integer `s.substring(startIndex, startIndex + remainingLength)` is valid * Create an empty string to save this answer using the following steps. * Set `last` to `0`. * Iterate over all elements `dot` in the list `dots`. * Append `s.substring(last, last + dot)` and a '.' into the answer string. * Increase `last` by `dot` and repeat these steps for each dot. * Append `s.substring(last, s.length)`. This is the final integer after the last dot. * Add the answer string into `ans`. * Return. 5. Iterate over `curPos` from `1` to `min(3, remainingLength)`. `curPos` is the number of digits we are including before placing a dot. * Place a dot by adding `curPos` into `dots`. * If the integer `s.substring(startIndex, startIndex + curPos)` is valid * Call helper(s, startIndex + curPos, dots, ans) * Remove the dot that we placed to backtrack. Implementation Complexity Analysis Let's assume we need to separate the input string into $N$ integers, each integer is at most $M$ digits. * Time complexity: $O(M ^ N \\cdot N)$. There are at most $M ^ {N - 1}$ possibilities, and for each possibility checking whether all parts are valid takes $O(M \\cdot N)$ time, so the final time complexity is $O(M ^ {N - 1}) \\cdot O(M \\cdot N)$ = $O(M ^ N \\cdot N)$. For this question, M = 3, N = 4, so the time complexity is $O(1)$. * Space complexity: $O(M \\cdot N)$. For each possibility, we save (N - 1) numbers (the number of digits before each dot) which takes $O(N)$ space. And we need temporary space to save a solution before putting it into the answer list. The length of each solution string is $M \\cdot N + M - 1$ = $O(M \\cdot N)$, so the total space complexity is $O(M \\cdot N)$ if we don't take the output space into consideration. For this question, M = 3, N = 4, so the space complexity is $O(1)$. Approach 2: Iterative Intuition We need to separate the input string into 4 integers, so we can enumerate the length of the first 3 integers, `len1`, `len2`, `len3`. We could iterate over `len1`, `len2`, `len3` with 3 nested loops and the last integer is the remaining part after separating out the first 3. We can make the ranges of `len1`, `len2`, `len3` tighter: * `len1` should be in the range `[max(1, s.length() - 9), min(3, s.length() - 3]` since we need to separate 3 more integers after it and the length of each integer is in [1..3]. * Similarly, `len2` should be in the range `[max(1, s.length() - len1 - 6, min(3, s.length() - len1 - 2]` * `len3` should be in the range `[max(1, s.length() - len1 - len2 - 3), min(3, s.length() - len1 - len2 - 1]` In this way, the last part's length is always in the range of `[1..3]`, then we can split each substring out based on the lengths and check whether they are valid. Each integer can be validated before starting the loop of the next part to prevent wasting time. Algorithm 1. Initialize an array of strings `ans`. 2. Iterate over the range of `len1`, the length of the first integer. * If the first integer is valid, then we iterate over `len2`'s range. * If the second integer is also valid, then we iterate over `len3`'s range. * If both third and fourth integers are valid, concatenate all four integers together with a character `'.'` between any 2 neighbors, and add the result string to `ans`. 3. Return `ans`. Implementation Complexity Analysis Let's assume we need to separate the input string into $N$ integers, each integer is at most $M$ digits. * Time complexity: $O(M ^ N \\cdot N)$. We have $(N - 1)$ nested loops and each of them iterates at most $M$ times, so the total number of iterations is at most $M ^ {N - 1}$ . In each iteration we split $N$ substrings out to check whether they are valid, each substring's length is at most $M$, so the time complexity to separate out all of them is $O(M \\cdot N)$. For this question, M = 3, N = 4, so the time complexity is $O(1)$. * Space complexity: $O(M \\cdot N)$. The algorithm saves (N - 1) numbers (the number of digits before each dot) which takes $O(N)$ space. And we need temporary space to save a solution before putting it into the answer list. The length of each solution string is $M \\cdot N + M - 1$ = $O(M \\cdot N)$, so the total space complexity is $O(M \\cdot N)$ if we don't take the output space into consideration. For this question, M = 3, N = 4, so the space complexity is $O(1)$.",
    "constraints": [
      "1 <= s.length <= 20",
      "s consists of digits only."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"25525511135\" Output: [\"255.255.11.135\",\"255.255.111.35\"]"
      },
      {
        "example_text": "Input: s = \"0000\" Output: [\"0.0.0.0\"]"
      },
      {
        "example_text": "Input: s = \"101023\" Output: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
      }
    ]
  },
  {
    "problem_slug": "binary-tree-inorder-traversal",
    "difficulty": "Easy",
    "topics": [
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values. Example 1: Example 2: Example 3: Example 4: Constraints:",
    "solution": "Solution Approach 1: Recursive Approach The first method to solve this problem is using recursion. This is the classical method and is straightforward. We can define a helper function to implement recursion.Complexity Analysis Time complexity: O(n) - The time complexity is O(n) because the recursive function is T(n) = 2 \\cdot T(n/2)+1. Space complexity: O(n) - The worst case space required is O(n), and in the average case it's O(\\log n) where n is number of nodes. Approach 2: Iterating method using Stack The strategy is very similiar to the first method, the different is using stack. Here is an illustration: !?!../Documents/94_Binary.json:1000,563!?!Complexity Analysis Time complexity: O(n) Space complexity: O(n) Approach 3: Morris Traversal In this method, we have to use a new data structure - Threaded Binary Tree, and the strategy is as follows: >Step 1: Initialize current as root > >Step 2: While current is not NULL, > > If current does not have left child > > a. Add currents value > > b. Go to the right, i.e., current = current.right > > Else > > a. In current's left subtree, make current the right child of the rightmost node > > b. Go to this left child, i.e., current = current.left For example: ``` 1 / \\ 2 3 / \\ / 4 5 6 ``` First, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current's left subtree is ``` 2 / \\ 4 5 ``` So in this subtree, the rightmost node is 5, then make the current(1) as the right child of 5. Set current = current.left (current = 2). The tree now looks like: ``` 2 / \\ 4 5 \\ 1 \\ 3 / 6 ``` For current 2, which has left child 4, we can continue with the same process as we did above ``` 4 \\ 2 \\ 5 \\ 1 \\ 3 / 6 ``` then add 4 because it has no left child, then add 2, 5, 1, 3 one by one, for node 3 which has left child 6, do the same as above. Finally, the inorder traversal is [4,2,5,1,6,3]. For more details, please check [Threaded binary tree](https://en.wikipedia.org/wiki/Threaded_binary_tree) and [Explanation of Morris Method](https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion)Complexity Analysis Time complexity: O(n) - To prove that the time complexity is O(n), the biggest problem lies in finding the time complexity of finding the predecessor nodes of all the nodes in the binary tree. Intuitively, the complexity is O(n \\log n), because to find the predecessor node for a single node related to the height of the tree. But in fact, finding the predecessor nodes for all nodes only needs O(n) time. Because a binary Tree with n nodes has n-1 edges, the whole processing for each edges up to 2 times, one is to locate a node, and the other is to find the predecessor node. So the complexity is O(n). Space complexity: O(1) - Extra space is only allocated for the ArrayList of size n, however the output does not count towards the space complexity.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: root = [1,null,2,3] Output: [1,3,2] Explanation:"
      },
      {
        "example_text": "Input: root = [1,2,3,4,5,null,8,null,null,6,7,9] Output: [4,2,6,5,7,1,3,9,8] Explanation:"
      },
      {
        "example_text": "Input: root = [] Output: []"
      },
      {
        "example_text": "Input: root = [1] Output: [1]"
      }
    ]
  },
  {
    "problem_slug": "unique-binary-search-trees-ii",
    "difficulty": "Medium",
    "topics": [
      "Dynamic Programming",
      "Backtracking",
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order. Example 1: Example 2: Constraints:",
    "solution": "Solution Overview Given an integer `n`, our task is to return all unique BSTs (binary search trees) that have exactly `n` nodes of unique values from `1` to `n`. Approach 1: Recursive Dynamic Programming Intuition In each node of a binary search tree (BST), all values in the left subtree are smaller and all values in the right subtree are greater. To find all the possible permutations of BSTs with `n` nodes, we can lock one node as the `root` node and split `n - 1` nodes between the left and right subtrees in all the possible ways. Let's say we place a node with value `i` as the root node and place `i - 1` nodes having values from `1` to `i - 1` in the left subtree. (If `i == 1`, the left child is null). Similarly, we place the remaining `n - i` nodes having values from `i + 1` to `n` in the right subtree. (If `i == n`, the right child is null). Now, we create a list of nodes called `leftSubTrees` for all the possible BSTs that could be the left subtree. Similarly, we create a list of nodes called `rightSubTrees` for all the BSTs that could be the right subtree. > In a BST, every subtree is also a BST. We iterate over both the lists and for each node pair `l` in `leftSubTrees` and `r` in `rightSubTrees`, we create a new `root` node with value `i` and set the left and right child of `root` to `l` and `r` respectively to form all the BSTs with the root node as `i`. We can iterate over the root's value from `i = 1` to `n` and repeat the process for each root value to get all the BSTs. You may notice that the subproblem of finding the arrays `leftSubTrees` and `rightSubTrees` are similar to the original problem. We can implement this approach using recursion as we are breaking down a problem with `n` nodes to smaller, repetitive subproblems with `i - 1` and `n - i` nodes (for `i = 1` till `n`) to compute the answer for `n` nodes. We only need the range of node values as the parameters to create the BSTs with nodes having values in that range. We implement a recursive function `allPossibleBST(start, end)` where `start` and `end` correspond to the range of node values that should be present in the BSTs created by this call. For a root node with value `i`, we will find all the left subtrees using `leftSubTrees = allPossibleBST(start, i - 1)` and also compute all the right subtrees using `rightSubTrees = allPossibleBST(i + 1, right)`. Finally, we iterate over all pairs between `leftSubTrees` and `rightSubTrees` and create a new root with value `i` for each pair. The base case of this function is when `start > end`. We have no values in our range and thus we will return `null` (an empty tree). Here is a visual representation of the recursion tree with `3` nodes: ![img](../Figures/95/95-1.png) Several subproblems, such as `allPossibleBST(1, 1)`, `allPossibleBST(3, 3)`, etc., are solved multiple times in the small partial recursion tree shown above. If we draw the entire recursion tree, we can see that there are many subproblems that are solved repeatedly. To avoid this issue, we store the solution of the subproblem in a hashmap that stores the mapping from a range of nodes values to the list of root nodes of all possible BSTs that can be formed with the same number of nodes. When we encounter the same subproblem again, we simply refer to this map to get the required list of `TreeNode`. This is called memoization. Algorithm 1. Create a hash map `memo` where `memo[(start, end)]` contains the list of root nodes of all possible BSTs with the range of node values from `start` to `end`. 2. We implement a recursive function `allPossibleBST` which takes the starting range of node values `start`, ending range `end`, and `memo` as parameters. It returns a list of `TreeNode` corresponding to all the BSTs that can be formed with this range of node values. We call `allPossibleBST(1, n, memo)` and perform the following: - We declare a list of `TreeNode` called `res` to store the list of root nodes of all possible BSTs. - If `start > end`, we push `null` to `res` and return it. - If we already have solved this subproblem, i.e., `memo` contains the pair `(start, end)`, we return `memo[(start, end)]`. - Select the root node value from `i = start` to `end` incrementing `i` by `1` after each iteration. We recursively call `leftSubtrees = llPossibleBST(start, i - 1, memo)` and `rightSubTrees = allPossibleBST(i + 1, end, memo)`. We iterate over all pairs between `leftSubtrees` and `rightSubTrees` and create a new root with value `i` for each pair. We push `root` of the new formed BST into `res`. - Set `memo[(start, end)] = res` and return `res`. Implementation Complexity Analysis Note, the time and space complexity of this problem is difficult to derive. In an interview, you should do your best to find an upper bound. The level of analysis here would not be expected in an interview. The number of unique BSTs that can be formed with `n` nodes is $G(n)$ where $G(n)$ is the $n^{th}$ [Catalan number](https://en.wikipedia.org/wiki/Catalan_number). $G(n) = O(\\dfrac{4^{n}}{n^{1.5}})$. * Time complexity: $O(\\dfrac{4^n}{\\sqrt{n}})$. - There are $G(n) = \\dfrac{4^n}{n^{1.5}}$ BSTs in our answer. Each of these BSTs has $n$ nodes, so it cost us $O(n)$ to build each one. This gives us a time complexity of $O(n \\cdot G(n)) = O(\\dfrac{4^n}{\\sqrt{n}})$. * Space complexity: $O(\\sum_{k=1}^{n}{[(n - k + 1) \\cdot \\dfrac{4^k}{\\sqrt{k}}]})$. We use some space for the recursion call stack, but the majority of the space used by the algorithm is storing the lists of BSTs in `memo`. Let's analyze how many nodes are stored in `memo`. The number of nodes in a range `start, end` is `end - start + 1`. Let $k = \\text{end} - \\text{start} + 1$ represent this formula. There are $n$ states `start, end` with one node, that is $k = 1$. There are $n - 1$ states `start, end` with two nodes, that is $k = 2$. There are $n - 2$ states `start, end` with three nodes, that is $k = 3$. This continues until there is only one state with $n$ nodes (the original input). In general, a value of $k$ has $n - k + 1$ states. For a given state with value $k$, there are $G(k) = \\dfrac{4^k}{k^{1.5}}$ BSTs. Each of these BSTs has $k$ nodes, and thus takes up $k \\cdot G(k) = \\dfrac{4^k}{\\sqrt{k}}$ space in `memo`. A given value $k$ has $n - k + 1$ states and thus takes up $(n - k + 1) \\cdot \\dfrac{4^k}{\\sqrt{k}}$ space. In our algorithm, $k$ ranges from $1$ to $n$. The space complexity is the summation for all values of $k$: $\\Large{\\sum_{k=1}^{n}{[(n - k + 1) \\cdot \\dfrac{4^k}{\\sqrt{k}}]}}$ This is a difficult sum to compute and involves higher-level mathematics. Using a program like WolframAlpha, we find that the sum is equal to: $4^{1 + n} \\cdot \\Phi(4, -0.5, 1 + n) - 4^{1 + n} \\cdot (1 + n) \\cdot \\Phi(4, 0.5, 1 + n) - \\text{Li}_{-0.5}(4) + \\text{Li}_{0.5}(4) + n \\cdot \\text{Li}_{0.5}(4)$ Where $\\Phi$ is the [Lerch transcendent](https://en.wikipedia.org/wiki/Lerch_zeta_function) and $\\text{Li}_n(x)$ is the [polylogarithm function](https://en.wikipedia.org/wiki/Polylogarithm). Needless to say, computing this sum by hand is not necessary in an interview. Even reaching the summation expression would likely impress any interviewer. Approach 2: Iterative Dynamic Programming Intuition We used memoization in the preceding approach to store the answers to subproblems in order to solve a larger problem. We can also use a bottom-up approach to solve such problems without using recursion. We build answers to subproblems iteratively first, then use them to build answers to larger problems. We create a 3D list `dp[n + 1][n + 1]` where `dp[i][j]` will store a list of all BSTs that have node values ranging from `i` to `j`. Note that `dp[i][j] = allPossibleBST(i, j)` from the previous approach. When `i = j`, the range contains only one node with value `i`. We push a single node with value `i` in the list `dp[i][i]` for all the values of `i` from `1` to `n`. This acts as the base case of our solution while we move in bottom to top manner. We form the answer with a smaller number of nodes having consecutive node values and move on to form answers for a bigger number of nodes. We run an outer loop from `numberOfNodes = 2` to `numberOfNodes = n` incrementing `numberOfNodes` by `1` after each iteration. This loop controls the total number of nodes under consideration. We further need to choose a node value we start with. Let's call it `start`. As we have `numberOfNodes` nodes under consideration with consecutive values, the maximum node value in such a BST would be `end = start + numberOfNodes - 1`. We will move `start` from `1` to `n - numberOfNodes + 1`. Now we have the `start` value and the `end` value, we can implement the same logic that we did in the `allPossibleBST` function from the previous approach. Lock a value `i`, find all left and right subtrees, and then iterate over each `left, right` pair and create a new root with value `i` for each pair. As we move from bottom to top, we will have a list of all the root nodes for all BSTs for every range of node values with lesser nodes. Locking a value `i` as the root node, we can find all left subtrees in `dp[start][i - 1]` and all right subtrees in `dp[i + 1][end]`. If `i == start`, the left subtree would be empty. Similarly, if `i == end`, the right subtree would be empty. We can handle these cases separately. We run an outer loop from `numberOfNodes = 2` to `n`. We run an inner loop that selects the starting node value. It runs from `start = 1` to `n - numberOfNodes + 1`. We define `end = start + numberOfNodes - 1`. We run a third nested loop that selects the root of the BSTs under consideration. It runs from `i = start` to `end`. We then iterate over the both the lists of left and right subtrees. For each root node `l` of the left subtree and `r` of the right subtree, we create a new `root` node with value `i` and set the left and right child to `l` and `r` respectively to form all the BSTs with root node as `i`. We also push each BST into `dp[start][end]` to be used later to build answer for other `dp` states with larger number of nodes. Algorithm 1. Create a 3D list `dp[n + 1][n + 1]` where `dp[i][j]` will store a list of root nodes for all possible BSTs using `j - i + 1` nodes with values from `i` to `j` nodes. 2. We initialize each list `dp[i][i]` to a `TreeNode` having value `i` for `i = 0` to `n`. 3. Iterate from `numberOfNodes = 2` till `numberOfNodes = n` incrementing `numberOfNodes` by `1` after each iteration. We start an inner loop from `start = 1` to `n - numberOfNodes + 1` incrementing `start` by `1`. We create an integer variable `end = start + numberOfNodes - 1` which stores the highest node value of the BSTs that will be formed. We run another loop from `i = start` to `end` to use all the permutations as the root node value. We perform the following in this loop: - We create a list of `TreeNode` called `leftSubtrees` which will store all the BSTs that can be formed with node values from `start` to `i - 1`. If `i == start`, we just add `null` to `leftSubtrees`, else `leftSubtrees == dp[start][i - 1]`. - Similarly, we create a list of `TreeNode` called `rightSubtrees` which will store all the BSTs that can be formed with node values from `i + 1` to `end`. If `i == end`, we just add `null` to `rightSubtrees`, else `rightSubtrees == dp[i + 1][end]`. - We form a new BST by creating a new node which acts as a root node with value `i`. For each element `left` in `leftSubtrees` and `right` in `rightSubtrees`, we set `root.left = left` and `root.right = right`. Finally, we add `root` to `dp[start][end]`. 4. Return `dp[1][n]`. Implementation Complexity Analysis * Time complexity: $O(\\dfrac{4^n}{\\sqrt{n}})$. - The time complexity of this approach will be similar to the time complexity of the first approach because we are iterating over the same `dp` states in bottom-up manner as compared to the previous approach where we used top-down approach with memoization. * Space complexity: $O(\\sum_{k=1}^{n}{[(n - k + 1) \\cdot \\dfrac{4^k}{\\sqrt{k}}]})$. - The space complexity would also be the number of BSTs stored in the `dp` list which is equal to the number of BSTs stored in `memo` in the worst-case. Hence, we have the same space complexity as the first approach. Approach 3: Dynamic Programming with Space Optimization Intuition We used a 3D list where we used `dp[start][end]` to store all the BSTs having `end - start + 1` nodes with range from `start` to `end`. Let's think if we can reduce the 3D `dp` list to a 2D list. If we compare all the BSTs that can be created from a set of consecutive values from `start` to `end` to those that can be created with the same number of nodes from a set of values starting at `1` and ending at `end - start + 1`, we will find that the structure of all the BSTs created with the above two ranges would be identical. The only difference is an offset of `start - 1` in the node values. Here's a visual representation of BSTs with 3 nodes from range `[1, 3]` and all BSTs with range `[4, 6]`: ![img](../Figures/95/95-2.png) We can see the structure of all the BSTs created with the above two ranges are identical. So, we can just store the BSTs for all the ranges starting from `1` and add the offset to convert them to required ranges. We create a 2D list `dp[n + 1]` where `dp[i]` will store a list of all BSTs with `i` nodes having values from `1` to `i`. `dp[n]` would be the answer to the problem. Similar to the above approach, we will move in bottom to top manner. We push a `null` node (empty tree) to `dp[0]` which acts as the base case. To get the list of root nodes for all possible BSTs with `numberOfNodes` nodes, we would split the `numberOfNodes` nodes with `i - 1` nodes with values `1` to `i - 1` in the left subtree, a root node with value `i` and the remaining `numberOfNodes - i` nodes with values `i + 1` to `numberOfNodes` in the right subtree where `1 <= i <= numberOfNodes`. Note that we do not need the starting of the range here, unlike the previous approach. It is always `1`. As we are executing in bottom-up manner and figuring out the answer for `numberOfNodes` nodes, we will already have the list of root nodes for all BSTs with `i - 1` and `numberOfNodes - i` nodes (for all values of `i = 1` to `numberOfNodes`). However, you may realize that `dp[i - 1]` will give all the BSTs having values from `1` to `i - 1` which is exactly what we want but `dp[numberOfNodes - i]` will give all the BSTs having values from `1` to `numberOfNodes - i` which isn't what we want. We want the right subtree to have `numberOfNodes - i` nodes but the range of nodes should be from `i + 1` to `numberOfNodes`. If we add the offset `(i + 1) - 1 = i` to all the nodes, it would solve this as we would now have trees with `numberOfNodes - i` nodes from values `i + 1` to `numberOfNodes`. Let us form the BSTs now. Similar to the previous approach, we create a new instance of `TreeNode` called `root` with the value `i`. We set the left child of `root` to an element in `dp[i - 1]`. Now, let's set the right child of `root`. We know every element in `dp[numberOfNodes - i]` is a root node that stores a BST with `numberOfNodes - 1` nodes having values from `1` to `numberOfNodes - i`. To set the right child of `root`, we create a new tree exactly similar to the tree stored by an element of `dp[numberOfNodes - i]` but increment all the node values of the new tree by `i`. We then set the right child of `root` to this newer tree. The required tree with `i` offset can be created by using a recursive function `clone` in which we pass a `TreeNode node` which corresponds to an element in `dp[numberOfNodes - i]` and an integer `offset`. We create a new `TreeNode clonedNode` with value `node.val + offset`. We then recursively set the left and the right child of `clonedNode` by performing `clonedNode.left = clone(node.left, offset)` and `clonedNode.right = clone(node.right, offset)`. Finally, return `clonedNode`. It is important to note that we are creating new trees to set the right child of `root` to preserve the original trees as it might be used directly (as `dp[i - 1]`) in some other iteration of `i` and `numberOfNodes`. Algorithm 1. Create a list `dp[n + 1]` where `dp[i]` will store a list of root nodes for all possible BSTs using `i` nodes. We initialize each list `dp[i]` to an empty list for `i = 0` to `n`. 2. We push a `null` node (empty tree) into `dp[0]` because with `n = 0` we can't have any BST. This forms the base case. 3. Iterate from `numberOfNodes = 1` till `numberOfNodes = n` incrementing `numberOfNodes` by `1` after each iteration. We start an inner loop from `i = 1` to `numberOfNodes` incrementing `i` by `1`. We perform the following in this loop: - Create a variable `j = numberOfNodes - i - 1`. It presents the number of nodes in the right subtree under consideration. - We can form a new BST by creating a new node which acts as a root node with value `i`. We assign its left child to any element in `dp[i]` and right child to a new tree where tree is similar to an element in `dp[j]` but all node values are incremented by `i`. As a result, we need two loops to iterate through the lists `dp[i]` and `dp[j]`. We create a new `root` node with value `i`. For each element `left` in `dp[i]` and `right` in `dp[j]`, we set `root.left = left` and `root.right = clone(right, i)`. Finally, we add `root` to `dp[numberOfNodes]`. 4. Return `dp[n]`. Implementation Complexity Analysis * Time complexity: $O(\\dfrac{4^n}{\\sqrt{n}})$. - In this approach we are not storing all the BSTs with all the ranges. We are just storing BSTs starting from range `1`. However, we are creating all the BSTs for all the ranges from `[start, end]` (for `1 <= start, end <= 1`) using the `clone` method by iterating over the BSTs starting with range `1`. - As a result, the time complexity should be similar to the previous approach as we are generating the same number of BSTs. * Space complexity: $O(\\sum_{k=1}^{n}\\dfrac{4^k}{{\\sqrt{k}}})$. - For any state `dp[k]`, we are storing all the BSTs that can be formed with $k$ nodes. We know there are $G(k)$ BSTs that can be formed with $k$ nodes. As we have $1$ to $n$ states, the total space consumed would be $O(\\sum_{k=1}^{n} k \\cdot G(k))$ = $O(\\sum_{k=1}^{n}\\dfrac{4^k}{{\\sqrt{k}}})$.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "example_text": "Input: n = 3 Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]"
      },
      {
        "example_text": "Input: n = 1 Output: [[1]]"
      }
    ]
  },
  {
    "problem_slug": "unique-binary-search-trees",
    "difficulty": "Medium",
    "topics": [
      "Math",
      "Dynamic Programming",
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 19"
    ],
    "examples": [
      {
        "example_text": "Input: n = 3 Output: 5"
      },
      {
        "example_text": "Input: n = 1 Output: 1"
      }
    ]
  },
  {
    "problem_slug": "interleaving-string",
    "difficulty": "Medium",
    "topics": [
      "String",
      "Dynamic Programming"
    ],
    "description": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2. An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that: Note: a + b is the concatenation of strings a and b. Example 1: Example 2: Example 3: Constraints: Follow up: Could you solve it using only O(s2.length) additional memory space?",
    "solution": "",
    "constraints": [
      "0 <= s1.length, s2.length <= 100",
      "0 <= s3.length <= 200",
      "s1, s2, and s3 consist of lowercase English letters."
    ],
    "examples": [
      {
        "example_text": "Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\" Output: true Explanation: One way to obtain s3 is: Split s1 into s1 = \"aa\" + \"bc\" + \"c\", and s2 into s2 = \"dbbc\" + \"a\". Interleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\". Since s3 can be obtained by interleaving s1 and s2, we return true."
      },
      {
        "example_text": "Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\" Output: false Explanation: Notice how it is impossible to interleave s2 with any other string to obtain s3."
      },
      {
        "example_text": "Input: s1 = \"\", s2 = \"\", s3 = \"\" Output: true"
      }
    ]
  },
  {
    "problem_slug": "validate-binary-search-tree",
    "difficulty": "Medium",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 104].",
      "-231 <= Node.val <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: root = [2,1,3] Output: true"
      },
      {
        "example_text": "Input: root = [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4."
      }
    ]
  },
  {
    "problem_slug": "recover-binary-search-tree",
    "difficulty": "Medium",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [2, 1000].",
      "-231 <= Node.val <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: root = [1,3,null,null,2] Output: [3,1,null,null,2] Explanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid."
      },
      {
        "example_text": "Input: root = [3,1,4,null,null,2] Output: [2,1,4,null,null,3] Explanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid."
      }
    ]
  },
  {
    "problem_slug": "same-tree",
    "difficulty": "Easy",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in both trees is in the range [0, 100].",
      "-104 <= Node.val <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: p = [1,2,3], q = [1,2,3] Output: true"
      },
      {
        "example_text": "Input: p = [1,2], q = [1,null,2] Output: false"
      },
      {
        "example_text": "Input: p = [1,2,1], q = [1,1,2] Output: false"
      }
    ]
  },
  {
    "problem_slug": "symmetric-tree",
    "difficulty": "Easy",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 1000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: root = [1,2,2,3,4,4,3] Output: true"
      },
      {
        "example_text": "Input: root = [1,2,2,null,3,null,3] Output: false"
      }
    ]
  },
  {
    "problem_slug": "binary-tree-level-order-traversal",
    "difficulty": "Medium",
    "topics": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level). Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "example_text": "Input: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]]"
      },
      {
        "example_text": "Input: root = [1] Output: [[1]]"
      },
      {
        "example_text": "Input: root = [] Output: []"
      }
    ]
  },
  {
    "problem_slug": "binary-tree-zigzag-level-order-traversal",
    "difficulty": "Medium",
    "topics": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between). Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: root = [3,9,20,null,null,15,7] Output: [[3],[20,9],[15,7]]"
      },
      {
        "example_text": "Input: root = [1] Output: [[1]]"
      },
      {
        "example_text": "Input: root = [] Output: []"
      }
    ]
  },
  {
    "problem_slug": "maximum-depth-of-binary-tree",
    "difficulty": "Easy",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 104].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: root = [3,9,20,null,null,15,7] Output: 3"
      },
      {
        "example_text": "Input: root = [1,null,2] Output: 2"
      }
    ]
  },
  {
    "problem_slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= preorder.length <= 3000",
      "inorder.length == preorder.length",
      "-3000 <= preorder[i], inorder[i] <= 3000",
      "preorder and inorder consist of unique values.",
      "Each value of inorder also appears in preorder.",
      "preorder is guaranteed to be the preorder traversal of the tree.",
      "inorder is guaranteed to be the inorder traversal of the tree."
    ],
    "examples": [
      {
        "example_text": "Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] Output: [3,9,20,null,null,15,7]"
      },
      {
        "example_text": "Input: preorder = [-1], inorder = [-1] Output: [-1]"
      }
    ]
  },
  {
    "problem_slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Tree",
      "Binary Tree"
    ],
    "description": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= inorder.length <= 3000",
      "postorder.length == inorder.length",
      "-3000 <= inorder[i], postorder[i] <= 3000",
      "inorder and postorder consist of unique values.",
      "Each value of postorder also appears in inorder.",
      "inorder is guaranteed to be the inorder traversal of the tree.",
      "postorder is guaranteed to be the postorder traversal of the tree."
    ],
    "examples": [
      {
        "example_text": "Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] Output: [3,9,20,null,null,15,7]"
      },
      {
        "example_text": "Input: inorder = [-1], postorder = [-1] Output: [-1]"
      }
    ]
  },
  {
    "problem_slug": "binary-tree-level-order-traversal-ii",
    "difficulty": "Medium",
    "topics": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root). Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "example_text": "Input: root = [3,9,20,null,null,15,7] Output: [[15,7],[9,20],[3]]"
      },
      {
        "example_text": "Input: root = [1] Output: [[1]]"
      },
      {
        "example_text": "Input: root = [] Output: []"
      }
    ]
  },
  {
    "problem_slug": "convert-sorted-array-to-binary-search-tree",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Divide and Conquer",
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 104",
      "-104 <= nums[i] <= 104",
      "nums is sorted in a strictly increasing order."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: [0,-10,5,null,-3,null,9] is also accepted:"
      },
      {
        "example_text": "Input: nums = [1,3] Output: [3,1] Explanation: [1,null,3] and [3,1] are both height-balanced BSTs."
      }
    ]
  },
  {
    "problem_slug": "convert-sorted-list-to-binary-search-tree",
    "difficulty": "Medium",
    "topics": [
      "Linked List",
      "Divide and Conquer",
      "Tree",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in head is in the range [0, 2 * 104].",
      "-105 <= Node.val <= 105"
    ],
    "examples": [
      {
        "example_text": "Input: head = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST."
      },
      {
        "example_text": "Input: head = [] Output: []"
      }
    ]
  },
  {
    "problem_slug": "balanced-binary-tree",
    "difficulty": "Easy",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "Given a binary tree, determine if it is height-balanced. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 5000].",
      "-104 <= Node.val <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: root = [3,9,20,null,null,15,7] Output: true"
      },
      {
        "example_text": "Input: root = [1,2,2,3,3,null,null,4,4] Output: false"
      },
      {
        "example_text": "Input: root = [] Output: true"
      }
    ]
  },
  {
    "problem_slug": "minimum-depth-of-binary-tree",
    "difficulty": "Easy",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 105].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "example_text": "Input: root = [3,9,20,null,null,15,7] Output: 2"
      },
      {
        "example_text": "Input: root = [2,null,3,null,4,null,5,null,6] Output: 5"
      }
    ]
  },
  {
    "problem_slug": "path-sum",
    "difficulty": "Easy",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 5000].",
      "-1000 <= Node.val <= 1000",
      "-1000 <= targetSum <= 1000"
    ],
    "examples": [
      {
        "example_text": "Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true Explanation: The root-to-leaf path with the target sum is shown."
      },
      {
        "example_text": "Input: root = [1,2,3], targetSum = 5 Output: false Explanation: There are two root-to-leaf paths in the tree: (1 --> 2): The sum is 3. (1 --> 3): The sum is 4. There is no root-to-leaf path with sum = 5."
      },
      {
        "example_text": "Input: root = [], targetSum = 0 Output: false Explanation: Since the tree is empty, there are no root-to-leaf paths."
      }
    ]
  },
  {
    "problem_slug": "path-sum-ii",
    "difficulty": "Medium",
    "topics": [
      "Backtracking",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 5000].",
      "-1000 <= Node.val <= 1000",
      "-1000 <= targetSum <= 1000"
    ],
    "examples": [
      {
        "example_text": "Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] Explanation: There are two paths whose sum equals targetSum: 5 + 4 + 11 + 2 = 22 5 + 8 + 4 + 5 = 22"
      },
      {
        "example_text": "Input: root = [1,2,3], targetSum = 5 Output: []"
      },
      {
        "example_text": "Input: root = [1,2], targetSum = 0 Output: []"
      }
    ]
  },
  {
    "problem_slug": "flatten-binary-tree-to-linked-list",
    "difficulty": "Medium",
    "topics": [
      "Linked List",
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, flatten the tree into a \"linked list\": Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: root = [1,2,5,3,4,null,6] Output: [1,null,2,null,3,null,4,null,5,null,6]"
      },
      {
        "example_text": "Input: root = [] Output: []"
      },
      {
        "example_text": "Input: root = [0] Output: [0]"
      }
    ]
  },
  {
    "problem_slug": "distinct-subsequences",
    "difficulty": "Hard",
    "topics": [
      "String",
      "Dynamic Programming"
    ],
    "description": "Given two strings s and t, return the number of distinct subsequences of s which equals t. The test cases are generated so that the answer fits on a 32-bit signed integer. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= s.length, t.length <= 1000",
      "s and t consist of English letters."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"rabbbit\", t = \"rabbit\" Output: 3 Explanation: As shown below, there are 3 ways you can generate \"rabbit\" from s. rabbbit rabbbit rabbbit"
      },
      {
        "example_text": "Input: s = \"babgbag\", t = \"bag\" Output: 5 Explanation: As shown below, there are 5 ways you can generate \"bag\" from s. babgbag babgbag babgbag babgbag babgbag"
      }
    ]
  },
  {
    "problem_slug": "populating-next-right-pointers-in-each-node",
    "difficulty": "Medium",
    "topics": [
      "Linked List",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Example 1: Example 2: Constraints: Follow-up:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 212 - 1].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "example_text": "struct Node { int val; Node *left; Node *right; Node *next; }"
      },
      {
        "example_text": "Input: root = [1,2,3,4,5,6,7] Output: [1,,2,3,,4,5,6,7,] Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '' signifying the end of each level."
      },
      {
        "example_text": "Input: root = [] Output: []"
      }
    ]
  },
  {
    "problem_slug": "populating-next-right-pointers-in-each-node-ii",
    "difficulty": "Medium",
    "topics": [
      "Linked List",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Given a binary tree Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Example 1: Example 2: Constraints: Follow-up:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 6000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "example_text": "struct Node { int val; Node *left; Node *right; Node *next; }"
      },
      {
        "example_text": "Input: root = [1,2,3,4,5,null,7] Output: [1,,2,3,,4,5,7,] Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '' signifying the end of each level."
      },
      {
        "example_text": "Input: root = [] Output: []"
      }
    ]
  },
  {
    "problem_slug": "pascals-triangle",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "Given an integer numRows, return the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it as shown: Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= numRows <= 30"
    ],
    "examples": [
      {
        "example_text": "Input: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]"
      },
      {
        "example_text": "Input: numRows = 1 Output: [[1]]"
      }
    ]
  },
  {
    "problem_slug": "pascals-triangle-ii",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it as shown: Example 1: Example 2: Example 3: Constraints: Follow up: Could you optimize your algorithm to use only O(rowIndex) extra space?",
    "solution": "",
    "constraints": [
      "0 <= rowIndex <= 33"
    ],
    "examples": [
      {
        "example_text": "Input: rowIndex = 3 Output: [1,3,3,1]"
      },
      {
        "example_text": "Input: rowIndex = 0 Output: [1]"
      },
      {
        "example_text": "Input: rowIndex = 1 Output: [1,1]"
      }
    ]
  },
  {
    "problem_slug": "triangle",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= triangle.length <= 200",
      "triangle[0].length == 1",
      "triangle[i].length == triangle[i - 1].length + 1",
      "-104 <= triangle[i][j] <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] Output: 11 Explanation: The triangle looks like: 2 3 4 6 5 7 4 1 8 3 The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above)."
      },
      {
        "example_text": "Input: triangle = [[-10]] Output: -10"
      }
    ]
  },
  {
    "problem_slug": "best-time-to-buy-and-sell-stock",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= prices.length <= 105",
      "0 <= prices[i] <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell."
      },
      {
        "example_text": "Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0."
      }
    ]
  },
  {
    "problem_slug": "best-time-to-buy-and-sell-stock-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Greedy"
    ],
    "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= prices.length <= 3 * 104",
      "0 <= prices[i] <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: prices = [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Total profit is 4 + 3 = 7."
      },
      {
        "example_text": "Input: prices = [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Total profit is 4."
      },
      {
        "example_text": "Input: prices = [7,6,4,3,1] Output: 0 Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0."
      }
    ]
  },
  {
    "problem_slug": "best-time-to-buy-and-sell-stock-iii",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete at most two transactions. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= prices.length <= 105",
      "0 <= prices[i] <= 105"
    ],
    "examples": [
      {
        "example_text": "Input: prices = [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3."
      },
      {
        "example_text": "Input: prices = [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again."
      },
      {
        "example_text": "Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0."
      }
    ]
  },
  {
    "problem_slug": "binary-tree-maximum-path-sum",
    "difficulty": "Hard",
    "topics": [
      "Dynamic Programming",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root. The path sum of a path is the sum of the node's values in the path. Given the root of a binary tree, return the maximum path sum of any non-empty path. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 3 * 104].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "example_text": "Input: root = [1,2,3] Output: 6 Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6."
      },
      {
        "example_text": "Input: root = [-10,9,20,null,null,15,7] Output: 42 Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42."
      }
    ]
  },
  {
    "problem_slug": "valid-palindrome",
    "difficulty": "Easy",
    "topics": [
      "Two Pointers",
      "String"
    ],
    "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 2 * 105",
      "s consists only of printable ASCII characters."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"A man, a plan, a canal: Panama\" Output: true Explanation: \"amanaplanacanalpanama\" is a palindrome."
      },
      {
        "example_text": "Input: s = \"race a car\" Output: false Explanation: \"raceacar\" is not a palindrome."
      },
      {
        "example_text": "Input: s = \" \" Output: true Explanation: s is an empty string \"\" after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome."
      }
    ]
  },
  {
    "problem_slug": "word-ladder-ii",
    "difficulty": "Hard",
    "topics": [
      "Hash Table",
      "String",
      "Backtracking",
      "Breadth-First Search"
    ],
    "description": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that: Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk]. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= beginWord.length <= 5",
      "endWord.length == beginWord.length",
      "1 <= wordList.length <= 500",
      "wordList[i].length == beginWord.length",
      "beginWord, endWord, and wordList[i] consist of lowercase English letters.",
      "beginWord != endWord",
      "All the words in wordList are unique.",
      "The sum of all shortest transformation sequences does not exceed 105."
    ],
    "examples": [
      {
        "example_text": "Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] Output: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]] Explanation: There are 2 shortest transformation sequences: \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\" \"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\""
      },
      {
        "example_text": "Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] Output: [] Explanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence."
      }
    ]
  },
  {
    "problem_slug": "word-ladder",
    "difficulty": "Hard",
    "topics": [
      "Hash Table",
      "String",
      "Breadth-First Search"
    ],
    "description": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that: Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= beginWord.length <= 10",
      "endWord.length == beginWord.length",
      "1 <= wordList.length <= 5000",
      "wordList[i].length == beginWord.length",
      "beginWord, endWord, and wordList[i] consist of lowercase English letters.",
      "beginWord != endWord",
      "All the words in wordList are unique."
    ],
    "examples": [
      {
        "example_text": "Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] Output: 5 Explanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long."
      },
      {
        "example_text": "Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] Output: 0 Explanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence."
      }
    ]
  },
  {
    "problem_slug": "longest-consecutive-sequence",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Hash Table",
      "Union Find"
    ],
    "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "0 <= nums.length <= 105",
      "-109 <= nums[i] <= 109"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4."
      },
      {
        "example_text": "Input: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9"
      },
      {
        "example_text": "Input: nums = [1,0,1,2] Output: 3"
      }
    ]
  },
  {
    "problem_slug": "sum-root-to-leaf-numbers",
    "difficulty": "Medium",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "You are given the root of a binary tree containing digits from 0 to 9 only. Each root-to-leaf path in the tree represents a number. Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer. A leaf node is a node with no children. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 1000].",
      "0 <= Node.val <= 9",
      "The depth of the tree will not exceed 10."
    ],
    "examples": [
      {
        "example_text": "Input: root = [1,2,3] Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25."
      },
      {
        "example_text": "Input: root = [4,9,0,5,1] Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026."
      }
    ]
  },
  {
    "problem_slug": "surrounded-regions",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "description": "You are given an m x n matrix board containing letters 'X' and 'O', capture regions that are surrounded: To capture a surrounded region, replace all 'O's with 'X's in-place within the original board. You do not need to return anything. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "m == board.length",
      "n == board[i].length",
      "1 <= m, n <= 200",
      "board[i][j] is 'X' or 'O'."
    ],
    "examples": [
      {
        "example_text": "Input: board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Output: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Explanation: In the above diagram, the bottom region is not captured because it is on the edge of the board and cannot be surrounded."
      },
      {
        "example_text": "Input: board = [[\"X\"]] Output: [[\"X\"]]"
      }
    ]
  },
  {
    "problem_slug": "palindrome-partitioning",
    "difficulty": "Medium",
    "topics": [
      "String",
      "Dynamic Programming",
      "Backtracking"
    ],
    "description": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 16",
      "s contains only lowercase English letters."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"aab\" Output: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]"
      },
      {
        "example_text": "Input: s = \"a\" Output: [[\"a\"]]"
      }
    ]
  },
  {
    "problem_slug": "palindrome-partitioning-ii",
    "difficulty": "Hard",
    "topics": [
      "String",
      "Dynamic Programming"
    ],
    "description": "Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 2000",
      "s consists of lowercase English letters only."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"aab\" Output: 1 Explanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut."
      },
      {
        "example_text": "Input: s = \"a\" Output: 0"
      },
      {
        "example_text": "Input: s = \"ab\" Output: 1"
      }
    ]
  },
  {
    "problem_slug": "clone-graph",
    "difficulty": "Medium",
    "topics": [
      "Hash Table",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "description": "Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors. Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the graph is in the range [0, 100].",
      "1 <= Node.val <= 100",
      "Node.val is unique for each node.",
      "There are no repeated edges and no self-loops in the graph.",
      "The Graph is connected and all nodes can be visited starting from the given node."
    ],
    "examples": [
      {
        "example_text": "class Node { public int val; public List<Node> neighbors; }"
      },
      {
        "example_text": "Input: adjList = [[2,4],[1,3],[2,4],[1,3]] Output: [[2,4],[1,3],[2,4],[1,3]] Explanation: There are 4 nodes in the graph. 1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). 3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3)."
      },
      {
        "example_text": "Input: adjList = [[]] Output: [[]] Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors."
      },
      {
        "example_text": "Input: adjList = [] Output: [] Explanation: This an empty graph, it does not have any nodes."
      }
    ]
  },
  {
    "problem_slug": "gas-station",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Greedy"
    ],
    "description": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "n == gas.length == cost.length",
      "1 <= n <= 105",
      "0 <= gas[i], cost[i] <= 104",
      "The input is generated such that the answer is unique."
    ],
    "examples": [
      {
        "example_text": "Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3 Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index."
      },
      {
        "example_text": "Input: gas = [2,3,4], cost = [3,4,3] Output: -1 Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start."
      }
    ]
  },
  {
    "problem_slug": "candy",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Greedy"
    ],
    "description": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings. You are giving candies to these children subjected to the following requirements: Return the minimum number of candies you need to have to distribute the candies to the children. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "n == ratings.length",
      "1 <= n <= 2 * 104",
      "0 <= ratings[i] <= 2 * 104"
    ],
    "examples": [
      {
        "example_text": "Input: ratings = [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively."
      },
      {
        "example_text": "Input: ratings = [1,2,2] Output: 4 Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions."
      }
    ]
  },
  {
    "problem_slug": "single-number",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Bit Manipulation"
    ],
    "description": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 3 * 104",
      "-3 * 104 <= nums[i] <= 3 * 104",
      "Each element in the array appears twice except for one element which appears only once."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [2,2,1] Output: 1"
      },
      {
        "example_text": "Input: nums = [4,1,2,1,2] Output: 4"
      },
      {
        "example_text": "Input: nums = [1] Output: 1"
      }
    ]
  },
  {
    "problem_slug": "single-number-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Bit Manipulation"
    ],
    "description": "Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it. You must implement a solution with a linear runtime complexity and use only constant extra space. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 3 * 104",
      "-231 <= nums[i] <= 231 - 1",
      "Each element in nums appears exactly three times except for one element which appears once."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [2,2,3,2] Output: 3"
      },
      {
        "example_text": "Input: nums = [0,1,0,1,0,1,99] Output: 99"
      }
    ]
  },
  {
    "problem_slug": "copy-list-with-random-pointer",
    "difficulty": "Medium",
    "topics": [
      "Hash Table",
      "Linked List"
    ],
    "description": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: Your code will only be given the head of the original linked list. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "0 <= n <= 1000",
      "-104 <= Node.val <= 104",
      "Node.random is null or is pointing to some node in the linked list."
    ],
    "examples": [
      {
        "example_text": "Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]] Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]"
      },
      {
        "example_text": "Input: head = [[1,1],[2,1]] Output: [[1,1],[2,1]]"
      },
      {
        "example_text": "Input: head = [[3,null],[3,0],[3,null]] Output: [[3,null],[3,0],[3,null]]"
      }
    ]
  },
  {
    "problem_slug": "word-break",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Hash Table",
      "String",
      "Dynamic Programming",
      "Trie",
      "Memoization"
    ],
    "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation. Example 1: Example 2: Example 3: Constraints:",
    "solution": "Video Solution Solution Article Approach 1: Breadth-First Search Intuition Let's imagine the indices of `s` as a graph. Each index can be thought of as a node, which represents building `s` up to the index. Adding a word to an existing string is like an edge between nodes. For a node `start`, we can move to node `end` if the substring of `s` between `start, end` exists in `wordDict`. For example, let's say we have `s = \"leetcode\"` and `wordDict = [\"leet\", \"code\"]`. We are currently at node `4`, which implies that we have built `\"leet\"` (the first 4 characters of `s`). We can move to node `8`, because the substring of `s` with indices `[4, 8)` is `\"code\"`, which is in `wordDict`. We start at node `0`, which represents the empty string. We want to reach node `s.length`, which implies that we have built the entire string. We can run a BFS to accomplish this traversal. If you're not familiar with BFS, check out the relevant [Explore Card](https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/). At each node `start`, we iterate over all the nodes `end` that come after `start`. For each `end`, we check if the substring between `start, end` is in `wordDict`. If it is, we can add `end` to the queue. We will first convert `wordDict` into a set so that we can perform the checks in constant time. We will also use a data structure `seen` to prevent us from visiting a node more than once. Algorithm 1. Convert `wordDict` into a set `words`. 2. Initialize a `queue` with `0` and a set `seen`. 3. While the `queue` is not empty: - Remove the first element, `start`. - If `start == s.length`, return `true`. - Iterate `end` from `start + 1` up to and including `s.length`. For each `end`, if `end` has not been visited yet, - Check the substring starting at `start` and ending before `end`. If it is in `words`, add `end` to the queue and mark it in `seen`. 4. Return `false` if the BFS finishes without reaching the final node. ImplementationComplexity Analysis Given n as the length of `s`, m as the length of `wordDict`, and k as the average length of the words in `wordDict`, * Time complexity: O(n^3 + m \\cdot k) There are O(n) nodes. Because of `seen`, we never visit a node more than once. At each node, we iterate over the nodes in front of the current node, of which there are O(n). For each node `end`, we create a substring, which also costs O(n). Therefore, handling a node costs O(n^2), so the BFS could cost up to O(n^3). Finally, we also spent O(m \\cdot k) to create the set `words`. * Space complexity: O(n + m \\cdot k) We use O(n) space for `queue` and `seen`. We use O(m \\cdot k) space for the set `words`. Approach 2: Top-Down Dynamic Programming Intuition > If you're not familiar with dynamic programming, we recommend checking out the [Dynamic Programming explore card](https://leetcode.com/explore/featured/card/dynamic-programming/). This problem is on the difficult side, so we will assume that readers are already familiar with the principles of DP. Let's have a function `dp` that returns a boolean indicating if it is possible to build `s` up to and including the index `i`. For example, given `s = \"leetcode\"` and `wordDict = [\"leet\", \"code\"]`, `dp(3)` would return `true`. `s` up to index `3` is `\"leet\"`, and we can build `\"leet\"` using the words in `wordDict`. The answer to the problem would be `dp(s.length - 1)`, which represents if we can build `s`. The base case of this function is when `i < 0`. This would represent an empty string, and we can always build an empty string by doing nothing. Therefore, `dp(i) = true` for `i < 0`. Given an index `i`, we need a recurrence relation to determine if `dp(i)` is `true` or `false`. For `dp(i)` to be `true`, there are two requirements: 1. First, there needs to be a `word` from `wordDict` that ends at index `i`. Given a `word`, the substring of `s` from indices `i - word.length + 1` up to and including `i` should match `word`. We can check every `word` for this. 2. If we manage to find a `word` that ends at index `i`, we would need to add it on top of another string (since we are building `s` by joining words together one by one). We need to make sure that the string we are adding onto is also buildable. If we find a `word` that passes the first check, it means `word` would start at index `i - word.length + 1`. The index before that is `i - word.length`. To check if the string ending at that index is buildable, we can refer to `dp(i - word.length)`. This gives us our recurrence relation: \\large{\\text{dp(i)} = \\text{any}(\\text{s}[\\text{i - word.length + 1, i}] == \\text{word \\&\\& dp(i - \\text{word.length})})} That is, there exists any `word` that satisfies both of the listed conditions. We can implement a recursive function `dp(i)` that implements the base cases and recurrence. We need to use memoization to avoid repeated computation. !?!../Documents/139.json:960,540!?! Algorithm 1. Declare a data structure `memo` that stores the values of `dp` for each index. 2. Create a function `dp(i)`: - If `i < 0`, return `true`. - If we already calculated `i`, return the value stored in `memo`. - Iterate over `wordDict`. For each `word`: - Check the substring of `s` ending at `i` with the same length as `word`. If the substring matches, and `dp(i - word.length)` is `true`, return `true`. - If no `word` satisfying the criteria was found, return `false`. 3. Return `dp(s.length - 1)`. Implementation > In Python, thefunctoolsmodule provides super handy tools that automatically memoize a function for us. We're going to use the `@cache` decorator in the Python implementation. > > In Java and C++, we will use an array `memo` to save values. `memo[i] = -1` if we haven't calculated yet, `memo[i] = 0` if `dp(i) = false`, and `memo[i] = 1` if `dp(i) = true`.Complexity Analysis Given n as the length of `s`, m as the length of `wordDict`, and k as the average length of the words in `wordDict`, * Time complexity: O(n \\cdot m \\cdot k) There are n states of `dp(i)`. Because of memoization, we only calculate each state once. To calculate a state, we iterate over m words, and for each word perform some substring operations which costs O(k). Therefore, calculating a state costs O(m \\cdot k), and we need to calculate O(n) states. * Space complexity: O(n) The data structure we use for memoization and the recursion call stack can use up to O(n) space. Approach 3: Bottom-Up Dynamic Programming Intuition The same algorithm can be implemented iteratively. Instead of using a function `dp(i)`, we will use an array `dp` where `dp[i]` represents the same thing that `dp(i)` did. We can use the same recurrence relation: \\large{\\text{dp[i]} = \\text{any}(\\text{s}[\\text{i - word.length + 1, i}] == \\text{word \\&\\& dp[i - \\text{word.length}]})} In top-down, we started at the top (`s.length - 1`) and work our way down to the base cases. In bottom-up, we start at the bottom `(i = 0)` and work our way up to the top. Before we check `dp[i - word.length]`, we should check if `i == word.length - 1`. This would mean that the current `word` we are placing to end at index `i` is the first word. `i - word.length` would be negative, so we need to separately check this case. Algorithm 1. Initialize an array `dp` with the same length as `s` and all values initially set to `false`. 2. Iterate `i` over the indices of `s`. At each `i`: - Iterate over each `word` in `wordDict`: - Check if `i == word.length - 1` or `dp[i - word.length] = true`. - If so, and the substring of `s` ending at `i` with the same length as `word` matches, set `dp[i] = true` and `break`. 3. Return `dp[s.length - 1]`. ImplementationComplexity Analysis Given n as the length of `s`, m as the length of `wordDict`, and k as the average length of the words in `wordDict`, * Time complexity: O(n \\cdot m \\cdot k) The logic behind the time complexity is identical to the previous approach. It costs us O(m \\cdot k) to calculate each state, and we calculate O(n) states in total. * Space complexity: O(n) We use an array `dp` of length n. Approach 4: Trie Optimization Intuition In the previous approach, we iterated over each state `i` and then calculated `dp[i]`. To calculate a given `dp[i]`, we did the following: - Iterate over every `word` in `wordDict` - Check if each `word` ended at the current index This cost us O(m \\cdot k). In the problem constraints, we can see that the maximum value of m \\cdot k is `20,000`, so this is expensive. We can optimize the time it takes to calculate a given `dp[i]` by using a trie. A trie is a data structure that can be used to efficiently search for strings. If you are not familiar with tries, we highly recommend you read the official solution to [this problem](https://leetcode.com/problems/implement-trie-prefix-tree/solution) before proceeding with this approach. To summarize, a trie is a tree where each node is labeled. Here, we label each node with a character. The path from the root to any node represents the string that is built by the nodes on the path. The root represents the empty string.We can start by building a trie from the words in `wordDict`. Each trie node will have an additional attribute `isWord` which indicates if the current node represents a word from `wordDict`. Then, we will calculate the same `dp` array as in the previous approach. We will calculate each state as follows: - First, check if `i == 0` (placing first word) or `dp[i - 1]` (we could build the string up to this point). If neither are true, move on to the next state `i + 1`. - Otherwise, we see if `dp[i]` can be `true`. Initialize a node `curr` at the `root` of the trie. - Start iterating with a variable `j` from index `i`. For each character `s[j]`, check if we can traverse the trie. - If we can't traverse the trie, it means no words exist starting at index `i` and ending at index `j` or beyond. We can break from the loop and move on to the next state `i + 1`. - If we can traverse the trie, we move to the child node. We check the child's `isWord` attribute. If it is `true`, it means there is a word in `wordDict` starting at index `i` and ending at index `j`. We set `dp[j] = true`. - We continue traversing the trie until we reach a dead end or `j` reaches the end of the string. This allows us to handle each state in O(n) instead of O(m \\cdot k), which is a big improvement since n \\leq 300. Algorithm 1. Build a trie from `wordDict`. Each node should also have an `isWord` attribute. Store the root of the trie in `root`. 2. Initialize an array `dp` with the same length as `s` and all values initially set to `false`. 3. Iterate `i` over the indices of `s`. At each `i`: - Check if `i == 0` or `dp[i - 1] = true`. If not, continue to the next `i`. - Set `curr = root`. Iterate `j` over the indices of `s`, starting from `i`. At each `j`, - Get the character at index `j` as `c = s[j]`. - If `c` is not in the children of `curr`, we can `break` from the loop. - Otherwise, move `curr` to the child labeled `c`. - If `curr.isWord`, set `dp[j] = true`. 4. Return `dp[s.length - 1]`. ImplementationComplexity Analysis Given n as the length of `s`, m as the length of `wordDict`, and k as the average length of the words in `wordDict`, * Time complexity: O(n^2 + m \\cdot k) Building the trie involves iterating over all characters of all words. This costs O(m \\cdot k). Once we build the trie, we calculate `dp`. For each `i`, we iterate over all the indices after `i`. We have a basic nested for loop which costs O(n^2) to handle all `dp[i]`. * Space complexity: O(n + m \\cdot k) The `dp` array takes O(n) space. The trie can have up to m \\cdot k nodes in it. Approach 5: A Different DP Intuition > In this approach, we will take a look at another way to implement the DP algorithm. Note that this approach is the one covered in the video. Here, we let `dp[i]` hold the answer to the question: \"is it possible to form `s` up to a length of `i`? To find the answer for each index, instead of iterating over the words in `wordDict` and checking if a `word` ends at the current index `i`, we will instead iterate over all substrings that end before index `i`. If we find one of these substrings is in `wordDict` and we can form the string prior to the substring, then `dp[i] = true`. The reason we are checking for before index `i` is because we have slightly changed our `dp` definition here. In the previous problem, `i` represented the index of the last character. Here, `i` represents the length, so we are offset by one. Before starting the DP, we first convert `wordsDict` to a set so that we can perform the checks in $O(1)$. The rest of the algorithm follows similarly to the previous approaches. Algorithm 1. Convert `wordsDict` to a set `words`. 2. Initialize an array `dp` of length `n + 1` with all values set to `false`. 3. Iterate `i` from `1` until and including `n`. Here, `i` represents the length of the string starting from the beginning. - Iterate `j` from `0` until `i`. Here, `j` represents the first index of the substring we are checking. - If `dp[j]` is true AND the substring `s[j:i]` is in `words`, set `dp[i] = true` and break. Note that `s[j:i]` represents the substring starting at `j` and ending at `i - 1`. 4. Return `dp[n]`. ImplementationComplexity Analysis Given n as the length of `s`, m as the length of `wordDict`, and k as the average length of the words in `wordDict`, * Time complexity: O(n^3 + m \\cdot k) First, we spend O(m \\cdot k) to convert `wordDict` into a set. Then we have a nested loop over `n`, which iterates O(n^2) times. For each iteration, we have a substring operation which could cost up to O(n). Thus this nested loop costs O(n^3). * Space complexity: O(n + m \\cdot k) The `dp` array takes O(n) space. The set `words` takes up O(m \\cdot k) space.",
    "constraints": [
      "1 <= s.length <= 300",
      "1 <= wordDict.length <= 1000",
      "1 <= wordDict[i].length <= 20",
      "s and wordDict[i] consist of only lowercase English letters.",
      "All the strings of wordDict are unique."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"leetcode\", wordDict = [\"leet\",\"code\"] Output: true Explanation: Return true because \"leetcode\" can be segmented as \"leet code\"."
      },
      {
        "example_text": "Input: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"] Output: true Explanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word."
      },
      {
        "example_text": "Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] Output: false"
      }
    ]
  },
  {
    "problem_slug": "word-break-ii",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Hash Table",
      "String",
      "Dynamic Programming",
      "Backtracking",
      "Trie",
      "Memoization"
    ],
    "description": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Note that the same word in the dictionary may be reused multiple times in the segmentation. Example 1: Example 2: Example 3: Constraints:",
    "solution": "Solution Overview We have a string `s` and a dictionary of strings `wordDict`. The task is to add spaces in `s` to construct valid sentences where each word is present in `wordDict` and return all possible valid sentences. The same word from the dictionary can be reused multiple times. This problem is an extension of [Problem 139. Word Break I](https://leetcode.com/problems/word-break/description/), where the goal was to determine if a word could be segmented into other words from a given dictionary. In this problem, however, we need to find all possible ways to split the word into valid statements. To understand this problem, it is beneficial to be familiar with [Problem 139. Word Break I](https://leetcode.com/problems/word-break/description/) as well as [Problem 208. Implement Trie Prefix Tree](https://leetcode.com/problems/implement-trie-prefix-tree/), as those questions provide the foundational concepts and intuition necessary for solving this problem. Here, we will focus on the applications of recursion, dynamic programming, and tries, rather than on understanding their underlying mechanisms. To gain an understanding of their underlying mechanisms, we suggest you check out these explore cards: 1. [Backtracking Explore Card](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/). 2. [Dynamic Programming Explore Card](https://leetcode.com/explore/learn/card/dynamic-programming/). 3. [Trie Explore Card](https://leetcode.com/explore/learn/card/trie/). Approach 1: Backtracking Intuition Initially, we might think of a brute-force approach where we systematically explore all possible ways to break the string into words from the dictionary. This leads us to the backtracking strategy, where we recursively try to form words from the string and add them to a current sentence if they are in the dictionary. If the current prefix doesn't lead to a valid solution, we backtrack by removing the last added word and trying the next possible word. This ensures we explore all possible segmentations of the string. At each step, we consider all possible end indices for substrings starting from the current index. For each substring, we check if it exists in the dictionary. If the substring is a valid word, we append it to the current sentence and recursively call the function with the updated index, which is the end index of the substring plus one. If we reach the end of the string, it means we have found a valid segmentation, and we can add the current sentence to the results. However, if we encounter a substring that is not a valid word, we backtrack by returning from that recursive call and trying the next possible end index. The backtracking approach will be inefficient due to the large number of recursive calls, especially for longer strings. To increase efficiency, we will convert the word dictionary into a set for constant-time lookups. However, the overall time complexity remains high because we explore all possible partitions. The process is visualized below: ![backtrack](../Figures/140/backtrack.png) Algorithm `wordBreak` Function: - Convert the `wordDict` array into an unordered set `wordSet` for efficient lookups. - Initialize an empty array `results` to store valid sentences. - Initialize an empty string `currentSentence` to keep track of the sentence being constructed. - Call the `backtrack` function with the input string `s`, `wordSet`, `currentSentence`, `results`, and a starting index set to 0, the beginning of the input string. - Return `results`. `backtrack` Function: - Base Case: If the `startIndex` is equal to the length of the string, add the `currentSentence` to `results` and return as it means that `currentSentence` represents a valid sentence. - Iterate over possible `endIndex` values from `startIndex + 1` to the end of the string. - Extract the substring `word` from `startIndex` to `endIndex - 1`. - If `word` is found in `wordSet`: - Store the current `currentSentence` in `originalSentence`. - Append `word` to `currentSentence` (with a space if needed). - Recursively call `backtrack` with the updated `currentSentence` and `endIndex`. - Reset `currentSentence` to its original value (`originalSentence`) to backtrack and try the next `endIndex`. - Return from the `backtrack` function. Implementation Complexity Analysis Let $n$ be the length of the input string. - Time complexity: $O(n \\cdot 2^n)$ The algorithm explores all possible ways to break the string into words. In the worst case, where each character can be treated as a word, the recursion tree has $2^n$ leaf nodes, resulting in an exponential time complexity. For each leaf node, $O(n)$ work is performed, so the overall complexity is $O(n \\cdot 2^n)$. - Space complexity: $O(2^n)$ The recursion stack can grow up to a depth of $n$, where each recursive call consumes additional space for storing the current state. Since each position in the string can be a split point or not, and for $n$ positions, there are $2^n$ possible combinations of splits. Thus, in the worst case, each combination generates a different sentence that needs to be stored, leading to exponential space complexity. Approach 2: Dynamic Programming - Memoization Intuition We can improve the efficiency of the backtracking method by using Memoization, which stores the results of subproblems to avoid recalculating them. We use a depth-first search (DFS) function that recursively breaks the string into words. However, before performing a recursive call, we check if the results for the current substring have already been computed and stored in a memoization map (typically a dictionary or hash table). If the results of the current substring are found in the memoization map, we can directly return them without further computation. If not, we proceed with the recursive call, computing the results and storing them in the memoization map before returning them. By memoizing the results, we can reduce the number of computations by ensuring that each substring is processed only once in average cases. Algorithm `wordBreak` Function: - Convert the `wordDict` array into an unordered set `wordSet` for efficient lookups. - Initialize an empty unordered map `memoization` to store the results of subproblems. - Call the `dfs` function with the input string `s`, `wordSet`, and `memoization`. `dfs` Function: - Check if the answer for the current `remainingStr`(the remaining part of the string to be processed) are already in `memoization`. If so, return them. - Base Case: If `remainingStr` is empty, it means that all characters have been processed. An empty string represents a valid sentence so return an array containing the empty string. - Initialize an empty array `results`. - Iterate from 1 to the length of `remainingStr`: - Extract the substring `currentWord` from 0 to `i` to check if it is a valid word. - If `currentWord` is found in `wordSet`: - Recursively call `dfs` with `remainingStr.substr(i)`, `wordSet`, and `memoization`. - Append `currentWord` and the recursive results to `results`(with a space if needed) to form valid sentences. - Store the `results` for `remainingStr` in `memoization`. - Return `results`. Implementation Complexity Analysis Let $n$ be the length of the input string. * Time complexity: $O(n \\cdot 2^n)$ While memoization avoids redundant computations, it does not change the overall number of subproblems that need to be solved. In the worst case, there are still unique $2^n$ possible substrings that need to be explored, leading to an exponential time complexity. For each subproblem, $O(n)$ work is performed, so the overall complexity is $O(n \\cdot 2^n)$. * Space complexity: $O(n \\cdot 2^n)$ The recursion stack can grow up to a depth of $n$, where each recursive call consumes additional space for storing the current state. The memoization map needs to store the results for all possible substrings, which can be up to $2^n$ substrings of size $n$ in the worst case, resulting in an exponential space complexity. Approach 3: Dynamic Programming - Tabulation Intuition While memoization improves the backtracking approach, we might consider an alternative approach using dynamic programming principles. This leads us to the tabulation method, which builds a table (or map) of valid sentences for each starting index in the string. The tabulation approach is often more efficient than backtracking and memoization in terms of time and space complexity because it avoids the overhead of recursive calls and stack usage. It also eliminates the need for a separate memoization map, as the table itself serves as the storage for the subproblem solutions. The tabulation approach works in a bottom-up manner, iterating from the end of the string towards the beginning. At each step, we construct all possible sentences that can be formed starting from the current index by checking if substrings form valid words in the dictionary. If a valid word is found, we combine it with the valid sentences formed from the remaining substring. This process continues until we reach the beginning of the string, building up the table of valid sentences for each starting index. The key idea behind tabulation is that we ensure all subproblems are solved before they are needed, enabling the construction of complete solutions in an organized manner. By iterating from the end to the beginning of the string, we guarantee that the necessary subproblems have already been solved when we need them. Algorithm - Initialize an empty unordered map `dp` to store the results of subproblems. - Iterate from the end of the string to the beginning (`startIdx` from `s.size()` to 0): - Initialize an empty array `validSentences` to store all valid sentences starting from that index. - Iterate from `startIdx` to the end of the string (`endIdx`): - Extract the substring `currentWord` from `startIdx` to `endIdx`. - If `currentWord` is a valid word in `wordDict`: - If `endIdx` is the last index, add `currentWord` to `validSentences`. - Else, append `currentWord` to each sentence formed by the remaining substring (`sentencesFromNextIndex`) from `dp[endIdx + 1]`. - Store `validSentences` in `dp[startIdx]`. - Return `dp[0]` (valid sentences formed from the entire string). The algorithm is visualized below: !?!../Documents/140/tabulation.json:976,631!?! Implementation Complexity Analysis Let $n$ be the length of the input string. * Time complexity: $O(n \\cdot 2^n)$ Similar to memoization, the tabulation approach still needs to explore all possible substrings, which can be up to $2^n$ in the worst case, leading to an exponential time complexity. $O(n)$ work is performed to explore each substring, so the overall complexity is $O(n \\cdot 2^n)$. * Space complexity: $O(n \\cdot 2^n)$ The dynamic programming table or map needs to store the valid sentences for all possible starting indices, which can be up to $2^n$ strings of size $n$ in the worst case, resulting in an exponential space complexity. Approach 4: Trie Optimization Intuition While the previous approaches focus on optimizing the search and computation process, we can also consider leveraging efficient data structures to enhance the word lookup process. This leads us to the trie-based approach, which uses a trie data structure to store the word dictionary, allowing efficient word lookup and prefix matching. > The trie, also known as a prefix tree, is a tree-based data structure where each node represents a character in a word, and the path from the root to a leaf node represents a complete word. This structure is particularly useful for problems involving word segmentation because it allows for efficient prefix matching. Here, we first build a trie from the dictionary words. Each word is represented as a path in the trie, where each node corresponds to a character in the word. By using the trie, we can quickly determine whether a substring can form a valid word without having to perform linear searches or set lookups. This reduces the search space and improves the efficiency of the algorithm. In this approach, instead of recursively exploring the remaining substring and using memoization, we iterate from the end of the input string to the beginning (in reverse order). For each starting index (`startIdx`), we attempt to find valid sentences that can be formed from that index by iterating through the string and checking if the current substring forms a valid word using the trie data structure. When a valid word is encountered in the trie, we append it to the list of valid sentences for the current starting index. If the current valid word is not the last word in the sentence, we combine it with the valid sentences formed from the next index (`endIdx + 1`), which are retrieved from the `dp` dictionary. The valid sentences for each starting index are stored in the `dp` dictionary, ensuring that previously computed results are reused. By using tabulation and storing the valid sentences for each starting index, we avoid redundant computations and achieve significant time and space efficiency improvements compared to the standard backtracking method with memoization. The trie-based approach offers advantages in terms of efficient word lookup and prefix matching, making it particularly suitable for problems involving word segmentation or string manipulation. However, it comes with the additional overhead of constructing and maintaining the trie data structure, which can be more memory-intensive for large dictionaries. Algorithm Initialize TrieNode Structure - Each TrieNode has two properties: - `isEnd`: A boolean value indicating if the node marks the end of a word. - `children`: An array of size 26 (for lowercase English letters) to store pointers to child nodes. - The constructor initializes `isEnd` to `false` and all elements in `children` to `null`. Trie Class - The Trie class has a `root` pointer of type `TrieNode`. - The constructor initializes the `root` with a new `TrieNode` object. - The `insert` function: - Takes a string `word` as input. - Starts from the `root` node. - For each character `c` in the `word`: - Calculate the index corresponding to the character. - If the child node at the calculated index doesn't exist, create a new `TrieNode` and assign it to that index. - Move to the child node. - After processing all characters, mark the current node's `isEnd` as `true`. wordBreak Function - Create a `Trie` object. - Insert all words from `wordDict` into the trie using the `insert` function. - Initialize a map `dp` to store the results of subproblems. - Iterate from the end of the string `s` to the beginning (in reverse order). - For each starting index `startIdx`: - Initialize a vector `validSentences` to store valid sentences starting from `startIdx`. - Initialize a `current_node` pointer to the `root` of the trie. - Iterate from `startIdx` to the end of the string. - For each character `c` in the string: - Calculate the index corresponding to `c`. - Check if the child node at the calculated index exists in the trie. - If the child node doesn't exist, break out of the inner loop. This means that the current substring cannot form a valid word, so there is no need to continue checking the remaining characters. - Move to the child node. - Check if the current node's `isEnd` is `true`, indicating a valid word. - If a valid word is found: - Extract the current word from the string using `substr`. - If it's the last word in the sentence (`endIdx` is the last index): - Add the current word to `validSentences`. - If it's not the last word: - Retrieve the valid sentences formed by the remaining substring from `dp[endIdx + 1]`. - Combine the current word with each sentence and add it to `validSentences`. - Store the `validSentences` for the current `startIdx` in `dp`. - Return the valid sentences stored in `dp[0]`, which represents the valid sentences formed from the entire string. Implementation Complexity Analysis Let $n$ be the length of the input string. * Time complexity: $O(n \\cdot 2^n)$ Even though the trie-based approach uses an efficient data structure for word lookup, it still needs to explore all possible ways to break the string into words. In the worst case, there are $2^n$ unique possible partitions, leading to an exponential time complexity. $O(n)$ work is performed for each partition, so the overall complexity is $O(n \\cdot 2^n)$. * Space complexity: $O(n \\cdot 2^n)$ The trie data structure itself can have a maximum of $2^n$ nodes in the worst case, where each character in the string represents a separate word. Additionally, the tabulation map used in this approach can also store up to $2^n$ strings of size $n$, resulting in an overall exponential space complexity. Further Thoughts On Complexity Analysis: The complexity of this problem cannot be reduced from $n \\cdot 2^n$; the worst-case scenario will still be $(n \\cdot 2^n)$. However, using dynamic programming (DP) will make it a bit more efficient than backtracking overall because of the below test case. Consider the input `\"aaaaaa\"`, with `wordDict = [\"a\", \"aa\", \"aaa\", \"aaaa\", \"aaaaa\", \"aaaaa\"]`. Every possible partition is a valid sentence, and there are $2^{n-1}$ such partitions. The algorithms cannot perform better than this since they must generate all valid sentences. The cost of iterating over cached results will be exponential, as every possible partition will be cached, resulting in the same runtime as regular backtracking. Likewise, the space complexity will also be $O(n \\cdot 2^n)$ for the same reasonevery partition is stored in memory. Another way to explain why the worst-case complexity is $O(n \\cdot 2^n)$ for all the algorithms is that, given an array of length $n$, there are $n+1$ ways/intervals to partition it into two parts. Each interval has two choices: to split or not to split. In the worst case, we will have to check all possibilities, which results in a time complexity of $O(n \\cdot 2^{n+1})$, which simplifies to $O(n \\cdot 2^n)$. This analysis is extremely similar to palindrome partitioning. Overall, this question is interesting because of the nature of this complexity. In an interview setting, if an interviewer asks this question, the most expected solutions would be Backtracking and Trie, as they become natural choices for the conditions and outputs we need.",
    "constraints": [
      "1 <= s.length <= 20",
      "1 <= wordDict.length <= 1000",
      "1 <= wordDict[i].length <= 10",
      "s and wordDict[i] consist of only lowercase English letters.",
      "All the strings of wordDict are unique.",
      "Input is generated in a way that the length of the answer doesn't exceed 105."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"] Output: [\"cats and dog\",\"cat sand dog\"]"
      },
      {
        "example_text": "Input: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"] Output: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"] Explanation: Note that you are allowed to reuse a dictionary word."
      },
      {
        "example_text": "Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] Output: []"
      }
    ]
  },
  {
    "problem_slug": "linked-list-cycle",
    "difficulty": "Easy",
    "topics": [
      "Hash Table",
      "Linked List",
      "Two Pointers"
    ],
    "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. Example 1: Example 2: Example 3: Constraints: Follow up: Can you solve it using O(1) (i.e. constant) memory?",
    "solution": "",
    "constraints": [
      "The number of the nodes in the list is in the range [0, 104].",
      "-105 <= Node.val <= 105",
      "pos is -1 or a valid index in the linked-list."
    ],
    "examples": [
      {
        "example_text": "Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed)."
      },
      {
        "example_text": "Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 0th node."
      },
      {
        "example_text": "Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list."
      }
    ]
  },
  {
    "problem_slug": "linked-list-cycle-ii",
    "difficulty": "Medium",
    "topics": [
      "Hash Table",
      "Linked List",
      "Two Pointers"
    ],
    "description": "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. Example 1: Example 2: Example 3: Constraints: Follow up: Can you solve it using O(1) (i.e. constant) memory?",
    "solution": "",
    "constraints": [
      "The number of the nodes in the list is in the range [0, 104].",
      "-105 <= Node.val <= 105",
      "pos is -1 or a valid index in the linked-list."
    ],
    "examples": [
      {
        "example_text": "Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node."
      },
      {
        "example_text": "Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node."
      },
      {
        "example_text": "Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list."
      }
    ]
  },
  {
    "problem_slug": "reorder-list",
    "difficulty": "Medium",
    "topics": [
      "Linked List",
      "Two Pointers",
      "Stack",
      "Recursion"
    ],
    "description": "You are given the head of a singly linked-list. The list can be represented as: Reorder the list to be on the following form: You may not modify the values in the list's nodes. Only nodes themselves may be changed. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the list is in the range [1, 5 * 104].",
      "1 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "example_text": "L0  L1    Ln - 1  Ln"
      },
      {
        "example_text": "L0  Ln  L1  Ln - 1  L2  Ln - 2  "
      },
      {
        "example_text": "Input: head = [1,2,3,4] Output: [1,4,2,3]"
      },
      {
        "example_text": "Input: head = [1,2,3,4,5] Output: [1,5,2,4,3]"
      }
    ]
  },
  {
    "problem_slug": "binary-tree-preorder-traversal",
    "difficulty": "Easy",
    "topics": [
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, return the preorder traversal of its nodes' values. Example 1: Example 2: Example 3: Example 4: Constraints: Follow up: Recursive solution is trivial, could you do it iteratively?",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: root = [1,null,2,3] Output: [1,2,3] Explanation:"
      },
      {
        "example_text": "Input: root = [1,2,3,4,5,null,8,null,null,6,7,9] Output: [1,2,4,5,6,7,3,8,9] Explanation:"
      },
      {
        "example_text": "Input: root = [] Output: []"
      },
      {
        "example_text": "Input: root = [1] Output: [1]"
      }
    ]
  },
  {
    "problem_slug": "binary-tree-postorder-traversal",
    "difficulty": "Easy",
    "topics": [
      "Stack",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, return the postorder traversal of its nodes' values. Example 1: Example 2: Example 3: Example 4: Constraints:",
    "solution": "Solution Overview To traverse a tree, we use two main strategies: - Breadth-First Search (BFS): This strategy involves scanning the tree level by level from the top down, visiting nodes at higher levels before those at lower levels. - Depth-First Search (DFS): This approach explores as far down a branch as possible before backtracking. It starts at the root, proceeds to a leaf, and then returns to explore other branches. DFS can be further categorized into: - Preorder: Visit the root first, then the left subtree, followed by the right subtree. - Inorder: Visit the left subtree first, then the root, and then the right subtree. - Postorder: Visit the left subtree first, then the right subtree, and finally the root. ![Tree Traversal Example](../Figures/145/traverse2.png) *Figure 1. Nodes are numbered in the order they are visited; refer to the sequence `1-2-3-4-5` to compare different traversal strategies.* For a binary tree with the root `[1, null, 2, 3]`, the tree structure is as follows: ``` 1 \\ 2 / 3 ``` In Postorder traversal, nodes are visited in the sequence: `3` (left subtree), `2` (right subtree), and finally `1` (root). Thus, the output for this input should be `[3, 2, 1]`. Approach 1: Recursive Postorder Traversal Intuition ![recursion](../Figures/145/recursion.png) *Figure 2. Recursive DFS traversals.* In this approach, we treat each node as the root of its subtree. We start by recursively traversing the left subtree. If the left child is not null, we continue exploring until the left subtree is fully traversed. Then, we move to the right subtree and repeat the process. After both subtrees are explored, we process the current node by adding its value to the result list. The base case occurs when the current node is null, indicating no further subtree to explore. At this point, we simply return and backtrack. Algorithm 1. Define a helper function `postorderTraversalHelper`: - If `currentNode` is `null`, return to stop further recursion. - Recursively call `postorderTraversalHelper` with `currentNode->left` to process the left subtree. - Recursively call `postorderTraversalHelper` with `currentNode->right` to process the right subtree. - Append `currentNode->val` to the `result` array to collect values in postorder. 2. In the `postorderTraversal` function: - Initialize an empty `result` array to store the postorder ordering of the nodes in`root`. - Call `postorderTraversalHelper` with the root node and `result` to start the traversal. - Return the `result` array containing the postorder traversal. Implementation Complexity Analysis Let $n$ be the number of nodes. - Time complexity: $O(n)$ Each node is visited once during the traversal, so the time complexity is linear with respect to the number of nodes `n`. - Space complexity: $O(n)$ The space complexity is $O(n)$ due to the recursion stack. In the worst case (e.g., a completely unbalanced tree), the recursion stack could hold all `n` nodes. Approach 2: Manipulating Preorder Traversal (Iterative Hack) Intuition Let's take a creative leap in this approach by exploiting the relationship between preorder and postorder traversals. In a standard preorder traversal, we visit the root node before we visit the left and right subtrees. However, postorder traversal requires us to visit the left and right subtrees before the root node. We can adapt the preorder traversal by visiting nodes in the order of root, right subtree, and then left subtree. Reversing the resulting list from this modified preorder traversal gives us the correct postorder sequence. We use a stack to traverse the tree iteratively, starting with the root node. We push the current node onto the stack and add its value to the result list. Instead of moving to the left child, we move to the right child. If there's no right child, we pop a node from the stack and move to its left child. This approach processes the right subtree before the left subtree, aligning with the modified preorder traversal. After traversing the entire tree, we reverse the result list to get the postorder sequence: left subtree, right subtree, root. Algorithm 1. Initialize an empty `result` list to store the traversal result, a `traversalStack` for nodes, and set `currentNode` to `root`. 2. While `currentNode` is not `null` or `traversalStack` is not empty: - If `currentNode` is not `null`, add `currentNode->val` to the `result` list before processing its children. - Push `currentNode` onto the `traversalStack` to revisit it later. - Move `currentNode` to `currentNode->right` to continue traversal in the right subtree. - If `currentNode` is `null`, pop the top node from `traversalStack` and set it to `currentNode`. - Move `currentNode` to `currentNode->left` to process the left subtree. 3. Reverse the `result` list to correct the order from preorder to postorder. 4. Return the `result` list with postorder traversal values. Implementation Complexity Analysis Let $n$ be the number of nodes. * Time complexity: $O(n)$ Each node is processed a constant number of times (essentially twice), so the time complexity remains linear with respect to `n`. * Space complexity: $O(n)$ The space complexity is $O(2n) = O(n)$ due to the stack used for traversing the tree nodes. This stack could hold up to `n` nodes in the worst case. Approach 3: Two Stack Postorder Traversal (Iterative) Intuition Instead of relying on hacks and tricks, this time we will build on the idea that we need to control the order in which nodes are processed to achieve postorder traversal. To achieve postorder traversal without recursion, we use two stacks to control the node processing order systematically. First, we push the root node onto the first stack. This stack simulates the recursive traversal of the tree. To process nodes in postorder (left-right-root), we need a second stack to reverse the order. As we pop nodes from the first stack, we push them onto the second stack. This reversal ensures that nodes are processed in the correct order. After all nodes are transferred to the second stack, popping from it gives us the nodes in postorder sequence. This method efficiently achieves the desired traversal order by leveraging the two stacks to manage the processing sequence without needing a final reversal step. In summary, the two-stack approach uses the first stack for tree traversal and the second stack to reverse the order, resulting in a postorder traversal. Despite initially seeming like a manipulation of preorder traversal, the final order of nodes from the second stack aligns with postorder traversal. Algorithm 1. Initialize an empty `result` list, and create `mainStack` and `pathStack` for nodes. 2. Check if `root` is `null`; if so, return `result` immediately, indicating there are no nodes to process. 3. Push `root` onto `mainStack` to start the traversal. 4. While `mainStack` is not empty: - Peek at the top of `mainStack` to examine the current node. - If the top of `pathStack` is the same as the top of `mainStack`, add `root->val` to the `result` list. - Pop the top node from both `mainStack` and `pathStack` after processing. - Otherwise, push the current node onto `pathStack`. - Push `root->right` and `root->left` onto `mainStack` if they exist to process their children. 5. Return the `result` list containing postorder traversal values. Implementation Complexity Analysis Let $n$ be the number of nodes. * Time complexity: $O(n)$ Each node is processed a constant number of times (once when pushed to the first stack and once when popped to the second stack), so the time complexity is linear with respect to `n`. * Space complexity: $O(n)$ The space complexity is $O(n)$ due to the use of two stacks. Each stack can hold up to `n` nodes in the worst case. Approach 4: Single Stack Postorder Traversal (Iterative) Intuition After exploring the two-stack approach, we might seek to optimize further by reducing space complexity. While two stacks effectively manage traversal order, they double our space usage. Instead, we can use a single stack combined with a `previousNode` pointer to track the traversal. We start by pushing nodes onto the stack while traversing left, similar to inorder traversal. In postorder traversal, we must process each node after its right subtree. To manage this, the `previousNode` pointer helps remember the last processed node. When a node is reached on the stack, we first check if it has an unvisited right child. If so, we move to that right child since we can't process the current node until after its right subtree. If the node has no right child or its right child has already been processed (indicated by `previousNode`), we process the node by popping it from the stack and adding its value to the result list, then update `previousNode` to this node. Algorithm 1. Initialize an empty `result` list, set `previousNode` to `null`, and initialize `traversalStack`. 2. Check if `root` is `null`; if so, return `result` immediately, indicating there are no nodes to process. 3. While `root` is not `null` or `traversalStack` is not empty: - If `root` is not `null`, push `root` onto `traversalStack`. - Move `root` to `root->left` to process the left subtree. - If `root` is `null`, peek at the top of `traversalStack`. - If `root->right` is `null` or `root->right` equals `previousNode`, add `root->val` to `result`. - Pop `root` from `traversalStack`, set `previousNode` to `root`, and set `root` to `null`. - If `root->right` is not `null`, move `root` to `root->right` to continue the traversal. 4. Return the `result` list containing postorder traversal values. Implementation Complexity Analysis Let $n$ be the number of nodes. * Time complexity: $O(n)$ Each node is processed a constant number of times. The stack operations and pointer manipulations also contribute to a linear time complexity with respect to `n`. * Space complexity: $O(n)$ Although this approach uses only a single stack, in the worst case, the stack can still hold up to `n` nodes, so the space complexity remains $O(n)$. However, this approach optimizes the space usage compared to using two stacks. Approach 5: Morris Traversal (No stack) Intuition All the approaches so far have been using some auxiliary space. To optimize for space complexity, we can use a traversal algorithm called Morris traversal. In Morris traversal, the tree structure is temporarily modified to create temporary links that simulate the effect of a stack or recursion. As a result, there is no overhead from additional data structures and the space complexity is constant. This traversal is tricky to understand at first, but the high level idea is to link each predecessor back to the current node, which allows us to trace back to the top of the tree. We encourage you to simulate the traversal on a piece of paper to get a stronger understanding. In setting up Morris traversal, we introduce a `dummyNode` with a value that is not part of the original tree and link it to the root. Our traversal begins with this dummyNode, treating it as the new root of the tree. For each node, we look for its in-order predecessor, the rightmost node in its left subtree. We do this so that the in-order predecessor can be used to create a temporary link back to the current node, simulating the recursive call stack. - If the current node has a left child, we find the rightmost node in the left subtree. This rightmost node is the in-order predecessor. - We then create a temporary link from this predecessor to the current node by setting its right pointer to the current node. If the predecessors right pointer is `null`, set it to point to the current node and move to the left child. This simulates the recursive call by allowing us to return to the current node after processing the left subtree. When a nodes predecessors right pointer points back to the current node, it indicates the left subtree is processed. Process the current node and reverse the temporary link to restore the trees structure. Finally, move to the right child and continue the traversal. Morris traversal operates in $O(n)$ time because finding the predecessor is not done for every node but only for nodes with a valid left child. > Note: Morris traversal may be a surprise topic in interviews. Its useful to know but not always the main focus; prioritize understanding basic traversal methods first. Algorithm 1. Initialize an empty `result` list and create a dummy node with the value `-1`. Set `dummyNode->left` to `root` and update `root` to `dummyNode`. 2. Check if `root` is `null`; if so, return `result` immediately, indicating there are no nodes to process. 3. While `root` is not `null`: - If `root->left` is not `null`, find the rightmost node (predecessor) in the `root->left` subtree. - If the right child of the predecessor is `null`, set the right child to `root` and move `root` to `root->left`. - If the right child of the predecessor is `root`, perform reverse traversal of the `root->left` subtree and add values to `result`. - Reverse the subtree back to its original state by restoring pointers. - Remove the temporary link from the predecessor to `root` and move `root` to `root->right`. - If `root->left` is `null`, move `root` to `root->right`. 4. Return the `result` list containing postorder traversal values. Implementation Complexity Analysis Let $n$ be the number of nodes. * Time complexity: $O(n)$ Each node is visited a constant number of times, and the traversal through the tree is linear in terms of `n`. * Space complexity: $O(1)$ The Morris Traversal technique uses no extra space beyond the pointers used for traversal. The temporary modifications to the tree structure are reversed before the traversal ends, so the space complexity is constant.",
    "constraints": [
      "The number of the nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: root = [1,null,2,3] Output: [3,2,1] Explanation:"
      },
      {
        "example_text": "Input: root = [1,2,3,4,5,null,8,null,null,6,7,9] Output: [4,6,7,5,2,9,8,3,1] Explanation:"
      },
      {
        "example_text": "Input: root = [] Output: []"
      },
      {
        "example_text": "Input: root = [1] Output: [1]"
      }
    ]
  },
  {
    "problem_slug": "lru-cache",
    "difficulty": "Medium",
    "topics": [
      "Hash Table",
      "Linked List",
      "Design",
      "Doubly-Linked List"
    ],
    "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: The functions get and put must each run in O(1) average time complexity. Example 1: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= capacity <= 3000",
      "0 <= key <= 104",
      "0 <= value <= 105",
      "At most 2 * 105 calls will be made to get and put."
    ],
    "examples": [
      {
        "example_text": "Input [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, null, -1, 3, 4] Explanation LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // cache is {1=1} lRUCache.put(2, 2); // cache is {1=1, 2=2} lRUCache.get(1); // return 1 lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3} lRUCache.get(2); // returns -1 (not found) lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3} lRUCache.get(1); // return -1 (not found) lRUCache.get(3); // return 3 lRUCache.get(4); // return 4"
      }
    ]
  },
  {
    "problem_slug": "insertion-sort-list",
    "difficulty": "Medium",
    "topics": [
      "Linked List",
      "Sorting"
    ],
    "description": "Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head. The steps of the insertion sort algorithm: The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration. Example 1: Example 2: Constraints:",
    "solution": "Video Solution Solution Article Overview [Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) is an intuitive sorting algorithm, although it is much less efficient than the more advanced algorithms such as quicksort or merge sort. Often that we perform the sorting algorithm on an [Array](https://leetcode.com/explore/learn/card/fun-with-arrays) structure, this problem though asks us to perform the insertion sort on a linked list data structure, which makes the implementation a bit challenging. In this article, we will present some tricks to manipulate the linked list, which would help us to simplify the logics of implementation. Approach 1: Insertion Sort Intuition Let us first review the idea of insertion sort algorithm, which can be broke down into the following steps: - First of all, we create an empty list which would be used to hold the results of sorting. - We then iterate through each element in the _input_ list. For each element, we need to find a proper position in the resulting list to insert the element, so that the order of the resulting list is maintained. - As one can see, once the iteration in the above step terminates, we will obtain the resulting list where the elements are _ordered_. Now, let us walk through a simple example, by applying the above intuition. Given the input list `input=[4, 3, 5]`, we have initially an empty resulting list `result=[]`. - We then iterate over the input list. For the first element `4`, we need to find a proper position in the resulting list to place it. Since the resulting list is still empty, we then simply _append_ it to the resulting list, _i.e._ `result=[4]`. ![step 1](../Figures/147/147_linked_list_step_1.png) - Now for the second element (_i.e._ `3`) in the input list, similarly we need to insert it properly into the resulting list. As one can see, we need to insert it right before the element `4`. As a result, the resulting list becomes `[3, 4]`. ![step 2](../Figures/147/147_linked_list_step_2.png) - Finally, for the last element (_i.e._ `5`) in the input list, as it turns out, the proper position to place it is the _tail_ of the resulting list. With this last iteration, we obtain a _sorted_ list as `result=[3, 4, 5]`. ![step 3](../Figures/147/147_linked_list_step_3.png) Algorithm To translate the above intuition into the implementation, we applied two tricks. >The first trick is that we will create a `dummy` (`pseudo_head`) node which serves as a pointer pointing to the resulting list. More precisely, this node facilitates us to always get a _hold_ on the resulting list, especially when we need to insert a new element to the head of the resulting list. One will see later in more details how it can greatly simplify the logic. In a _singly-linked list_, each node has only one pointer that points to the next node. If we would like to insert a new node (say `B`) before certain node (say `A`), we need to know the node (say `C`) that is currently before the node `A`, _i.e._ `C -> A`. With the reference in the node `C`, we could now insert the new node, _i.e._ `C -> B -> A`. Given the above insight, in order to insert a new element into a singly-linked list, we apply another trick. >The idea is that we use a _pair of pointers_ (namely `prev -> next`) which serve as place-holders to guard the position where in-between we would insert a new element (_i.e._ `prev -> new_node -> next`). With the same example before, _i.e._ `input=[4, 3, 5]`, we illustrate what the above helper pointers look like at the moment of insertion, in the following graph: ![pointers](../Figures/147/147_pointers.png) Implementation Here are some sample implementations based on the above ideas: Complexity Analysis Let $N$ be the number of elements in the input list. - Time Complexity: $\\mathcal{O}(N^2)$ - First of all, we run an iteration over the input list. - At each iteration, we insert an element into the resulting list. In the worst case where the position to insert is the tail of the list, we have to walk through the entire resulting list. - As a result, the total steps that we need to walk in the worst case would be $\\sum_{i=1}^{N} i = \\frac{N(N+1)}{2}$. - To sum up, the overall time complexity of the algorithm is $\\mathcal{O}(N^2)$. - Space Complexity: $\\mathcal{O}(1)$ - We used some pointers within the algorithm. However, their memory consumption is constant regardless of the input. - Note, we did not create new nodes to hold the values of input list, but simply _reorder_ the existing nodes.",
    "constraints": [
      "The number of nodes in the list is in the range [1, 5000].",
      "-5000 <= Node.val <= 5000"
    ],
    "examples": [
      {
        "example_text": "Input: head = [4,2,1,3] Output: [1,2,3,4]"
      },
      {
        "example_text": "Input: head = [-1,5,3,4,0] Output: [-1,0,3,4,5]"
      }
    ]
  },
  {
    "problem_slug": "sort-list",
    "difficulty": "Medium",
    "topics": [
      "Linked List",
      "Two Pointers",
      "Divide and Conquer",
      "Sorting",
      "Merge Sort"
    ],
    "description": "Given the head of a linked list, return the list after sorting it in ascending order. Example 1: Example 2: Example 3: Constraints: Follow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)?",
    "solution": "",
    "constraints": [
      "The number of nodes in the list is in the range [0, 5 * 104].",
      "-105 <= Node.val <= 105"
    ],
    "examples": [
      {
        "example_text": "Input: head = [4,2,1,3] Output: [1,2,3,4]"
      },
      {
        "example_text": "Input: head = [-1,5,3,4,0] Output: [-1,0,3,4,5]"
      },
      {
        "example_text": "Input: head = [] Output: []"
      }
    ]
  },
  {
    "problem_slug": "max-points-on-a-line",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Hash Table",
      "Math",
      "Geometry"
    ],
    "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= points.length <= 300",
      "points[i].length == 2",
      "-104 <= xi, yi <= 104",
      "All the points are unique."
    ],
    "examples": [
      {
        "example_text": "Input: points = [[1,1],[2,2],[3,3]] Output: 3"
      },
      {
        "example_text": "Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4"
      }
    ]
  },
  {
    "problem_slug": "evaluate-reverse-polish-notation",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Math",
      "Stack"
    ],
    "description": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression. Return an integer that represents the value of the expression. Note that: Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= tokens.length <= 104",
      "tokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200]."
    ],
    "examples": [
      {
        "example_text": "Input: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"] Output: 9 Explanation: ((2 + 1) * 3) = 9"
      },
      {
        "example_text": "Input: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"] Output: 6 Explanation: (4 + (13 / 5)) = 6"
      },
      {
        "example_text": "Input: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22"
      }
    ]
  },
  {
    "problem_slug": "reverse-words-in-a-string",
    "difficulty": "Medium",
    "topics": [
      "Two Pointers",
      "String"
    ],
    "description": "Given an input string s, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces. Example 1: Example 2: Example 3: Constraints: Follow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 104",
      "s contains English letters (upper-case and lower-case), digits, and spaces ' '.",
      "There is at least one word in s."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"the sky is blue\" Output: \"blue is sky the\""
      },
      {
        "example_text": "Input: s = \" hello world \" Output: \"world hello\" Explanation: Your reversed string should not contain leading or trailing spaces."
      },
      {
        "example_text": "Input: s = \"a good example\" Output: \"example good a\" Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
      }
    ]
  },
  {
    "problem_slug": "maximum-product-subarray",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "Given an integer array nums, find a subarray that has the largest product, and return the product. The test cases are generated so that the answer will fit in a 32-bit integer. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 2 * 104",
      "-10 <= nums[i] <= 10",
      "The product of any subarray of nums is guaranteed to fit in a 32-bit integer."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6."
      },
      {
        "example_text": "Input: nums = [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray."
      }
    ]
  },
  {
    "problem_slug": "find-minimum-in-rotated-sorted-array",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Binary Search"
    ],
    "description": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become: Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 5000",
      "-5000 <= nums[i] <= 5000",
      "All the integers of nums are unique.",
      "nums is sorted and rotated between 1 and n times."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [3,4,5,1,2] Output: 1 Explanation: The original array was [1,2,3,4,5] rotated 3 times."
      },
      {
        "example_text": "Input: nums = [4,5,6,7,0,1,2] Output: 0 Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times."
      },
      {
        "example_text": "Input: nums = [11,13,15,17] Output: 11 Explanation: The original array was [11,13,15,17] and it was rotated 4 times."
      }
    ]
  },
  {
    "problem_slug": "find-minimum-in-rotated-sorted-array-ii",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Binary Search"
    ],
    "description": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become: Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array. You must decrease the overall operation steps as much as possible. Example 1: Example 2: Constraints: Follow up: This problem is similar to Find Minimum in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?",
    "solution": "",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 5000",
      "-5000 <= nums[i] <= 5000",
      "nums is sorted and rotated between 1 and n times."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,3,5] Output: 1"
      },
      {
        "example_text": "Input: nums = [2,2,2,0,1] Output: 0"
      }
    ]
  },
  {
    "problem_slug": "min-stack",
    "difficulty": "Medium",
    "topics": [
      "Stack",
      "Design"
    ],
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: You must implement a solution with O(1) time complexity for each function. Example 1: Constraints:",
    "solution": "",
    "constraints": [
      "-231 <= val <= 231 - 1",
      "Methods pop, top and getMin operations will always be called on non-empty stacks.",
      "At most 3 * 104 calls will be made to push, pop, top, and getMin."
    ],
    "examples": [
      {
        "example_text": "Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2"
      }
    ]
  },
  {
    "problem_slug": "intersection-of-two-linked-lists",
    "difficulty": "Easy",
    "topics": [
      "Hash Table",
      "Linked List",
      "Two Pointers"
    ],
    "description": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1: The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note that the linked lists must retain their original structure after the function returns. Custom Judge: The inputs to the judge are given as follows (your program is not given these inputs): The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes of listA is in the m.",
      "The number of nodes of listB is in the n.",
      "1 <= m, n <= 3 * 104",
      "1 <= Node.val <= 105",
      "0 <= skipA <= m",
      "0 <= skipB <= n",
      "intersectVal is 0 if listA and listB do not intersect.",
      "intersectVal == listA[skipA] == listB[skipB] if listA and listB intersect."
    ],
    "examples": [
      {
        "example_text": "Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 Output: Intersected at '8' Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. - Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory."
      },
      {
        "example_text": "Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 Output: Intersected at '2' Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B."
      },
      {
        "example_text": "Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 Output: No intersection Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values. Explanation: The two lists do not intersect, so return null."
      }
    ]
  },
  {
    "problem_slug": "find-peak-element",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Binary Search"
    ],
    "description": "A peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. You must write an algorithm that runs in O(log n) time. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 1000",
      "-231 <= nums[i] <= 231 - 1",
      "nums[i] != nums[i + 1] for all valid i."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2."
      },
      {
        "example_text": "Input: nums = [1,2,1,3,5,6,4] Output: 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6."
      }
    ]
  },
  {
    "problem_slug": "maximum-gap",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Sorting",
      "Bucket Sort",
      "Radix Sort"
    ],
    "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0. You must write an algorithm that runs in linear time and uses linear extra space. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 105",
      "0 <= nums[i] <= 109"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [3,6,9,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3."
      },
      {
        "example_text": "Input: nums = [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0."
      }
    ]
  },
  {
    "problem_slug": "compare-version-numbers",
    "difficulty": "Medium",
    "topics": [
      "Two Pointers",
      "String"
    ],
    "description": "Given two version strings, version1 and version2, compare them. A version string consists of revisions separated by dots '.'. The value of the revision is its integer conversion ignoring leading zeros. To compare version strings, compare their revision values in left-to-right order. If one of the version strings has fewer revisions, treat the missing revision values as 0. Return the following: Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= version1.length, version2.length <= 500",
      "version1 and version2 only contain digits and '.'.",
      "version1 and version2 are valid version numbers.",
      "All the given revisions in version1 and version2 can be stored in a 32-bit integer."
    ],
    "examples": [
      {
        "example_text": "Input: version1 = \"1.2\", version2 = \"1.10\" Output: -1 Explanation: version1's second revision is \"2\" and version2's second revision is \"10\": 2 < 10, so version1 < version2."
      },
      {
        "example_text": "Input: version1 = \"1.01\", version2 = \"1.001\" Output: 0 Explanation: Ignoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\"."
      },
      {
        "example_text": "Input: version1 = \"1.0\", version2 = \"1.0.0.0\" Output: 0 Explanation: version1 has less revisions, which means every missing revision are treated as \"0\"."
      }
    ]
  },
  {
    "problem_slug": "fraction-to-recurring-decimal",
    "difficulty": "Medium",
    "topics": [
      "Hash Table",
      "Math",
      "String"
    ],
    "description": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. If multiple answers are possible, return any of them. It is guaranteed that the length of the answer string is less than 104 for all the given inputs. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "-231 <= numerator, denominator <= 231 - 1",
      "denominator != 0"
    ],
    "examples": [
      {
        "example_text": "Input: numerator = 1, denominator = 2 Output: \"0.5\""
      },
      {
        "example_text": "Input: numerator = 2, denominator = 1 Output: \"2\""
      },
      {
        "example_text": "Input: numerator = 4, denominator = 333 Output: \"0.(012)\""
      }
    ]
  },
  {
    "problem_slug": "two-sum-ii-input-array-is-sorted",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Two Pointers",
      "Binary Search"
    ],
    "description": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "2 <= numbers.length <= 3 * 104",
      "-1000 <= numbers[i] <= 1000",
      "numbers is sorted in non-decreasing order.",
      "-1000 <= target <= 1000",
      "The tests are generated such that there is exactly one solution."
    ],
    "examples": [
      {
        "example_text": "Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2]."
      },
      {
        "example_text": "Input: numbers = [2,3,4], target = 6 Output: [1,3] Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3]."
      },
      {
        "example_text": "Input: numbers = [-1,0], target = -1 Output: [1,2] Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2]."
      }
    ]
  },
  {
    "problem_slug": "excel-sheet-column-title",
    "difficulty": "Easy",
    "topics": [
      "Math",
      "String"
    ],
    "description": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet. For example: Example 1: Example 2: Example 3: Constraints:",
    "solution": "Solution Approach: Convert Intuition In Excel, the columns are letters that correspond to numbers. We start with `A = 1`. Similarly, `2` corresponds to `B` until `26` for `Z`. Once we run out of letters, we start appending them. `27` will correspond to `AA`, `28` for `AB`, and so on. In this problem, we are given the integer which is the column number and we need to return the corresponding letters for it. At first glance, it might be tempting to say that these numbers are just base 26, but the catch is that in a base 26 system, the numbers would start from `0`. The mapping would be like below: ![fig](../Figures/168/168A_resize.png) However, in the problem, we have the number starting from `1`, not `0`. But we can change them to process them like base 26 numbers. The important point to observe here is that every column title has the corresponding column number as a number in base 26 plus one. For example, let's convert the number `2002` to the letters `BXZ` by representing it as a number in base 26. Note that each part will have an extra `1` added to compensate for the fact that we are starting from `1` in our system. See the below example for a better understanding of the algorithm: `N = 2002` corresponds to `BXZ`. In terms of base 26: $N = (B + 1) \\cdot 26^2 + (X + 1) \\cdot 26^1 + (Z + 1) * 26^0$ $N = (1 + 1) \\cdot 676 + (23 + 1) \\cdot 26 + (25 + 1) \\cdot 1 = 2002$ Steps to get the letters: 1. Subtract `1` from `N`. Now, `N = 2001`. Take N modulo 26 and convert the result to the corresponding position in the alphabet. `2001 % 26 = 25`, which corresponds to `Z`, since we start with `A = 0`. 2. Divide `N` by 26. We have $N = \\frac{2001}{26} = 76$. 3. Repeat the process until `N = 0`. We subtract `1`, so now `N = 75`. Take it modulo 26: `75 % 26 = 23`. This corresponds to `X`. 4. Divide `N` by 26. We have $N = \\frac{75}{26} = 2$. 5. Subtract `1`, so now `N = 1`. Take it modulo 26: `1 % 26 = 1`. This corresponds to `B`. Finally, we are done, because $\\frac{N}{26} = 0$. The result is `BXZ`, the reverse order in which we found the letters. Algorithm 1. Initialize an empty string `ans` which would store the column title. 2. Do the following as long as `columnNumber` is greater than `0`: 1. Subtract `1` from the `columnNumber` 2. Find the character corresponding to `columnNumber % 26` and append it to the `ans` in the end. 3. Assign `columnNumber` to `columnNumber / 26`. 3. Reverse the string `columnNumber` and return it. Implementation Complexity Analysis Here, $N$ is the column number given in the problem. * Time complexity: $O(\\log N)$ The number of operations would be equal to the number of while loop iterations. In each iteration, the number $N$ gets divided by $26$. Hence the time complexity would be $O(\\log{_{26}}{N})$. Note that the base of the logarithm is not relevant when it comes to big O, since all logarithms are related by a constant factor. * Space complexity: $O(1)$ We only need one string to store the output, but generally the space to store the output is not considered as part of space complexity and hence the space complexity is constant.",
    "constraints": [
      "1 <= columnNumber <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ..."
      },
      {
        "example_text": "Input: columnNumber = 1 Output: \"A\""
      },
      {
        "example_text": "Input: columnNumber = 28 Output: \"AB\""
      },
      {
        "example_text": "Input: columnNumber = 701 Output: \"ZY\""
      }
    ]
  },
  {
    "problem_slug": "majority-element",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Sorting",
      "Counting"
    ],
    "description": "Given an array nums of size n, return the majority element. The majority element is the element that appears more than n / 2 times. You may assume that the majority element always exists in the array. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 5 * 104",
      "-109 <= nums[i] <= 109"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [3,2,3] Output: 3"
      },
      {
        "example_text": "Input: nums = [2,2,1,1,1,2,2] Output: 2"
      }
    ]
  },
  {
    "problem_slug": "excel-sheet-column-number",
    "difficulty": "Easy",
    "topics": [
      "Math",
      "String"
    ],
    "description": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number. For example: Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= columnTitle.length <= 7",
      "columnTitle consists only of uppercase English letters.",
      "columnTitle is in the range [\"A\", \"FXSHRXW\"]."
    ],
    "examples": [
      {
        "example_text": "A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ..."
      },
      {
        "example_text": "Input: columnTitle = \"A\" Output: 1"
      },
      {
        "example_text": "Input: columnTitle = \"AB\" Output: 28"
      },
      {
        "example_text": "Input: columnTitle = \"ZY\" Output: 701"
      }
    ]
  },
  {
    "problem_slug": "factorial-trailing-zeroes",
    "difficulty": "Medium",
    "topics": [
      "Math"
    ],
    "description": "Given an integer n, return the number of trailing zeroes in n!. Note that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1. Example 1: Example 2: Example 3: Constraints: Follow up: Could you write a solution that works in logarithmic time complexity?",
    "solution": "",
    "constraints": [
      "0 <= n <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: n = 3 Output: 0 Explanation: 3! = 6, no trailing zero."
      },
      {
        "example_text": "Input: n = 5 Output: 1 Explanation: 5! = 120, one trailing zero."
      },
      {
        "example_text": "Input: n = 0 Output: 0"
      }
    ]
  },
  {
    "problem_slug": "binary-search-tree-iterator",
    "difficulty": "Medium",
    "topics": [
      "Stack",
      "Tree",
      "Design",
      "Binary Search Tree",
      "Binary Tree",
      "Iterator"
    ],
    "description": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST): Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called. Example 1: Constraints: Follow up:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 105].",
      "0 <= Node.val <= 106",
      "At most 105 calls will be made to hasNext, and next."
    ],
    "examples": [
      {
        "example_text": "Input [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] Output [null, 3, 7, true, 9, true, 15, true, 20, false] Explanation BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next(); // return 3 bSTIterator.next(); // return 7 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 9 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 15 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 20 bSTIterator.hasNext(); // return False"
      }
    ]
  },
  {
    "problem_slug": "dungeon-game",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "description": "The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers). To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Return the knight's minimum initial health so that he can rescue the princess. Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "m == dungeon.length",
      "n == dungeon[i].length",
      "1 <= m, n <= 200",
      "-1000 <= dungeon[i][j] <= 1000"
    ],
    "examples": [
      {
        "example_text": "Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]] Output: 7 Explanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN."
      },
      {
        "example_text": "Input: dungeon = [[0]] Output: 1"
      }
    ]
  },
  {
    "problem_slug": "combine-two-tables",
    "difficulty": "Easy",
    "topics": [
      "Database"
    ],
    "description": "Table: Person Table: Address Write a solution to report the first name, last name, city, and state of each person in the Person table. If the address of a personId is not present in the Address table, report null instead. Return the result table in any order. The result format is in the following example. Example 1:",
    "solution": "Solution pandas Approach 1: Using `merge` Visualization of approach 1 ![fig](../Figures/175/175-1.png) Intuition Let's breakdown the steps given the following input DataFrames: `person`:personIdlastNamefirstName1WangAllen2AliceBob`address`:addressIdpersonIdcitystate12New York CityNew York23LeetcodeCalifornia1. Merging the DataFrames ```python result = pd.merge(person, address, on='personId', how='left') ``` In this step, we are merging the `person` and `address` dataframes using a left join operation with the `pd.merge()` function. Here: - `on='personId'` specifies that we are using the 'personId' column as the key for merging the data. This column is present in both dataframes, and it holds unique identifiers for the individuals. - `how='left'` specifies that we are performing a left join, meaning all the records from the `person` dataframe (the left dataframe) will be retained, and the matching records from the `address` dataframe (the right dataframe) will be merged where the 'personId' values match. If a 'personId' from the `person` dataframe does not have a matching 'personId' in the `address` dataframe, the 'city' and 'state' columns for that record will contain Null values (representing missing data).personIdlastNamefirstNameaddressIdcitystate1WangAllenNullNullNull2AliceBob1.0New York CityNew York2. Selecting Relevant Columns ```python result = result[['firstName', 'lastName', 'city', 'state']] ``` In this step, we select only the columns that we are interested in for the final output. Since the merging operation can potentially bring in other columns from the `address` dataframe, we are explicitly selecting only the 'firstName', 'lastName', 'city', and 'state' columns to be in our final result. This helps in maintaining a clean and focused dataset which contains only the information we are interested in.firstNamelastNamecitystateAllenWangNullNullBobAliceNew York CityNew YorkIn summary, this script is taking two separate dataframes and merging them into a single dataframe where each row represents a person and contains their first name, last name, city, and state. This is done using the person's unique identifier to correctly match each person with their address. It's a common operation when you want to bring together information from different sources into a unified view. Implementation Database Approach 1: Using `outer join` Intuition Since the *PersonId* in table Address is the foreign key of table Person, we can join these two tables to get the address information of a person. Considering there might be no address information for every person, we should use `outer join` instead of the default `inner join`. Implementation > Note: For MySQL, an `outer join` is performed either using `left join` or `right join`. ```sql select FirstName, LastName, City, State from Person left join Address on Person.PersonId = Address.PersonId ; ``` > Note: Using the `where` clause to filter the records will fail if there is no address information for a person because it will not display the name information.",
    "constraints": [],
    "examples": [
      {
        "example_text": "+-++ | Column Name | Type | +-++ | personId | int | | lastName | varchar | | firstName | varchar | +-++ personId is the primary key (column with unique values) for this table. This table contains information about the ID of some persons and their first and last names."
      },
      {
        "example_text": "+-++ | Column Name | Type | +-++ | addressId | int | | personId | int | | city | varchar | | state | varchar | +-++ addressId is the primary key (column with unique values) for this table. Each row of this table contains information about the city and state of one person with ID = PersonId."
      },
      {
        "example_text": "Input: Person table: +-+-+--+ | personId | lastName | firstName | +-+-+--+ | 1 | Wang | Allen | | 2 | Alice | Bob | +-+-+--+ Address table: +--+-+++ | addressId | personId | city | state | +--+-+++ | 1 | 2 | New York City | New York | | 2 | 3 | Leetcode | California | +--+-+++ Output: +--+-++-+ | firstName | lastName | city | state | +--+-++-+ | Allen | Wang | Null | Null | | Bob | Alice | New York City | New York | +--+-++-+ Explanation: There is no address in the address table for the personId = 1 so we return null in their city and state. addressId = 1 contains information about the address of personId = 2."
      }
    ]
  },
  {
    "problem_slug": "second-highest-salary",
    "difficulty": "Medium",
    "topics": [
      "Database"
    ],
    "description": "Table: Employee Write a solution to find the second highest distinct salary from the Employee table. If there is no second highest salary, return null (return None in Pandas). The result format is in the following example. Example 1: Example 2:",
    "solution": "",
    "constraints": [],
    "examples": [
      {
        "example_text": "+-++ | Column Name | Type | +-++ | id | int | | salary | int | +-++ id is the primary key (column with unique values) for this table. Each row of this table contains information about the salary of an employee."
      },
      {
        "example_text": "Input: Employee table: +-+--+ | id | salary | +-+--+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +-+--+ Output: ++ | SecondHighestSalary | ++ | 200 | ++"
      },
      {
        "example_text": "Input: Employee table: +-+--+ | id | salary | +-+--+ | 1 | 100 | +-+--+ Output: ++ | SecondHighestSalary | ++ | null | ++"
      }
    ]
  },
  {
    "problem_slug": "nth-highest-salary",
    "difficulty": "Medium",
    "topics": [
      "Database"
    ],
    "description": "Table: Employee Write a solution to find the nth highest distinct salary from the Employee table. If there are less than n distinct salaries, return null. The result format is in the following example. Example 1: Example 2:",
    "solution": "",
    "constraints": [],
    "examples": [
      {
        "example_text": "+-++ | Column Name | Type | +-++ | id | int | | salary | int | +-++ id is the primary key (column with unique values) for this table. Each row of this table contains information about the salary of an employee."
      },
      {
        "example_text": "Input: Employee table: +-+--+ | id | salary | +-+--+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +-+--+ n = 2 Output: ++ | getNthHighestSalary(2) | ++ | 200 | ++"
      },
      {
        "example_text": "Input: Employee table: +-+--+ | id | salary | +-+--+ | 1 | 100 | +-+--+ n = 2 Output: ++ | getNthHighestSalary(2) | ++ | null | ++"
      }
    ]
  },
  {
    "problem_slug": "rank-scores",
    "difficulty": "Medium",
    "topics": [
      "Database"
    ],
    "description": "Table: Scores Write a solution to find the rank of the scores. The ranking should be calculated according to the following rules: Return the result table ordered by score in descending order. The result format is in the following example. Example 1:",
    "solution": "",
    "constraints": [],
    "examples": [
      {
        "example_text": "+-++ | Column Name | Type | +-++ | id | int | | score | decimal | +-++ id is the primary key (column with unique values) for this table. Each row of this table contains the score of a game. Score is a floating point value with two decimal places."
      },
      {
        "example_text": "Input: Scores table: +-+-+ | id | score | +-+-+ | 1 | 3.50 | | 2 | 3.65 | | 3 | 4.00 | | 4 | 3.85 | | 5 | 4.00 | | 6 | 3.65 | +-+-+ Output: +-++ | score | rank | +-++ | 4.00 | 1 | | 4.00 | 1 | | 3.85 | 2 | | 3.65 | 3 | | 3.65 | 3 | | 3.50 | 4 | +-++"
      }
    ]
  },
  {
    "problem_slug": "largest-number",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "String",
      "Greedy",
      "Sorting"
    ],
    "description": "Given a list of non-negative integers nums, arrange them such that they form the largest number and return it. Since the result may be very large, so you need to return a string instead of an integer. Example 1: Example 2: Constraints:",
    "solution": "Solution Overview We need to arrange a list of non-negative integers such that their concatenation results in the largest possible number. Return this largest number as a string. To solve this, we use a custom comparatora function or object that defines how two elements are compared for sorting. Its used when the default comparison operations (like `<` or `>`) do not fit the requirements of a particular task. In this case, we want to compare numbers based on the result of their concatenation in two different orders. First, we convert each integer to a string. Then, we sort the array of strings. Sorting the numbers in descending order might seem like a good idea, but it leads to issues when numbers share the same leading digit. For example, sorting `[9, 5, 34, 3, 30]` in descending order gives `\"9534303\"`, but the correct answer is `\"9534330\"`. The problem arises because `\"3\"` and `\"30\"` share the same leading digit. To fix this, we compare the concatenated results of pairs of numbers. For example, given two numbers `a` and `b`, we compare `a + b` and `b + a` (where `+` denotes string concatenation). If `a + b` is larger, we place `a` before `b`. This ensures that the numbers are ordered correctly for the largest possible result. The key is that this comparison ensures that the greedy approach of comparing pairs of numbers leads to the correct result. The difficult part is proving that this greedy logic always gives the correct answer. Proof of Correctness Objective: To ensure that our custom comparator for sorting numbers produces the largest possible concatenated number. 1. Transitivity of the Comparator: To verify the validity of the comparator, we need to prove that it is transitive. In other words, if number `A` should come before `B`, and `B` should come before `C`, then `A` must come before `C` in the final order. We define the function: \\begin{aligned} f(X) &= 10^{\\text{lg}(X) + 1} \\end{aligned} where $\\text{lg}(X)$ denotes the logarithm base 10 of $X$. This function helps in determining the power of 10 needed to position `X` correctly when concatenating. 2. Comparator Verification: If concatenating `A` and `B` as `AB` is less than or equal to `BA`, we need to verify that: \\begin{aligned} f(B)A + B &\\leq f(A)B + A \\\\ (f(B) - 1)A &\\leq (f(A) - 1)B \\\\ A &\\leq \\frac{B \\cdot (f(A) - 1)}{f(B) - 1} \\end{aligned} Similarly, if `B` and `C` satisfy: \\begin{aligned} BC &\\leq CB \\\\ (f(C) - 1)B &\\leq (f(B) - 1)C \\\\ B &\\leq \\frac{C \\cdot (f(B) - 1)}{f(C) - 1} \\end{aligned} 3. By Combining These Inequalities: \\begin{aligned} A &\\leq \\frac{C \\cdot (f(A) - 1)}{f(C) - 1} \\\\ (f(C) - 1)A &\\leq (f(A) - 1)C \\\\ f(C)A + C &\\leq f(A)C + A \\\\ AC &\\leq CA \\end{aligned} This demonstrates that if `A` is before `B` and `B` is before `C`, then `A` must come before `C`, maintaining a consistent ordering. 4. By Establishing the Consistency of the Comparator: We confirm that sorting numbers with this comparator yields the largest concatenated number. For example, sorting `[3, 30, 34, 5, 9]` yields `[9, 5, 34, 3, 30]`, which concatenates to `\"9534330\"`, the largest possible number. Approach 1: Using Built-in Function Intuition To begin with, we need to determine the best order for the numbers to form the largest possible number when concatenated. We first convert each integer in the list to a string. This conversion allows us to compare different concatenated results. For instance, if we have the numbers `56` and `9`, converting them to strings allows us to compare `\"569\"` and `\"956\"`. Next, we use a custom sorting function to order these strings. This function compares two strings, `a` and `b`, by evaluating `a + b` against `b + a`. If `a + b` is greater, then `a` should come before `b` in the sorted list to maximize the final result. Once sorted, we concatenate all the strings. If the first element in this sorted list is \"0\", it indicates that all numbers were zeros, so the largest number possible is \"0\". In this case, we return \"0\". If not, we return the concatenated result. Algorithm - Initialize `numStrings` as an array of strings to hold string representations of numbers. - Convert each integer in `nums` to a string and store it in `numStrings`. - Sort `numStrings` based on concatenated values: - Use a lambda function to compare concatenated results (`a + b` and `b + a`). - Ensure that the concatenation which forms a larger number determines the order. - Check if the largest number formed is \"0\": - If the first element in `numStrings` is \"0\", return \"0\" (handles cases where all numbers are zero). - Concatenate all strings in `numStrings` to form the largest number. - Return the concatenated result as the largest number. Implementation Complexity Analysis Let $n$ be the size of the `nums` array. - Time Complexity: $O(n \\log n)$ The most time-consuming operation is the sorting step, which uses a custom comparator. The sorting algorithm has a time complexity of $O(n \\log n)$. The conversion of numbers to strings and concatenation operations are linear with respect to the number of elements. - Space Complexity: $O(n + S)$ Additional space is used for storing the string representations of the numbers and the final concatenated result, which scales linearly with the size of the input array. Some extra space is used when we sort an array of size $n$ in place. The space complexity of the sorting algorithm ($S$) depends on the programming language. The value of $S$ depends on the programming language and the sorting algorithm being used: - In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(n)$ - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O( \\log n )$ - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log n)$ Thus, the total space complexity of the algorithm is $O(n + S)$. Approach 2: Quick Sort Intuition Quick Sort uses a divide-and-conquer method to sort the numbers. We start by selecting a pivot and partitioning the list into two parts based on how each number compares with the pivot. Specifically, we compare concatenated results like `a + pivot` with `pivot + a`. We recursively sort the two partitions and then combine them. This recursive sorting ensures that the entire list is ordered such that concatenating all numbers results in the largest possible number. After sorting, we concatenate the numbers. If the final string starts with '0', it means all numbers were zeros, so we return \"0\". Otherwise, we return the concatenated result. This approach efficiently sorts and merges numbers to achieve the desired outcome. Each of these approaches aims to sort the numbers in such a way that their concatenation produces the largest possible number. By using different sorting techniques and comparison methods, we can achieve the correct order efficiently.Lets take the list `[3, 30, 34, 5, 9]`. To apply quick sort, we first select a pivot, such as `34`. We then partition the list so that numbers that produce a larger concatenated result with the pivot come before it, and those that produce a smaller result come after it. For each number compared to `34`: - Compare `\"3\"` with `\"34\"`. Concatenate as `\"34\" + \"3\" = \"343\"` and `\"3\" + \"34\" = \"334\"`. Since `\"343\"` is greater, `\"3\"` is placed after `\"34\"`. - Compare `\"30\"` with `\"34\"`. Concatenate as `\"34\" + \"30\" = \"3430\"` and `\"30\" + \"34\" = \"3034\"`. Since `\"3430\"` is greater, `\"30\"` is placed after `\"34\"`. The same process applies to `\"5\"` and `\"9\"`. The result of the partitioning places `\"9\"`, `\"5\"`, and `\"34\"` correctly relative to each other, but in the final list, we sort based on which numbers yield larger concatenated results when placed in various orders. After applying quick sort recursively to each partition, the list gets sorted to `[9, 5, 34, 3, 30]`. Concatenating these numbers results in `\"9534330\"`, which is the largest number possible. Algorithm - Call `quickSort(nums, 0, nums.size() - 1)` to sort the numbers in descending order based on their concatenated values. - `quickSort` function: - If `left` is greater than or equal to `right`, return (base case: the array or sub-array is already sorted). - Call `partition(nums, left, right)` to partition the array around a pivot and get the pivot index. - Recursively call `quickSort` on the left sub-array (`left` to `pivotIndex - 1`). - Recursively call `quickSort` on the right sub-array (`pivotIndex + 1` to `right`). - `partition` function: - Choose the rightmost element as the pivot. - Rearrange elements so that elements that, when concatenated with the pivot, form a larger number are moved to the left. - Swap elements to place the pivot in its correct position. - Return the pivot index. - `compare` function: - Compare the concatenated strings of `firstNum` and `secondNum` to determine their order. - Concatenate the sorted numbers into a string to form the largest number. - Handle the edge case where the largest number is zero: - Return \"0\" if the first character of the concatenated string is '0'. - Otherwise, return the concatenated string. Implementation Complexity Analysis Let $n$ be the size of the `nums` array. - Time Complexity: $O(n \\log n)$ on average, $O(n^2)$ in the worst case Quick sort generally has an average time complexity of $O(n \\log n)$, though its worst-case time complexity is $O(n^2)$ if the pivot selection consistently results in unbalanced partitions. The average case is efficient due to its partitioning strategy. - Space Complexity: $O(\\log n)$ on average, $O(n)$ in the worst case The space complexity for quick sort is $O(\\log n)$ due to the depth of the recursion stack in the average case. In the worst case, it can be $O(n)$ if the recursion depth is not balanced. Approach 3: Merge Sort Intuition Merge sort involves recursively dividing the list into smaller parts until each part contains a single number. Sorting single-number parts is straightforward, so we focus on merging these parts in the correct order. During the merging process, we compare numbers by concatenating their string representations. We ensure that larger concatenated results come first in the merged list. This is done by comparing combinations like `a + b` and `b + a` and placing the larger result first. After merging all parts, we obtain a sorted list where concatenating all numbers forms the largest number. If this result starts with '0', all numbers are zero, so we return \"0\". Otherwise, we return the concatenated result. For example, with the list `[3, 30, 34, 5, 9]`, we first split it into `[3, 30]` and `[34, 5, 9]`. We recursively divide these segments further until each segment contains a single number. We then merge these single-number segments, comparing concatenated results to determine the order. For example, merging `[3]` and `[30]`, we find `\"330\"` is greater than `\"303\"`, so `\"30\"` should precede `\"3\"`. Merging all segments with similar comparisons results in the list `[9, 5, 34, 3, 30]`. Concatenating these numbers gives `\"9534330\"`, the largest possible number. Algorithm - Sort the `nums` array using a custom merge sort to arrange numbers in a way that forms the largest possible concatenated number. - `mergeSort` function: - If the range of elements to be sorted (`left` to `right`) is a single element, return it as it is already sorted. - Divide the array into two halves (`left` and `right`) by finding the middle index. - Recursively sort the left and right halves. - Merge the sorted halves using the `merge` function. - `merge` function: - Initialize two indices to iterate over the left and right halves of the array. - Compare elements from the left and right halves based on custom concatenation order (using the `compare` function). - Append the larger element to the sorted array and move the corresponding index. - After processing all elements from one half, append the remaining elements from the other half. - `compare` function: - Concatenate `firstNum` and `secondNum` in both possible orders and compare them. - Return `true` if `firstNum` should appear before `secondNum` in the final sorted order based on the concatenated result. - After sorting, concatenate the sorted numbers to form the largest number. - Return \"0\" if the largest number starts with '0' (handles cases where all numbers are zero); otherwise, return the concatenated result. Implementation Complexity Analysis Let $n$ be the size of the `nums` array. - Time Complexity: $O(n \\log n)$ Merge sort divides the array into halves and merges them in $O(n \\log n)$ time. Each merge operation is linear in the size of the array being merged, and the recursive divide-and-conquer approach ensures a logarithmic depth of recursion. - Space Complexity: $O(n)$ Merge sort requires additional space for the temporary arrays used during merging. For each recursive call, we use extra space proportional to the size of the array being merged. The depth of the recursion stack is $O(\\log n)$, and the space used per level of recursion for merging is $O(n)$. So, the total space complexity is $O(n)$. Creating the final string involves space proportional to the size of the final string, which is $O(n)$. Approach 4: HeapSort Intuition Heapsort helps us find the largest concatenated number by using a priority queue, which we often call a max heap. First, we need to turn each number into a string. This way, we can compare different concatenations of these strings. We then insert these string representations into a max heap. The max heap will arrange these strings based on our custom comparison function and The heap uses this comparison to decide which string should come first. Say we have the numbers `[3, 30, 34, 5, 9]`. We start by converting each number to a string, resulting in `[\"3\", \"30\", \"34\", \"5\", \"9\"]`. We insert these strings into the heap. The heap sorts these strings based on which concatenation yields a larger number. For instance, comparing `\"30\"` and `\"3\"` involves checking if `\"303\"` is larger than `\"330\"`. Since `\"330\"` is larger, `\"3\"` will be prioritized over `\"30\"` in the heap. After inserting all strings, the heap will arrange them in a way that ensures the largest number comes out first. Next, we remove elements from the heap one by one and build our result string. By concatenating these strings in the order they come out of the heap, we get the largest possible number. Finally, if the result starts with '0', we return \"0\" because this means all numbers were zeros.The algorithm is visualized below: !?!../Documents/179/heapsort.json:925,695!?! Algorithm - Initialize a max heap to store numbers as strings in a custom sorted order, using the `compare` function. - Initialize a variable `totalLength` to track the total length of all numbers converted to strings. - Iterate over each number `num` in `nums`: - Convert the integer `num` to a string `strNum`. - Add the length of `strNum` to `totalLength`. - Push `strNum` into the max heap using the custom comparison function to maintain the order. - Initialize an empty string `result` and reserve space based on `totalLength` for efficiency. - While the max heap is not empty: - Append the top element (largest string based on custom comparison) from the max heap to `result`. - Pop the top element from the max heap. - Check if the resulting string is empty or starts with `'0'`: - If true, return `\"0\"` to handle the edge case where the result might be a string of zeros. - Otherwise, return the final `result` string, which represents the largest possible number. - `compare` function: - Given two strings `first` and `second`, compare them by concatenating them in two different orders (`first + second` and `second + first`). - Return `true` if `(first + second)` is less than `(second + first)`, ensuring the correct order for the largest number construction.\\ Implementation Complexity Analysis Let $n$ be the size of the `nums` array. - Time Complexity: $O(n \\log n)$ Converting each integer to a string takes $O(\\log k)$ time per integer, where $k$ is the integer value. If there are $n$ integers, the total time for conversion is $O(n \\log k)$. Inserting each string into the priority queue takes $O(\\log n)$ time per insertion. Since there are $n$ strings, this step contributes $O(n \\log n)$. Extracting elements from the priority queue and concatenating them into the result string takes $O(n \\log n)$ time due to the heap operations and string concatenations. Combining these steps, the overall time complexity is dominated by the heap operations, so: Converting integers to strings takes $O(n \\log k)$ time, and inserting each string into the priority queue takes $O(n \\log n)$. Building the result string takes $O(n \\log n)$. Thus, the overall time complexity is $O(n \\log n)$. - Space Complexity: $O(n)$ The priority queue stores $n$ strings, each of which can be up to $O(\\log k)$ in length. Hence, the space required for the priority queue is $O(n \\log k)$. The result string stores all $n$ integers, so its space complexity is $O(n \\log k)$. Since these are the main contributors to space complexity, the overall space complexity is $O(n \\log k) = O(n)$. Approach 5: TimSort Intuition TimSort is a sorting algorithm that combines insertion sort and merge sort. We start by dividing the list into small segments called runs. Each run is a segment of the list that is sorted independently using insertion sort. Insertion sort is well-suited for this task because it efficiently handles small or already partially sorted segments. For instance, in our example list `[3, 30, 34, 5, 9]`, TimSort first breaks it into runs. Since the list is small, it might treat the entire list as a single run or split it into smaller manageable runs like `[3, 30]` and `[34, 5, 9]` [Usually runs are not this small but for the sake of this example lets say its 2]. > Minrun is chosen from the range 32 to 64 inclusive, such that the size of the data, divided by minrun, is equal to, or slightly less than, a power of two. Next, we merge these sorted runs into larger, sorted segments. During the merging phase, we use a custom comparison function to determine the order of numbers based on which concatenated result is larger. After all runs are merged, we get a fully sorted list arranged to form the largest possible number. Finally, we check if the result starts with '0'. If it does, this indicates that all numbers are zeros, so we return \"0\". Consider the list `[3, 30, 34, 5, 9]`. TimSort starts by sorting small runs like `[3, 30]` and `[34, 5, 9]` using insertion sort. It then merges these runs, comparing concatenated results to determine the correct order. For instance, it would compare `\"330\"` with `\"303\"` and place `\"3\"` before `\"30\"` because `\"330\"` is larger. The final merge step sorts the list to `[9, 5, 34, 3, 30]`. Concatenating these gives us the largest number, `\"9534330\"`. Timsort aims to optimize the merging process by ensuring that the number of runs is close to a power of two. Merging is most effective when the number of runs is equal to or just under a power of two, while it becomes less efficient when the number of runs exceeds a power of two. To achieve this, Timsort selects the value of `RUN` so that the total number of runs is close to a power of two. `RUN` is chosen within the range of 32 to 64. It is set so that the total size of the data divided by `RUN` is either equal to or slightly less than a power of two. The method for determining `RUN` involves taking the six most significant bits of the array size, adding one if any of the remaining bits are set, and using this result for `RUN`. This approach accommodates all array sizes, including those smaller than 64. For arrays with 63 or fewer elements, `RUN` is set equal to the array size, effectively reducing Timsort to insertion sort for those smaller arrays. > Fun fact: Timsort is highly regarded for its efficiency and stability. It is more advanced compared to older algorithms like bubble sort or insertion sort. Invented by Tim Peters in 2002, it was named after him. Timsort is used in Python sort. Algorithm - Sort the `nums` array using the custom `timSort` algorithm. - `timSort` function: - For each small run of size `RUN` (32 elements), call `insertionSort` to sort the subarrays. - After sorting small runs, iteratively merge them using the `merge` function until the entire array is sorted. - `insertionSort` function: - Iterate through the subarray from `left + 1` to `right`. - For each element, store it in a temporary variable `temp`. - Compare `temp` with its previous elements (from right to left) using the `compare` function: - If the comparison returns `true` (i.e., `temp` should precede the compared element), shift the previous element to the right. - Insert `temp` in its correct position once all comparisons are done. - `merge` function: - Split the array into two subarrays: `leftArr` (from `left` to `mid`) and `rightArr` (from `mid + 1` to `right`). - Merge the two subarrays back into the original array: - Compare the elements from both subarrays using the `compare` function. - Insert the smaller element into the original array and proceed until both subarrays are fully merged. - `compare` function: - Convert the two numbers `firstNum` and `secondNum` into strings. - Concatenate them in both possible orders and return `true` if the first concatenation results in a larger number. - Once `nums` is sorted, concatenate all elements in `nums` to form the `largestNum` string. - If the first character of `largestNum` is `'0'`, return `\"0\"` to handle the case where all numbers are zero. - Otherwise, return `largestNum` as the final result. Implementation Complexity Analysis Let $n$ be the size of the `nums` array. - Time complexity: $O(n \\log n)$ The main time-consuming operation here is the sorting step using TimSort. Its time complexity is $O(n \\log n)$ in the average and worst cases. Specifically: - The insertion sort runs in $O(n^2)$ time on small segments (runs), but since it operates on a limited size of $RUN$, the total cost for insertion sorting all runs is $O(n)$ in practice. - The merge step involves merging pairs of runs and is performed $\\log n$ times, leading to the overall time complexity of $O(n \\log n)$ for TimSort. Concatenating the numbers to form the final string has a linear time complexity $O(n)$, but it doesn't affect the overall complexity since $O(n \\log n)$ dominates. - Space complexity: $O(n)$ The space complexity is dominated by the space used for temporary storage during merging: - The `leftArr` and `rightArr` vectors in the merge function require $O(n)$ space in total. - The extra space used for the `largestNum` string is $O(n)$. Other auxiliary space used in the algorithm, such as variables and function call stacks, is minimal compared to the space required for arrays. Thus, the overall space complexity is $O(n)$. Further Thoughts: You might be wondering why merging is most effective when the number of runs is equal to or just below a power of two, and why it becomes less efficient when the number of runs exceeds this number. The main reason for this is that merging is most balanced when the number of runs is a power of two. In general, if the data is randomly ordered, each run will typically be about the size of `minrun`. When the number of runs matches a power of two, merging operations can proceed in a perfectly balanced manner throughout the process. This balance minimizes the number of comparisons and data movements needed. If the number of runs is slightly more than a power of two, the merging process becomes less balanced. This imbalance results in inefficient merges, as you end up with uneven merge sizes, leading to increased comparisons and data movement. Conversely, if the number of runs is slightly fewer than a power of two, the merges remain relatively balanced, although not perfectly. This slight imbalance causes only a minor increase in inefficiency compared to the ideal scenario. For example, if you have nine natural runs with lengths of 800, 100, 100, 100, 100, 100, 100, 100, and 100 elements, the merges will still be well-balanced, even though the number of runs is slightly above a power of two. Tim Peters talks about this in his [listsort.txt](https://github.com/python/cpython/blob/main/Objects/listsort.txt) file. He points out that using a `minrun` of 32 isn't always the best choice. For example, if you have 2,112 elements, splitting them into runs of 32 means it will take 7 steps to merge everything. The first 6 runs merge smoothly, but after reaching 2,048 elements, the final merge becomes less efficient. This leads to more comparisons and extra data movement. Now, if the run size is 33, it will take 6 steps to merge everything: 33, 66(33 * 2), 132(66 * 2), 264(132 * 2), 528(264 * 2), 1,056(528 * 2) and then 2,112(1,056 * 2). But with a run size of 32, you'll need 7 steps: 32, 64, 128, 256, 512, 1,024, 2,048, and then 2,112.You can view the full implementation of TimSort, including all the detailed aspects, in the file located at [https://svn.python.org/projects/python/trunk/Objects/listobject.c](https://svn.python.org/projects/python/trunk/Objects/listobject.c). This implementation was crafted by Tim Peters.Heres a snippet taken from `listobject.c` showing how to determine the minimum run size for a subarray in the Timsort algorithm based on the size of the initial array `n`. ```c /* Compute a good value for the minimum run length; natural runs shorter * than this are boosted artificially via binary insertion. * * If n < 64, return n (it's too small to bother with fancy stuff). * Else if n is an exact power of 2, return 32. * Else return an int k, 32 <= k <= 64, such that n/k is close to, but * strictly less than, an exact power of 2. * * See listsort.txt for more info. */ static Py_ssize_t merge_compute_minrun(Py_ssize_t n) { Py_ssize_t r = 0; /* becomes 1 if any 1 bits are shifted off */ assert(n >= 0); while (n >= 64) { r |= n & 1; n >>= 1; } return n + r; } ```",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 109"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [10,2] Output: \"210\""
      },
      {
        "example_text": "Input: nums = [3,30,34,5,9] Output: \"9534330\""
      }
    ]
  },
  {
    "problem_slug": "consecutive-numbers",
    "difficulty": "Medium",
    "topics": [
      "Database"
    ],
    "description": "Table: Logs Find all numbers that appear at least three times consecutively. Return the result table in any order. The result format is in the following example. Example 1:",
    "solution": "Solution Approach: Using `DISTINCT` and `WHERE` clause [Accepted] Algorithm Consecutive appearing means the Id of the Num are next to each others. Since this problem asks for numbers appearing at least three times consecutively, we can use 3 aliases for this table Logs, and then check whether 3 consecutive numbers are all the same. ```sql SELECT * FROM Logs l1, Logs l2, Logs l3 WHERE l1.Id = l2.Id - 1 AND l2.Id = l3.Id - 1 AND l1.Num = l2.Num AND l2.Num = l3.Num ; ``` | Id | Num | Id | Num | Id | Num | |-|--|-|--|-|--| | 1 | 1 | 2 | 1 | 3 | 1 | >Note: The first two columns are from l1, then the next two are from l2, and the last two are from l3. Then we can select any *Num* column from the above table to get the target data. However, we need to add a keyword `DISTINCT` because it will display a duplicated number if one number appears more than 3 times consecutively. MySQL ```sql SELECT DISTINCT l1.Num AS ConsecutiveNums FROM Logs l1, Logs l2, Logs l3 WHERE l1.Id = l2.Id - 1 AND l2.Id = l3.Id - 1 AND l1.Num = l2.Num AND l2.Num = l3.Num ; ```",
    "constraints": [],
    "examples": [
      {
        "example_text": "+-++ | Column Name | Type | +-++ | id | int | | num | varchar | +-++ In SQL, id is the primary key for this table. id is an autoincrement column starting from 1."
      },
      {
        "example_text": "Input: Logs table: +-+--+ | id | num | +-+--+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +-+--+ Output: +--+ | ConsecutiveNums | +--+ | 1 | +--+ Explanation: 1 is the only number that appears consecutively for at least three times."
      }
    ]
  },
  {
    "problem_slug": "employees-earning-more-than-their-managers",
    "difficulty": "Easy",
    "topics": [
      "Database"
    ],
    "description": "Table: Employee Write a solution to find the employees who earn more than their managers. Return the result table in any order. The result format is in the following example. Example 1:",
    "solution": "",
    "constraints": [],
    "examples": [
      {
        "example_text": "+-++ | Column Name | Type | +-++ | id | int | | name | varchar | | salary | int | | managerId | int | +-++ id is the primary key (column with unique values) for this table. Each row of this table indicates the ID of an employee, their name, salary, and the ID of their manager."
      },
      {
        "example_text": "Input: Employee table: +-+-+--+--+ | id | name | salary | managerId | +-+-+--+--+ | 1 | Joe | 70000 | 3 | | 2 | Henry | 80000 | 4 | | 3 | Sam | 60000 | Null | | 4 | Max | 90000 | Null | +-+-+--+--+ Output: +-+ | Employee | +-+ | Joe | +-+ Explanation: Joe is the only employee who earns more than his manager."
      }
    ]
  },
  {
    "problem_slug": "duplicate-emails",
    "difficulty": "Easy",
    "topics": [
      "Database"
    ],
    "description": "Table: Person Write a solution to report all the duplicate emails. Note that it's guaranteed that the email field is not NULL. Return the result table in any order. The result format is in the following example. Example 1:",
    "solution": "",
    "constraints": [],
    "examples": [
      {
        "example_text": "+-++ | Column Name | Type | +-++ | id | int | | email | varchar | +-++ id is the primary key (column with unique values) for this table. Each row of this table contains an email. The emails will not contain uppercase letters."
      },
      {
        "example_text": "Input: Person table: +-++ | id | email | +-++ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +-++ Output: ++ | Email | ++ | a@b.com | ++ Explanation: a@b.com is repeated two times."
      }
    ]
  },
  {
    "problem_slug": "customers-who-never-order",
    "difficulty": "Easy",
    "topics": [
      "Database"
    ],
    "description": "Table: Customers Table: Orders Write a solution to find all customers who never order anything. Return the result table in any order. The result format is in the following example. Example 1:",
    "solution": "",
    "constraints": [],
    "examples": [
      {
        "example_text": "+-++ | Column Name | Type | +-++ | id | int | | name | varchar | +-++ id is the primary key (column with unique values) for this table. Each row of this table indicates the ID and name of a customer."
      },
      {
        "example_text": "+-++ | Column Name | Type | +-++ | id | int | | customerId | int | +-++ id is the primary key (column with unique values) for this table. customerId is a foreign key (reference columns) of the ID from the Customers table. Each row of this table indicates the ID of an order and the ID of the customer who ordered it."
      },
      {
        "example_text": "Input: Customers table: +-+-+ | id | name | +-+-+ | 1 | Joe | | 2 | Henry | | 3 | Sam | | 4 | Max | +-+-+ Orders table: +-++ | id | customerId | +-++ | 1 | 3 | | 2 | 1 | +-++ Output: +--+ | Customers | +--+ | Henry | | Max | +--+"
      }
    ]
  },
  {
    "problem_slug": "department-highest-salary",
    "difficulty": "Medium",
    "topics": [
      "Database"
    ],
    "description": "Table: Employee Table: Department Write a solution to find employees who have the highest salary in each of the departments. Return the result table in any order. The result format is in the following example. Example 1:",
    "solution": "",
    "constraints": [],
    "examples": [
      {
        "example_text": "+--++ | Column Name | Type | +--++ | id | int | | name | varchar | | salary | int | | departmentId | int | +--++ id is the primary key (column with unique values) for this table. departmentId is a foreign key (reference columns) of the ID from the Department table. Each row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department."
      },
      {
        "example_text": "+-++ | Column Name | Type | +-++ | id | int | | name | varchar | +-++ id is the primary key (column with unique values) for this table. It is guaranteed that department name is not NULL. Each row of this table indicates the ID of a department and its name."
      },
      {
        "example_text": "Input: Employee table: +-+-+--+--+ | id | name | salary | departmentId | +-+-+--+--+ | 1 | Joe | 70000 | 1 | | 2 | Jim | 90000 | 1 | | 3 | Henry | 80000 | 2 | | 4 | Sam | 60000 | 2 | | 5 | Max | 90000 | 1 | +-+-+--+--+ Department table: +-+-+ | id | name | +-+-+ | 1 | IT | | 2 | Sales | +-+-+ Output: ++-+--+ | Department | Employee | Salary | ++-+--+ | IT | Jim | 90000 | | Sales | Henry | 80000 | | IT | Max | 90000 | ++-+--+ Explanation: Max and Jim both have the highest salary in the IT department and Henry has the highest salary in the Sales department."
      }
    ]
  },
  {
    "problem_slug": "department-top-three-salaries",
    "difficulty": "Hard",
    "topics": [
      "Database"
    ],
    "description": "Table: Employee Table: Department A company's executives are interested in seeing who earns the most money in each of the company's departments. A high earner in a department is an employee who has a salary in the top three unique salaries for that department. Write a solution to find the employees who are high earners in each of the departments. Return the result table in any order. The result format is in the following example. Example 1: Constraints:",
    "solution": "  Solution   pandas Approach 1: Return the First n Rows Using nlargest() AlgorithmFor this problem, we can either identify the top earners first using DataFrame `employee` and then join the DataFrame `department` to get the department name, or join the DataFrame `department` first to get the department name before identifying the top earners. In this approach, we use the latter logic. In this step, we can also update the column name in the DataFrame `department` from `name` to `Department` as requested by the final output. ```python Employee_Department = employee.merge(department, left_on='departmentId', right_on='id').rename(columns = {'name_y': 'Department'}) ``` Now we have the employee and department information stored in the same DataFrame: | id_x | name_x | salary | departmentId | id_y | Department | | - | | | | - | - | | 1 | Joe | 85000 | 1 | 1 | IT | | 4 | Max | 90000 | 1 | 1 | IT | | 5 | Janet | 69000 | 1 | 1 | IT | | 6 | Randy | 85000 | 1 | 1 | IT | | 7 | Will | 70000 | 1 | 1 | IT | | 2 | Henry | 80000 | 2 | 2 | Sales | | 3 | Sam | 60000 | 2 | 2 | Sales | Since the definition of a high earner is an employee who has a salary in the top three unique salaries for the department, we want to make sure the salary is unique at the department level for later calculation. To do this, we select only the department and salary from the DataFrame created in the last step and drop any duplicated records if existed. ```python Employee_Department = Employee_Department[['Department', 'departmentId', 'salary']].drop_duplicates() ``` Here's the output after this step: | Department | departmentId | salary | | - | | | | IT | 1 | 85000 | | IT | 1 | 90000 | | IT | 1 | 69000 | | IT | 1 | 70000 | | Sales | 2 | 80000 | | Sales | 2 | 60000 | Now we can identify the top 3 unique salaries for each department. We use the function [`nlargest()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.nlargest.html) to get this value. The parameter '3' is passed to the function as it defines the number of rows to return. ```python top_salary = Employee_Department.groupby(['Department', 'departmentId']).salary.nlargest(3).reset_index() ``` | Department | departmentId | level_2 | salary | | - | | - | | | IT | 1 | 1 | 90000 | | IT | 1 | 0 | 85000 | | IT | 1 | 4 | 70000 | | Sales | 2 | 5 | 80000 | | Sales | 2 | 6 | 60000 | Now we only need to identify the employees are in these departments and making the same amount of salary. To do this, we can merge the DataFrame `top_salary`, which contains the top three unique salary for each department, to the DataFrame `employee` on `departmentId` and `salary`, so only the employees that match both criteria will be retained. ```python df = top_salary.merge(employee, on=['departmentId', 'salary']) ``` | Department | departmentId | level_2 | salary | id | name | | - | | - | | -- | -- | | IT | 1 | 1 | 90000 | 4 | Max | | IT | 1 | 0 | 85000 | 1 | Joe | | IT | 1 | 0 | 85000 | 6 | Randy | | IT | 1 | 4 | 70000 | 7 | Will | | Sales | 2 | 5 | 80000 | 2 | Henry | | Sales | 2 | 6 | 60000 | 3 | Sam | Lastly, we clean the DataFrame as per requested by the final output. We keep only the columns needed and rename the columns accordingly. ```python df[['Department', 'name', 'salary']].rename(columns = {'name': 'Employee', 'salary': 'Salary'}) ``` Implementation  Approach 2: Return the First n Rows Using rank() AlgorithmFor this approach, we first identify the top earners from the DataFrame `employee` and then join the DataFrame `department` to get the department name. To identify the high earners for each department, we use the function [`rank()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rank.html) to apply dense rank on the column `salary` so we can get the top three unique salaries. The parameter `ascending=False` is passed so the salary is sorted from the maximum to the minimum. Within the same step, we can also add the filter to keep only the records with a rank smaller than or equal to 3. ```python top_salary = employee[employee.groupby('departmentId').salary.rank(method='dense', ascending=False) <= 3] ``` Only employees who are `high earners` retained in the new DataFrame: | id | name | salary | departmentId | | -- | -- | | | | 1 | Joe | 85000 | 1 | | 2 | Henry | 80000 | 2 | | 3 | Sam | 60000 | 2 | | 4 | Max | 90000 | 1 | | 6 | Randy | 85000 | 1 | | 7 | Will | 70000 | 1 | Now we want to `merge` to the DataFrame `department` to get the `name` of the department. In the same step, we can also select only the columns needed for the final output. ```python employee_department = top_salary.merge(department, left_on='departmentId', right_on='id')[['name_y', 'name_x', 'salary']] ``` | name_y | name_x | salary | | | | | | IT | Joe | 85000 | | IT | Max | 90000 | | IT | Randy | 85000 | | IT | Will | 70000 | | Sales | Henry | 80000 | | Sales | Sam | 60000 | We are almost there! To get the final output, we need to update the column name as per requested. ```python return employee_department.rename(columns = {'name_y': 'Department', 'name_x': 'Employee', 'salary': 'Salary'}) ``` Implementation Database Approach 1: Return the First n Rows Using Correlated Subquery Algorithm We can build a [correlated subquery](https://dev.mysql.com/doc/refman/8.0/en/correlated-subqueries.html) to identify the top N records from more than one category. Since the correlated subquery is dependent on the main query, the idea behind this approach is to compare the values between the main query and the subquery, so that in the subquery, at most N-1 salaries can be greater than each selected salary from the main query. To do this, we first build the main query. In the main query, we can also join the table `Employee` to the table `Department` on `departmentId` to get the `name` of the departments and rename the columns as requested by the final output. ```sql SELECT d.name AS 'Department', e1.name AS 'Employee', e1.salary AS 'Salary' FROM Employee e1 JOIN Department d ON e1.departmentId = d.id ``` In the correlated subquery, we select the number of salaries from the same table `Employee`. To compare the salaries between the main query and the subquery, we make sure the department is the same from both queries, but the salary from the subquery is always bigger than the salary from the main query. ```sql ( SELECT COUNT(DISTINCT e2.salary) FROM Employee e2 WHERE e2.salary > e1.salary AND e1.departmentId = e2.departmentId ) ``` Since we need to identify the top three high earners in the main query, and the subquery always has larger salaries than the salaries from the main query, the maximum count of the larger salaries in the subquery is two. We add this criteria as a filter to the main query. Implementation ```sql SELECT d.name AS 'Department', e1.name AS 'Employee', e1.salary AS 'Salary' FROM Employee e1 JOIN Department d ON e1.departmentId = d.id WHERE 3 > (SELECT COUNT(DISTINCT e2.salary) FROM Employee e2 WHERE e2.salary > e1.salary AND e1.departmentId = e2.departmentId); ```  Approach 2: Return the First n Rows Using DENSE_RANK() Algorithm Unlike the previous approach that utilized a correlated subquery, in this approach, we sorted the salaries in descending order, ranked employees based on their salaries within the department, and selected only the first 3 employees for the final output. We first create a subquery or CTE to rank the employees. Since the definition of a high earner is the employee who has a salary in the top three unique salaries for the department, we can use the function `DENSE_RANK()` to avoid the scenario that employees from the same department make the same amount of salary. In this step, we can also join the table `Department` on `departmentId` to get the `name` of the departments and rename the columns for the final output. ```sql WITH employee_department AS ( SELECT d.id, d.name AS Department, salary AS Salary, e.name AS Employee, DENSE_RANK()OVER(PARTITION BY d.id ORDER BY salary DESC) AS rnk FROM Department d JOIN Employee e ON d.id = e.departmentId ) ``` Now, each employee has a rank based on the `salary` in a descending order for each department. | id | Department | Salary | Employee | rnk | | -- | - | | -- | | | 1 | IT | 90000 | Max | 1 | | 1 | IT | 85000 | Joe | 2 | | 1 | IT | 85000 | Randy | 2 | | 1 | IT | 70000 | Will | 3 | | 1 | IT | 69000 | Janet | 4 | | 2 | Sales | 80000 | Henry | 1 | | 2 | Sales | 60000 | Sam | 2 | With the rank, we can select the high earners. We can add the filter to select employees that have a rank smaller than or equal to 3 in the main query. ```sql SELECT Department, Employee, Salary FROM employee_department WHERE rnk <= 3 ``` Implementation ```mysql [] WITH employee_department AS ( SELECT d.id, d.name AS Department, salary AS Salary, e.name AS Employee, DENSE_RANK()OVER(PARTITION BY d.id ORDER BY salary DESC) AS rnk FROM Department d JOIN Employee e ON d.id = e.departmentId ) SELECT Department, Employee, Salary FROM employee_department WHERE rnk <= 3 ```  -",
    "constraints": [
      "There are no employees with the exact same name, salary and department."
    ],
    "examples": [
      {
        "example_text": "+--++ | Column Name | Type | +--++ | id | int | | name | varchar | | salary | int | | departmentId | int | +--++ id is the primary key (column with unique values) for this table. departmentId is a foreign key (reference column) of the ID from the Department table. Each row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department."
      },
      {
        "example_text": "+-++ | Column Name | Type | +-++ | id | int | | name | varchar | +-++ id is the primary key (column with unique values) for this table. Each row of this table indicates the ID of a department and its name."
      },
      {
        "example_text": "Input: Employee table: +-+-+--+--+ | id | name | salary | departmentId | +-+-+--+--+ | 1 | Joe | 85000 | 1 | | 2 | Henry | 80000 | 2 | | 3 | Sam | 60000 | 2 | | 4 | Max | 90000 | 1 | | 5 | Janet | 69000 | 1 | | 6 | Randy | 85000 | 1 | | 7 | Will | 70000 | 1 | +-+-+--+--+ Department table: +-+-+ | id | name | +-+-+ | 1 | IT | | 2 | Sales | +-+-+ Output: ++-+--+ | Department | Employee | Salary | ++-+--+ | IT | Max | 90000 | | IT | Joe | 85000 | | IT | Randy | 85000 | | IT | Will | 70000 | | Sales | Henry | 80000 | | Sales | Sam | 60000 | ++-+--+ Explanation: In the IT department: - Max earns the highest unique salary - Both Randy and Joe earn the second-highest unique salary - Will earns the third-highest unique salary In the Sales department: - Henry earns the highest salary - Sam earns the second-highest salary - There is no third-highest salary as there are only two employees"
      }
    ]
  },
  {
    "problem_slug": "repeated-dna-sequences",
    "difficulty": "Medium",
    "topics": [
      "Hash Table",
      "String",
      "Bit Manipulation",
      "Sliding Window",
      "Rolling Hash",
      "Hash Function"
    ],
    "description": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. When studying DNA, it is useful to identify repeated sequences within the DNA. Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 105",
      "s[i] is either 'A', 'C', 'G', or 'T'."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\" Output: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]"
      },
      {
        "example_text": "Input: s = \"AAAAAAAAAAAAA\" Output: [\"AAAAAAAAAA\"]"
      }
    ]
  },
  {
    "problem_slug": "best-time-to-buy-and-sell-stock-iv",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k. Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= k <= 100",
      "1 <= prices.length <= 1000",
      "0 <= prices[i] <= 1000"
    ],
    "examples": [
      {
        "example_text": "Input: k = 2, prices = [2,4,1] Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2."
      },
      {
        "example_text": "Input: k = 2, prices = [3,2,6,5,0,3] Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3."
      }
    ]
  },
  {
    "problem_slug": "rotate-array",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Math",
      "Two Pointers"
    ],
    "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative. Example 1: Example 2: Constraints: Follow up:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 105",
      "-231 <= nums[i] <= 231 - 1",
      "0 <= k <= 105"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4]"
      },
      {
        "example_text": "Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]"
      }
    ]
  },
  {
    "problem_slug": "reverse-bits",
    "difficulty": "Easy",
    "topics": [
      "Divide and Conquer",
      "Bit Manipulation"
    ],
    "description": "Reverse bits of a given 32 bits unsigned integer. Note: Example 1: Example 2: Constraints: Follow up: If this function is called many times, how would you optimize it?",
    "solution": "",
    "constraints": [
      "0 <= n <= 231 - 2",
      "n is even."
    ],
    "examples": [
      {
        "example_text": "Input: n = 43261596 Output: 964176192 Explanation:"
      },
      {
        "example_text": "Input: n = 2147483644 Output: 1073741822 Explanation:"
      }
    ]
  },
  {
    "problem_slug": "number-of-1-bits",
    "difficulty": "Easy",
    "topics": [
      "Divide and Conquer",
      "Bit Manipulation"
    ],
    "description": "Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight). Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: n = 11 Output: 3 Explanation: The input binary string 1011 has a total of three set bits."
      },
      {
        "example_text": "Input: n = 128 Output: 1 Explanation: The input binary string 10000000 has a total of one set bit."
      },
      {
        "example_text": "Input: n = 2147483645 Output: 30 Explanation: The input binary string 1111111111111111111111111111101 has a total of thirty set bits."
      }
    ]
  },
  {
    "problem_slug": "word-frequency",
    "difficulty": "Medium",
    "topics": [
      "Shell"
    ],
    "description": "Write a bash script to calculate the frequency of each word in a text file words.txt. For simplicity sake, you may assume: Example: Assume that words.txt has the following content: Your script should output the following, sorted by descending frequency: Note:",
    "solution": "",
    "constraints": [],
    "examples": [
      {
        "example_text": "the day is sunny the the the sunny is is"
      },
      {
        "example_text": "the 4 is 3 sunny 2 day 1"
      }
    ]
  },
  {
    "problem_slug": "valid-phone-numbers",
    "difficulty": "Easy",
    "topics": [
      "Shell"
    ],
    "description": "Given a text file file.txt that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers. You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit) You may also assume each line in the text file must not contain leading or trailing white spaces. Example: Assume that file.txt has the following content: Your script should output the following valid phone numbers:",
    "solution": "",
    "constraints": [],
    "examples": [
      {
        "example_text": "987-123-4567 123 456 7890 (123) 456-7890"
      },
      {
        "example_text": "987-123-4567 (123) 456-7890"
      }
    ]
  },
  {
    "problem_slug": "transpose-file",
    "difficulty": "Medium",
    "topics": [
      "Shell"
    ],
    "description": "Given a text file file.txt, transpose its content. You may assume that each row has the same number of columns, and each field is separated by the ' ' character. Example: If file.txt has the following content: Output the following:",
    "solution": "",
    "constraints": [],
    "examples": [
      {
        "example_text": "name age alice 21 ryan 30"
      },
      {
        "example_text": "name alice ryan age 21 30"
      }
    ]
  },
  {
    "problem_slug": "tenth-line",
    "difficulty": "Easy",
    "topics": [
      "Shell"
    ],
    "description": "Given a text file file.txt, print just the 10th line of the file. Example: Assume that file.txt has the following content: Your script should output the tenth line, which is:",
    "solution": "",
    "constraints": [],
    "examples": [
      {
        "example_text": "Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 Line 7 Line 8 Line 9 Line 10"
      },
      {
        "example_text": "Line 10"
      }
    ]
  },
  {
    "problem_slug": "delete-duplicate-emails",
    "difficulty": "Easy",
    "topics": [
      "Database"
    ],
    "description": "Table: Person Write a solution to delete all duplicate emails, keeping only one unique email with the smallest id. For SQL users, please note that you are supposed to write a DELETE statement and not a SELECT one. For Pandas users, please note that you are supposed to modify Person in place. After running your script, the answer shown is the Person table. The driver will first compile and run your piece of code and then show the Person table. The final order of the Person table does not matter. The result format is in the following example. Example 1:",
    "solution": "",
    "constraints": [],
    "examples": [
      {
        "example_text": "+-++ | Column Name | Type | +-++ | id | int | | email | varchar | +-++ id is the primary key (column with unique values) for this table. Each row of this table contains an email. The emails will not contain uppercase letters."
      },
      {
        "example_text": "Input: Person table: +-++ | id | email | +-++ | 1 | john@example.com | | 2 | bob@example.com | | 3 | john@example.com | +-++ Output: +-++ | id | email | +-++ | 1 | john@example.com | | 2 | bob@example.com | +-++ Explanation: john@example.com is repeated two times. We keep the row with the smallest Id = 1."
      }
    ]
  },
  {
    "problem_slug": "rising-temperature",
    "difficulty": "Easy",
    "topics": [
      "Database"
    ],
    "description": "Table: Weather Write a solution to find all dates' id with higher temperatures compared to its previous dates (yesterday). Return the result table in any order. The result format is in the following example. Example 1:",
    "solution": "Solution Overview Problem Statement Reference > Write a solution to find all dates' Id with higher temperatures compared to its previous dates (yesterday). Return the result table in any order. Let's further elaborate on the given example to deepen our understanding of the problem at hand. If we conduct a time series analysis of the temperature data, we would notice distinct points where there is a rise in temperature compared to the previous day. This phenomenon is precisely what we are interested in identifying. By analyzing the given data:idrecordDatetemperature12015-01-011022015-01-022532015-01-032042015-01-0430We can graphically represent the temperature readings across the consecutive dates. When we plot these points on a graph, with the `recordDate` on the X-axis and the `temperature` on the Y-axis, we observe a graphical representation of the temperature variations over the specified period. ![fig](../Figures/197/197-1.png) From this graphical analysis, we notice two instances where there is a rise in the temperature compared to the day before: 1. January 2, 2015 (id: 2): On this day, the temperature is recorded to be 25, which is higher than the 10 recorded on January 1st. 2. January 4, 2015 (id: 4): Here, the temperature escalated to 30, surpassing the temperature of 20 noted on January 3rd. Thus, based on our criteria of identifying days with a temperature rise compared to the immediate preceding day, we should return the ids for January 2nd and January 4th, which are 2 and 4 respectively. pandas Approach 1: Shifted Dataframe Merge on Record Date Intuition We are creating a new DataFrame that represents the data shifted by one day and merging it with the original DataFrame based on the `recordDate`. This way, for each record, we will have information on both the current day and the previous day in the same row, enabling easy comparison of temperatures across consecutive days. Let's break this down step by step: Step 1: Converting `recordDate` to Datetime Type ```python Ensure the 'recordDate' column is a datetime type weather['recordDate'] = pd.to_datetime(weather['recordDate']) ``` - Before working with date data, it is good practice to ensure that the date column is of the datetime data type to facilitate date-based operations correctly. Step 2: Creating a Shifted DataFrame ```python Create a copy of the weather DataFrame with a 1 day shift weather_shifted = weather.copy() weather_shifted['recordDate'] = weather_shifted['recordDate'] + pd.to_timedelta(1, unit='D') ``` - A copy of the original DataFrame is created, where the `recordDate` for each entry is shifted forward by one day. This allows us to later merge this DataFrame with the original one to compare the temperatures of each day with the previous day. Step 3: Merging the Original and Shifted DataFrames ```python Merging the DataFrames on the 'recordDate' column to find consecutive dates merged_df = pd.merge(weather, weather_shifted, on='recordDate', suffixes=('_today', '_yesterday')) ``` - The original and shifted DataFrames are merged based on the `recordDate` column, which now contains consecutive dates. This merge operation forms pairs of consecutive days so that we can directly compare the temperatures of each day with the previous day. Step 4: Identifying Days with Higher Temperatures than the Previous Day ```python Finding rows where the temperature is greater on the current day compared to the previous day result = merged_df[merged_df['temperature_today'] > merged_df['temperature_yesterday']][['id_today']].rename(columns={'id_today': 'Id'}) ``` - Within the merged DataFrame, we apply a condition to retain only those rows where the temperature of the current day (`temperature_today`) is greater than that of the previous day (`temperature_yesterday`). This effectively identifies all the days where the temperature was higher than the previous day. - We select only the ID column corresponding to the days that satisfy this condition, renaming it to `Id` to meet the output specification. Step 5: Returning the Result ```python return result ``` - The final step is to return the DataFrame containing the IDs of the days where the temperature was higher than on the previous day. Implementation Approach 2: Shift Function with Precise Date Match Intuition In this approach, we sort the DataFrame by `recordDate` and then use the shift function to create new columns that hold the data for the previous day. After that, we filter the DataFrame to only include the rows where the temperature is greater than that of the previous day and the dates are precisely one day apart. Let's break this down step by step: Step 1: Converting `recordDate` to Datetime Type ```python weather['recordDate'] = pd.to_datetime(weather['recordDate']) ``` - Before performing operations based on dates, we first ensure that the `recordDate` column is of datetime type. This allows us to easily perform date-specific operations later in the function. Step 2: Sorting the DataFrame ```python weather.sort_values('recordDate', inplace=True) ``` - We sort the data based on the `recordDate` to maintain a chronological order. This step is crucial because the next steps involve operations that are dependent on the order of the dates. Step 3: Creating Columns for Previous Day's Data ```python weather['PreviousTemperature'] = weather['temperature'].shift(1) weather['PreviousRecordDate'] = weather['recordDate'].shift(1) ``` - We create two new columns in the `weather` DataFrame: - `PreviousTemperature`: This column is constructed by shifting the `temperature` column down by one row using `shift(1)`. This means that the value in each row of `PreviousTemperature` is the temperature value from the immediately preceding row in the DataFrame, not necessarily from the immediately preceding day in terms of time. - `PreviousRecordDate`: Similarly, this column is formed by shifting the `recordDate` column down by one row. Hence, each value in `PreviousRecordDate` corresponds to the date from the immediately preceding row, not necessarily the day immediately before the current `recordDate`. By having these new columns, we align each row with the temperature and record date of its preceding row in the DataFrame, allowing for comparisons between a day's temperature and that of the previous row. Its crucial to note that these previous values come from the DataFrame's order and do not always represent the chronological day before, as there might be gaps in the dates within the data. Step 4: Filtering for Days with Higher Temperature than the Previous Day ```python result = weather[ (weather['temperature'] > weather['PreviousTemperature']) & (weather['recordDate'] == weather['PreviousRecordDate'] + pd.Timedelta(days=1)) ][['id']].rename(columns={'id': 'Id'}) ``` - We are filtering the DataFrame for rows where the temperature is higher than the previous day's temperature: `(weather['temperature'] > weather['PreviousTemperature'])`. - We also ensure that the record date is exactly one day more than the previous record date: `(weather['recordDate'] == weather['PreviousRecordDate'] + pd.Timedelta(days=1))`. This is done using `pd.Timedelta(days=1)` to add a day to the previous record date and checking if it equals the current record date. Step 5: Returning the Result ```python return result ``` - Finally, we return the filtered DataFrame which contains only the `Id` column that satisfies both conditions specified in step 4. This DataFrame represents all the dates where the temperature was higher than the temperature of the previous day. Implementation Database Approach 1: Using `JOIN` and `DATEDIFF()` Intuition By doing a self-join on the `Weather` table, we create a Cartesian product of the table with itself, creating pairs of days. We then use the `DATEDIFF` function to restrict these pairs to only include consecutive days. Lastly, we filter these pairs of consecutive days further to only include pairs where the temperature is higher on the second day. The resulting ids represent the days where the temperature was higher than the previous day. Let's break this down step by step: Step 1: Defining the Main Query Structure ```sql SELECT w1.id FROM Weather w1 JOIN Weather w2 ``` Here, we are setting up a query to retrieve the `id` from the `Weather` table aliased as `w1`. To find the records where the temperature is greater than the previous day, we are performing a self-join on the `Weather` table, creating a second alias `w2`. This allows us to compare each record in `w1` with each record in `w2`. Step 2: Join Condition ```sql ON DATEDIFF(w1.recordDate, w2.recordDate) = 1 ``` In the join condition, we are using the `DATEDIFF` function to find pairs of records where the `recordDate` differs by exactly one day. This condition ensures that we are comparing each day's temperature with the temperature of the previous day. Step 3: Filter Records with Higher Temperature ```sql WHERE w1.temperature > w2.temperature; ``` After finding pairs of days that are consecutive, we apply a filter in the `WHERE` clause to only get the records where the temperature on a day (represented by a record in `w1`) is greater than the temperature on the previous day (represented by a record in `w2`). This is the main condition to fulfill the requirement of finding the ids where the temperature is higher than the previous day. Implementation ```mysql [] SELECT w1.id FROM Weather w1 JOIN Weather w2 ON DATEDIFF(w1.recordDate, w2.recordDate) = 1 WHERE w1.temperature > w2.temperature; ``` Approach 2: Using `LAG()` Function Intuition Let's break this down step by step: Step 1: Creating a Common Table Expression (CTE) with Lag Function ```sql WITH PreviousWeatherData AS ( SELECT id, recordDate, temperature, LAG(temperature, 1) OVER (ORDER BY recordDate) AS PreviousTemperature, LAG(recordDate, 1) OVER (ORDER BY recordDate) AS PreviousRecordDate FROM Weather ) ``` In this step, we create a Common Table Expression (CTE) named `PreviousWeatherData` using a `WITH` clause. Inside this CTE, we are selecting all the rows from the \"Weather\" table along with two additional columns: 1. `PreviousTemperature`: The temperature from the previous day, which is obtained using the `LAG()` function with an offset of 1, ordered by `recordDate`. 2. `PreviousRecordDate`: The record date of the previous day, similarly obtained using the `LAG()` function with an offset of 1, ordered by `recordDate`. This setup helps us associate each record with the respective details from the previous day in the same row. Step 2: Selecting IDs with Conditions on Temperature and Date ```sql SELECT id FROM PreviousWeatherData WHERE temperature > PreviousTemperature AND recordDate = DATE_ADD(PreviousRecordDate, INTERVAL 1 DAY); ``` In this step, we execute a query on the `PreviousWeatherData` CTE with two conditions in the WHERE clause to filter the required IDs: 1. `temperature > PreviousTemperature`: This condition filters for the days where the temperature was higher than the previous day's temperature. 2. `recordDate = DATE_ADD(PreviousRecordDate, INTERVAL 1 DAY)`: This condition ensures that we are comparing consecutive days. It uses the `DATE_ADD()` function to add an interval of 1 day to the `PreviousRecordDate` and checks if it equals the current `recordDate`. By combining these two conditions with an `AND` clause, we ensure that we only select the IDs where both conditions are met, which are the days when the temperature is higher than the day before. Implementation ```mysql [] WITH PreviousWeatherData AS ( SELECT id, recordDate, temperature, LAG(temperature, 1) OVER (ORDER BY recordDate) AS PreviousTemperature, LAG(recordDate, 1) OVER (ORDER BY recordDate) AS PreviousRecordDate FROM Weather ) SELECT id FROM PreviousWeatherData WHERE temperature > PreviousTemperature AND recordDate = DATE_ADD(PreviousRecordDate, INTERVAL 1 DAY); ``` Approach 3: Using Subquery Intuition Let's break this down step by step: Step 1: Inner Subquery to Get the Previous Days Temperature ```sql SELECT w2.temperature FROM Weather w2 WHERE w2.recordDate = DATE_SUB(w1.recordDate, INTERVAL 1 DAY) ``` The inner query is responsible for retrieving the temperature of the day before the date currently under consideration in the outer query. It utilizes the `DATE_SUB` function to find the date one day before the `recordDate` in the outer query (`w1.recordDate`) and then fetches the temperature recorded on that previous date from the same Weather table (alias `w2`). Step 2: Outer Query to Find Days with Higher Temperature ```sql SELECT w1.id FROM Weather w1 WHERE w1.temperature > ( -- ... (inner subquery) ); ``` The outer query iterates over each row (each day) in the Weather table (alias `w1`) and checks if the temperature on that day is greater than the temperature on the previous day, the latter being obtained from the inner subquery. Step 3: Comparing Temperatures ```sql w1.temperature > ( -- ... (inner subquery) ) ``` Here, we have the crucial comparison that serves our goal. For each day in the outer query, it checks whether the temperature is greater than the temperature fetched from the inner subquery (which is the temperature of the previous day). Step 4: Selecting the ID ```sql SELECT w1.id ``` If the condition in the `WHERE` clause is satisfied (todays temperature is greater than yesterdays), we select the ID of the current day (from the outer querys perspective). This ID indicates a day where the temperature was higher than the temperature on the previous day. Implementation ```mysql [] SELECT w1.id FROM Weather w1 WHERE w1.temperature > ( SELECT w2.temperature FROM Weather w2 WHERE w2.recordDate = DATE_SUB(w1.recordDate, INTERVAL 1 DAY) ); ``` Approach 4: Using Cartesian Product and `WHERE` Clause Intuition Let's break this down step by step: Step 1: Cartesian Product ```sql FROM Weather w1, Weather w2 ``` In this step, we are performing a Cartesian product (or cross join) of the `Weather` table with itself. This means we create a new table where each row from `w1` (first instance of the Weather table) is paired with every row from `w2` (second instance of the Weather table), resulting in a table with n rows (where n is the number of rows in the Weather table). Step 2: Filtering Based on Date Difference ```sql WHERE DATEDIFF(w2.recordDate, w1.recordDate) = 1 ``` Next, we use the `DATEDIFF` function to find pairs of rows where the difference between the 'recordDate' in w2 and w1 is exactly 1 day. This effectively filters down to pairs of rows representing consecutive days. Step 3: Filtering Based on Temperature Difference ```sql AND w2.temperature > w1.temperature; ``` In this step, we are filtering the pairs further to retain only those where the temperature on the second day (`w2.temperature`) is greater than the temperature on the first day (`w1.temperature`). This finds the days where the temperature is rising compared to the previous day. Step 4: Selecting the Result ```sql SELECT w2.id ``` Finally, from all the pairs that satisfy the conditions set in the WHERE clause, we select the ID of the day from the w2 table (i.e., the ID of the day with the higher temperature). Implementation ```mysql [] SELECT w2.id FROM Weather w1, Weather w2 WHERE DATEDIFF(w2.recordDate, w1.recordDate) = 1 AND w2.temperature > w1.temperature; ```",
    "constraints": [],
    "examples": [
      {
        "example_text": "+++ | Column Name | Type | +++ | id | int | | recordDate | date | | temperature | int | +++ id is the column with unique values for this table. There are no different rows with the same recordDate. This table contains information about the temperature on a certain day."
      },
      {
        "example_text": "Input: Weather table: +-++-+ | id | recordDate | temperature | +-++-+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +-++-+ Output: +-+ | id | +-+ | 2 | | 4 | +-+ Explanation: In 2015-01-02, the temperature was higher than the previous day (10 -> 25). In 2015-01-04, the temperature was higher than the previous day (20 -> 30)."
      }
    ]
  },
  {
    "problem_slug": "house-robber",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 400"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4."
      },
      {
        "example_text": "Input: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12."
      }
    ]
  },
  {
    "problem_slug": "binary-tree-right-side-view",
    "difficulty": "Medium",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example 1: Example 2: Example 3: Example 4: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: root = [1,2,3,null,5,null,4] Output: [1,3,4] Explanation:"
      },
      {
        "example_text": "Input: root = [1,2,3,4,null,null,null,5] Output: [1,3,4,5] Explanation:"
      },
      {
        "example_text": "Input: root = [1,null,3] Output: [1,3]"
      },
      {
        "example_text": "Input: root = [] Output: []"
      }
    ]
  },
  {
    "problem_slug": "number-of-islands",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "example_text": "Input: grid = [ [\"1\",\"1\",\"1\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"0\",\"0\"] ] Output: 1"
      },
      {
        "example_text": "Input: grid = [ [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"1\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"1\",\"1\"] ] Output: 3"
      }
    ]
  },
  {
    "problem_slug": "bitwise-and-of-numbers-range",
    "difficulty": "Medium",
    "topics": [
      "Bit Manipulation"
    ],
    "description": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "0 <= left <= right <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: left = 5, right = 7 Output: 4"
      },
      {
        "example_text": "Input: left = 0, right = 0 Output: 0"
      },
      {
        "example_text": "Input: left = 1, right = 2147483647 Output: 0"
      }
    ]
  },
  {
    "problem_slug": "happy-number",
    "difficulty": "Easy",
    "topics": [
      "Hash Table",
      "Math",
      "Two Pointers"
    ],
    "description": "Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: Return true if n is a happy number, and false if not. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: n = 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1"
      },
      {
        "example_text": "Input: n = 2 Output: false"
      }
    ]
  },
  {
    "problem_slug": "remove-linked-list-elements",
    "difficulty": "Easy",
    "topics": [
      "Linked List",
      "Recursion"
    ],
    "description": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the list is in the range [0, 104].",
      "1 <= Node.val <= 50",
      "0 <= val <= 50"
    ],
    "examples": [
      {
        "example_text": "Input: head = [1,2,6,3,4,5,6], val = 6 Output: [1,2,3,4,5]"
      },
      {
        "example_text": "Input: head = [], val = 1 Output: []"
      },
      {
        "example_text": "Input: head = [7,7,7,7], val = 7 Output: []"
      }
    ]
  },
  {
    "problem_slug": "count-primes",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Math",
      "Enumeration",
      "Number Theory"
    ],
    "description": "Given an integer n, return the number of prime numbers that are strictly less than n. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "0 <= n <= 5 * 106"
    ],
    "examples": [
      {
        "example_text": "Input: n = 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7."
      },
      {
        "example_text": "Input: n = 0 Output: 0"
      },
      {
        "example_text": "Input: n = 1 Output: 0"
      }
    ]
  },
  {
    "problem_slug": "isomorphic-strings",
    "difficulty": "Easy",
    "topics": [
      "Hash Table",
      "String"
    ],
    "description": "Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 5 * 104",
      "t.length == s.length",
      "s and t consist of any valid ascii character."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"egg\", t = \"add\" Output: true Explanation: The strings s and t can be made identical by:"
      },
      {
        "example_text": "Input: s = \"foo\", t = \"bar\" Output: false Explanation: The strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r' ."
      },
      {
        "example_text": "Input: s = \"paper\", t = \"title\" Output: true"
      }
    ]
  },
  {
    "problem_slug": "reverse-linked-list",
    "difficulty": "Easy",
    "topics": [
      "Linked List",
      "Recursion"
    ],
    "description": "Given the head of a singly linked list, reverse the list, and return the reversed list. Example 1: Example 2: Example 3: Constraints: Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?",
    "solution": "",
    "constraints": [
      "The number of nodes in the list is the range [0, 5000].",
      "-5000 <= Node.val <= 5000"
    ],
    "examples": [
      {
        "example_text": "Input: head = [1,2,3,4,5] Output: [5,4,3,2,1]"
      },
      {
        "example_text": "Input: head = [1,2] Output: [2,1]"
      },
      {
        "example_text": "Input: head = [] Output: []"
      }
    ]
  },
  {
    "problem_slug": "course-schedule",
    "difficulty": "Medium",
    "topics": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. Return true if you can finish all courses. Otherwise, return false. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= ai, bi < numCourses",
      "All the pairs prerequisites[i] are unique."
    ],
    "examples": [
      {
        "example_text": "Input: numCourses = 2, prerequisites = [[1,0]] Output: true Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible."
      },
      {
        "example_text": "Input: numCourses = 2, prerequisites = [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible."
      }
    ]
  },
  {
    "problem_slug": "implement-trie-prefix-tree",
    "difficulty": "Medium",
    "topics": [
      "Hash Table",
      "String",
      "Design",
      "Trie"
    ],
    "description": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: Example 1: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= word.length, prefix.length <= 2000",
      "word and prefix consist only of lowercase English letters.",
      "At most 3 * 104 calls in total will be made to insert, search, and startsWith."
    ],
    "examples": [
      {
        "example_text": "Input [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"] [[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]] Output [null, null, true, false, true, null, true] Explanation Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // return True trie.search(\"app\"); // return False trie.startsWith(\"app\"); // return True trie.insert(\"app\"); trie.search(\"app\"); // return True"
      }
    ]
  },
  {
    "problem_slug": "minimum-size-subarray-sum",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Binary Search",
      "Sliding Window",
      "Prefix Sum"
    ],
    "description": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead. Example 1: Example 2: Example 3: Constraints:",
    "solution": "Solution Overview Given an array of positive integers `nums` and a positive integer `target`, our task is to return the minimal length of a subarray whose sum is greater than or equal to `target`. If there is no such subarray, we have to return `0`. Approach: Sliding Window Intuition An intuitive technique is to go through all the subarrays one by one and check the sum of each one. If the total of the subarray under consideration is larger than or equal to `target`, we attempt to update our answer variable by using the minimum of the current answer and the length of this subarray. To get all the subarrays, we can run two loops: the outer loop selects a starting point and the inner loop selects an ending point. This solution, however, will take $O(n^2)$ time, resulting in a time limit exceeded (TLE). Let's think whether we really need to iterate over all the subarrays. Given that we only have positive integers, there is no purpose in adding further elements to a subarray if its sum exceeds or equals `target`. Adding more elements to such a subarray will result in the construction of longer subarrays, which is useless because we have already found a smaller subarray that meets our requirements. Only if the sum of the current subarray under consideration is smaller than `target`, we should append elements to the subarray. When the sum of the subarrays exceeds or equals `target`, we will attempt to update our answer with the length of the current subarray. We now try to remove the elements from the start and see if we can form a smaller subarray that meets our requirements. We remove the first element from the subarray and check if we still have the total higher than or equal to `target`. If the total exceeds or equals `target`, we have a smaller subarray that meets our requirement. As a result, we again try to update our answer with the length of the current subarray and repeat the process of eliminating the first element from the current subarray until the sum no longer exceeds or equals `target`. Now after removing elements, if the sum of the subarray is less than `target`, we have to append more elements to it until the sum becomes larger than or equal to `target`. We append elements until the sum equals or exceeds `target`, then try to update our answer variable and repeat the process of eliminating the first element. The above approach can be efficiently solved using the sliding window approach. If you are not familiar with sliding window, please refer to our explore cards [Sliding Window Explore Card](https://leetcode.com/explore/featured/card/leetcodes-interview-crash-course-data-structures-and-algorithms/703/arraystrings/4502/). A sliding window is achieved by using two pointers `left` and `right`, which point to the starting and ending indices of the subarray. We set them to a value of `0`. To \"add\" elements to the window, we loop over the array by incrementing `right`. In this problem, if the sum of the window exceeds or equals `target`, we try to update our answer and then \"remove\" elements from the window by incrementing `left` until the sum is less than `target` again. Here's a visual representation of how the approach works: !?!../Documents/209/209-slides.json:601,301!?! Algorithm 1. Create three integer variables `left`, `right` and `sumOfCurrentWindow`. The variables `left` and `right` form a subarray by pointing to the starting and ending indices of the current subarray (or window), and `sumOfCurrentWindow` stores the sum of this window. Initialize all of them with `0`. 2. Create another variable `res` to store the answer to the problem. We initialize it to a large integer value. 3. We iterate over `nums` using `right` starting from `right = 0` till `nums.length - 1` incrementing `right` by `1` after each iteration. We perform the following inside this iteration: - Add element at index `right` to the current window, incrementing `sumOfCurrentWindow` by `nums[right]`. - We check if `sumOfCurrentWindow >= target`. If so, we have a subarray that satisfies our condition. As a result, we attempt to update our answer variable with the length of this subarray. We perform `res = min(res, right - left + 1)`. We then remove the first element from this window by reducing `sumOfCurrentWindow` by `nums[left]` and incrementing `left` by `1`. This step is repeated in an inner loop as long as `sumOfCurrentWindow >= target`. - The current window's sum is now smaller than `target`. We need to add more elements to it. As a result, `right` is incremented by `1`. 4. Return `res`. Implementation Complexity Analysis Here $n$ is the length of `nums`. * Time complexity: $O(n)$. - You may be thinking: there is an inner while loop inside another for loop, isn't the time complexity $O(n^2)$? The reason it is still $O(n)$ is because the right pointer `right` can move $n$ times and the left pointer `left` can move also $n$ times in total. The inner loop is not running $n$ times for each iteration of the outer loop. A sliding window guarantees a maximum of $2n$ window iterations. This is what is referred to as [amortized analysis](https://en.wikipedia.org/wiki/Amortized_analysis) - even though the worst case for an iteration inside the for loop is $O(n)$, it averages out to $O(1)$ when you consider the entire runtime of the algorithm. * Space complexity: $O(1)$. - We are not using any extra space other than a few integer variables:`left`, `right`, `sumOfCurrentWindow`, and `res`, which takes up constant space each.",
    "constraints": [
      "1 <= target <= 109",
      "1 <= nums.length <= 105",
      "1 <= nums[i] <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint."
      },
      {
        "example_text": "Input: target = 4, nums = [1,4,4] Output: 1"
      },
      {
        "example_text": "Input: target = 11, nums = [1,1,1,1,1,1,1,1] Output: 0"
      }
    ]
  },
  {
    "problem_slug": "course-schedule-ii",
    "difficulty": "Medium",
    "topics": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= numCourses * (numCourses - 1)",
      "prerequisites[i].length == 2",
      "0 <= ai, bi < numCourses",
      "ai != bi",
      "All the pairs [ai, bi] are distinct."
    ],
    "examples": [
      {
        "example_text": "Input: numCourses = 2, prerequisites = [[1,0]] Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]."
      },
      {
        "example_text": "Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]] Output: [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3]."
      },
      {
        "example_text": "Input: numCourses = 1, prerequisites = [] Output: [0]"
      }
    ]
  },
  {
    "problem_slug": "design-add-and-search-words-data-structure",
    "difficulty": "Medium",
    "topics": [
      "String",
      "Depth-First Search",
      "Design",
      "Trie"
    ],
    "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string. Implement the WordDictionary class: Example: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= word.length <= 25",
      "word in addWord consists of lowercase English letters.",
      "word in search consist of '.' or lowercase English letters.",
      "There will be at most 2 dots in word for search queries.",
      "At most 104 calls will be made to addWord and search."
    ],
    "examples": [
      {
        "example_text": "Input [\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"] [[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]] Output [null,null,null,null,false,true,true,true] Explanation WordDictionary wordDictionary = new WordDictionary(); wordDictionary.addWord(\"bad\"); wordDictionary.addWord(\"dad\"); wordDictionary.addWord(\"mad\"); wordDictionary.search(\"pad\"); // return False wordDictionary.search(\"bad\"); // return True wordDictionary.search(\".ad\"); // return True wordDictionary.search(\"b..\"); // return True"
      }
    ]
  },
  {
    "problem_slug": "word-search-ii",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "String",
      "Backtracking",
      "Trie",
      "Matrix"
    ],
    "description": "Given an m x n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "m == board.length",
      "n == board[i].length",
      "1 <= m, n <= 12",
      "board[i][j] is a lowercase English letter.",
      "1 <= words.length <= 3 * 104",
      "1 <= words[i].length <= 10",
      "words[i] consists of lowercase English letters.",
      "All the strings of words are unique."
    ],
    "examples": [
      {
        "example_text": "Input: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"] Output: [\"eat\",\"oath\"]"
      },
      {
        "example_text": "Input: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"] Output: []"
      }
    ]
  },
  {
    "problem_slug": "house-robber-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 1000"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses."
      },
      {
        "example_text": "Input: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4."
      },
      {
        "example_text": "Input: nums = [1,2,3] Output: 3"
      }
    ]
  },
  {
    "problem_slug": "shortest-palindrome",
    "difficulty": "Hard",
    "topics": [
      "String",
      "Rolling Hash",
      "String Matching",
      "Hash Function"
    ],
    "description": "You are given a string s. You can convert s to a palindrome by adding characters in front of it. Return the shortest palindrome you can find by performing this transformation. Example 1: Example 2: Constraints:",
    "solution": "Solution Overview We are given a string `s`. Our task is to build the smallest palindrome by adding characters to the beginning of `s`. To solve this, we can reframe the problem as finding the longest palindromic substring that starts from the index `0`. Once we know the length of this substring, we can create the shortest palindrome by appending the reverse of the remaining part of the string to the original string to make `s` a complete palindrome. For instance, consider the string `s = \"aacecaaa\"`. Here, the longest palindromic prefix is `\"aacecaa\"`(starts at index `0`). The remaining part of the string is just the last `\"a\"`. To create the smallest palindrome, we reverse this remaining part and add it to the front of the original string, resulting in `\"aaacecaaa\"`, which is a palindrome. Another example is `s = \"abcd\"`, where the longest palindromic prefix is just the first character `\"a\"`. The remaining part, `\"bcd\"`, is not a palindrome. By reversing `\"bcd\"` and adding it to the start, we get `\"dcbabcd\"`, which is the smallest palindrome that can be formed from the original string. This way, we can find the shortest palindrome by adding only the necessary characters to the front of the string. Approach 1: Brute Force Intuition As we know, a palindrome reads the same forwards and backwards. Therefore, the challenge is to identify the longest prefix of the original string that can be extended to a full palindrome by only adding characters at the start. First, we need to find out which part of the string is already a palindrome. So, we check the original string and see how much of it matches the end of its reversed version. This helps us figure out the longest palindromic prefix. To do this, we look at different prefixes of the original string and compare them to suffixes of the reversed string. If a prefix matches a suffix of the reversed string, its part of a palindrome. Once we find the longest palindromic prefix, we need to reverse the rest of the string (the part not included in the prefix) and add this reversed part to the start of the original string. This gives us the shortest possible palindrome. For example: Lets take the string `\"abcbabcab\"`. We reverse the string to get `\"bacbabcba\"`. By comparing prefixes of `\"abcbabcab\"` with suffixes of `\"bacbabcba\"`, we find that the longest prefix `\"abcba\"` matches with the suffix `\"abcba\"` in the reversed string. This is a palindrome. To form the shortest palindrome, we then need to reverse the remaining part of the original string that doesnt overlap with this prefix. In our example, the remaining part is `\"bcab\"`. Reversing `\"bcab\"` gives us `\"bacb\"`. Adding this to the start of the original string results in `\"bacbabcbabcab\"`. Algorithm - Initialize `length` with the length of the string `s`. - Reverse the string `s` to get `reversedString`. - Iterate through the string from `0` to `length - 1`: - For each index `i`, check if the substring `s.substring(0, length - i)` (i.e., the prefix of `s` up to `length - i`) is equal to the substring `reversedString.substring(i)` (i.e., the suffix of `reversedString` starting from `i`). - If they are equal, it means the prefix of `s` is a palindrome: - Return the concatenation of `reversedString.substring(0, i)` (i.e., the characters in `reversedString` before `i`) and the original string `s`. - If no valid prefix is found that satisfies the condition, return an empty string `\"\"`. Implementation Complexity Analysis Let $n$ be the length of the input string $s$. - Time complexity: $O(n^2)$ The reversal of the string `s` involves traversing the string once, which has a time complexity of $O(n)$. In the loop, for each iteration, we check if the substring of length $n - i$ of `s` matches the substring of length $n - i$ of the reversed string. Each check involves string operations that are linear in the length of the substring being compared. Thus, for each iteration $i$, the comparison is $O(n - i)$. Since $i$ ranges from 0 to $n - 1$, the total time complexity of the palindrome check part can be expressed as the sum of comparisons of decreasing lengths. This sum is roughly $O(n^2)$. Combining these operations, the overall time complexity is $O(n^2)$. - Space complexity: $O(n)$ Creating the reversed string involves additional space proportional to the length of the input string, i.e., $O(n)$. The substring operations in the `for` loop do not require additional space proportional to the length of the string but do create new string objects temporarily, which is still $O(n)$ space for each substring. Therefore, the overall space complexity is $O(n)$. Approach 2: Two Pointer Intuition In the brute force approach, we observe that we need to identify the longest palindromic prefix of a string. To do this, we can now use a method involving two pointers. This method is a bit more efficient compared to checking every possible substring, which would take longer. Let's consider an example string: `\"abcbabcaba\"`. We use two pointers, `left` and `right`. We start by setting `left` to `0`. Then, we move the `right` pointer from the end of the string to the beginning. Each time the characters at `left` and `right` match, we increment `left`. By following this process, we narrow our search to the substring from the beginning of the string up to `left`. This substring will always include the longest palindromic prefix. - If the entire string were a perfect palindrome, the `left` pointer would move through the entire length of the string, reaching the end (`n` times). - If the string isnt a perfect palindrome, the `left` pointer will still move forward by the length of the palindromic part at the beginning. Therefore, while the substring $[0, \\text{left})$ may not always be the tightest fit, it will always contain the longest palindromic prefix. The best-case scenario for this algorithm is when the entire string is a palindrome. In this case, the `left` pointer will reach the end of the string quickly. The worst-case scenario is when the string is something like `\"aababababababa\"`. Here, `left` initially becomes `12`, meaning we need to recheck the substring $[0, 12)$. As we continue, `left` might decrease to `10`, and so on. In this worst-case scenario, the substring is reduced by only a few elements at each step, making the total number of steps proportional to the length of the string, or $O(n)$. Algorithm - If the string `s` is empty, return `s` immediately. - Find the longest palindromic prefix: - Initialize `left` to 0. - Iterate `right` from the end of the string (`length - 1`) to the start (0): - If the character at `right` matches the character at `left`: - Increment `left`. - If `left` equals the length of the string, `s` is already a palindrome, so return `s`. - Extract the suffix that is not part of the palindromic prefix: - Create `nonPalindromeSuffix` as the substring from `left` to the end of `s`. - Reverse `nonPalindromeSuffix` to create `reverseSuffix`. - Form the shortest palindrome: - Recursively call `shortestPalindrome` on the substring from the start to `left` (i.e., `s.substring(0, left)`). - Concatenate `reverseSuffix`, the result of the recursive call, and `nonPalindromeSuffix`. - Return the concatenated result as the shortest palindrome. Implementation Complexity Analysis Let $n$ be the length of the input string. - Time Complexity: $O(n^2)$ Each iteration of the `shortestPalindrome` function operates on a substring of size `n`. In the worst-case scenario, where the string is not a palindrome and we must continually reduce its size, the function might need to be called up to `n/2` times. The time complexity $T(n)$ represents the total time taken by the algorithm. At each step, the algorithm processes a substring and then works with a smaller substring by removing two characters. This can be expressed as $T(n) = T(n-2) + O(n)$, where $O(n)$ is the time taken to process the substring of size `n`. Summing up all the steps, we get: $T(n) = O(n) + O(n-2) + O(n-4) + \\ldots + O(1)$ This sum of terms approximates to $O(n^2)$ because it is an arithmetic series where the number of terms grows linearly with `n`. - Space Complexity: $O(n)$ The space complexity is linear, $O(n)$, due to the space needed to store the reversed suffix and other temporary variables. Approach 3: KMP (Knuth-Morris-Pratt) Algorithm Intuition The KMP algorithm is used for pattern matching within strings. The KMP algorithm computes prefix functions to identify substrings that match specific patterns. In our case, we use this efficiency to compute the longest palindromic prefix. We construct a combined string of the original string, a special delimiter, and the reversed original string. By applying KMP, we can determine the longest prefix of the original string that matches a suffix of the reversed string. First, we construct a new string by concatenating the original string, a delimiter (such as `\"\"`), and the reversed original string. This combined string looks like `\"originalreversed\"`. The delimiter `\"\"` is crucial because it ensures that we are only comparing the original string with its reversed version, and not inadvertently matching parts of the reversed string with itself. To proceed, we calculate the prefix function for this combined string. The prefix function or partial match table is an array where each element at index `i` indicates the length of the longest prefix of the substring ending at `i` which is also a suffix. This helps us identify the longest segment where the prefix of the original string matches a suffix in the reversed string. The purpose is to identify how much of the original string matches a suffix of the reversed string.For example: We construct a combined string using the original string `s`, a delimiter `\"\"`, and the reversed version of `s`. This combined string helps us find the longest palindromic prefix by applying the KMP algorithm. For the string `\"aacecaaa\"`, the reversed string is `\"aaacecaa\"`. Thus, the combined string becomes `\"aacecaaaaaacecaa\"`. The prefix function helps us determine the length of the longest prefix of the original string that can be matched by a suffix of the reversed string. For the combined string `\"aacecaaaaaacecaa\"`, the prefix function will reveal that the longest palindromic prefix of `\"aacecaaa\"` is `\"aacecaa\"`. To create the shortest palindrome, we need to prepend characters to the original string. Specifically, we reverse the portion of the original string that extends beyond the longest palindromic prefix and prepend it. In this case, the part of the original string that extends beyond `\"aacecaa\"` is `\"a\"`. Reversing `\"a\"` gives `\"a\"`, so we prepend `\"a\"` to `\"aacecaaa\"` and the result is `\"aaacecaaa\"`.The algorithm to generate the prefix table is described below: ```java prefixTable[0] = 0; for (int i = 1; i < n; i++) { int length = prefixTable[i - 1]; while (length > 0 && s.charAt(i) != s.charAt(length)) { length = prefixTable[length - 1]; } if (s.charAt(i) == s.charAt(length)) { length++; } prefixTable[i] = length; } ``` * Begin by setting `prefixTable[0] = 0` since there is no proper prefix for the first character. * Next, iterate over `i` from 1 to `n - 1`: * Set `length = prefixTable[i - 1]`, which represents the longest prefix length for the substring up to the previous character. * While `length > 0` and the character at position `i` doesn't match the character at position `length`, set `length = prefixTable[length - 1]`. This step is essential when we encounter a mismatch, and we attempt to match a shorter prefix, which is the value of `prefixTable[length - 1]`, until either we find a match or `length` becomes 0. * If `s.charAt(i) == s.charAt(length)`, we increment `length` by 1 (extend the matching prefix). * Finally, set `prefixTable[i] = length`. The lookup table generation is as illustrated below: ![KMP](../Figures/214/shortest_palindrome_KMP.png) Algorithm - `shortestPalindrome` function: - Create `reversedString` by reversing the input string `s`. - Concatenate `s`, a separator ``, and `reversedString` to form `combinedString`. - Call `buildPrefixTable(combinedString)` to compute the prefix table for `combinedString`. - Extract the length of the longest palindromic prefix from the last value in the prefix table (`prefixTable[combinedString.length() - 1]`). - Compute `suffix` by taking the substring of `s` starting from the length of the longest palindromic prefix. - Reverse `suffix` and prepend it to `s` to form and return the shortest palindrome. - `buildPrefixTable` function: - Initialize `prefixTable` with the same length as the input string `s` and set `length` to `0`. - Iterate over `s` from index `1` to the end: - While `length` is greater than `0` and the current character does not match the character at the current length, update `length` to the value at `prefixTable[length - 1]`. - If the current character matches the character at `length`, increment `length`. - Set `prefixTable[i]` to the current `length`. - Return the `prefixTable`. - The result is the shortest palindrome string formed by appending the reversed suffix of `s` to `s`. Implementation Complexity Analysis Let $n$ be the length of the input string. - Time complexity: $O(n)$ Creating the reversed string requires a pass through the original string, which takes $O(n)$ time. Concatenating `s`, ``, and `reversedString` takes $O(n)$ time, as concatenating strings of length $n$ is linear in the length of the strings. Constructing the prefix table involves iterating over the combined string of length $2n + 1$. The `buildPrefixTable` method runs in $O(m)$ time, where $m$ is the length of the combined string. In this case, $m = 2n + 1$, so the time complexity is $O(n)$. Extracting the suffix and reversing it are both $O(n)$ operations. Combining these, the overall time complexity is $O(n)$. - Space complexity: $O(n)$ The `reversedString` and `combinedString` each use $O(n)$ space. The `prefixTable` array has a size of $2n + 1$, which is $O(n)$. Other variables used (such as `length` and indices) use $O(1)$ space. Combining these, the overall space complexity is $O(n)$. Approach 4: Rolling Hash Based Algorithm Intuition The rolling hash approach uses hash functions to efficiently compare different substrings of the original string with those of the reversed string. Hashing helps determine if a substring matches another by comparing hash values rather than individual characters. Rolling hashes were designed to handle substring matching and comparison problems by allowing incremental updates to hash values as we slide through the string. This reduces the number of comparisons needed by comparing hash values instead of actual substrings. To start, we compute hash values for all prefixes of the original string and all suffixes of the reversed string using a rolling hash function. The rolling hash function allows us to update the hash values incrementally, which speeds up the computation compared to recalculating hashes from scratch. Next, we compare the hash values of the prefixes from the original string with the hash values of the suffixes from the reversed string. When the hash values match, it indicates that the corresponding substrings are identical. This helps us find the longest palindromic prefix. For example: Suppose our string is `\"aacecaaa\"`. We calculate hash values for the prefixes of `\"aacecaaa\"` and the suffixes of its reverse, `\"aaacecaa\"`. The hash comparisons reveal that the longest palindromic prefix is `\"aacecaaa\"`. We then reverse the remaining part of the string (`\"a\"`), yielding `\"a\"`. Prepending this reversed part to the original string gives `\"aaacecaaa\"`. Hash Calculation Details: To give you a clearer idea of how the hashing is calculated, let's see this: We initialize two hash values: one for the original string and one for its reversed version. Lets use base `29` and a large prime modulus $10^9 + 7$ for hashing. We also initialize a variable to keep track of powers of the base. We iterate through each character of the original string and compute its hash. Suppose we start with the hash value `0` and process characters one by one:\\text{Character } 'a': \\text{Update hash:} \\text{hash} = (\\text{hash} \\times \\text{base} + \\text{character\\_value}) \\% \\text{mod} \\text{Suppose } \\text{character\\_value} \\text{ for } 'a' \\text{ is } 1. \\text{hash} = (0 \\times 29 + 1) \\% 1000000007 = 1\\text{Character } 'a': \\text{Update hash:} \\text{hash} = (1 \\times 29 + 1) \\% 1000000007 = 30Continue this for all characters. After processing `\"aacecaaa\"`, lets assume the final hash is `23456789` for this substring. We do a similar hash calculation for the reversed string `\"aaacecaa\"`. We compute the hash values for each prefix of the reversed string. Lets assume the final hash of the reversed string is `34567890`. To compare substrings, we use a rolling hash. As we move the window of comparison along the combined string, we update the hash values based on the new and old characters entering and exiting the window. If the hash of a prefix of the original string matches the hash of a suffix of the reversed string, that prefix is palindromic. Now the comparison shows that the longest prefix of `\"aacecaaa\"` that matches a suffix of `\"aaacecaa\"` is `\"aacecaa\"`. This tells us that `\"aacecaa\"` is a palindromic segment. Now we identify the remaining part of the original string that extends beyond the palindromic prefix. For `\"aacecaaa\"`, the remaining part is `\"a\"`. So we reverse the remaining part (`\"a\"`) to get `\"a\"`, and prepend this reversed part to the original string. Thus the shortest palindrome is `\"aaacecaaa\"`. Algorithm - Initialize hash parameters: - Set `hashBase` to 29 and `modValue` to $10^9 + 7$. - Initialize `forwardHash` and `reverseHash` to 0. - Initialize `powerValue` to 1. - Initialize `palindromeEndIndex` to -1. - Iterate over each character `currentChar` in the string `s`: - Update `forwardHash` to include the current character: - Compute `forwardHash` as `(forwardHash * hashBase + (currentChar - 'a' + 1)) % modValue`. - Update `reverseHash` to include the current character: - Compute `reverseHash` as `(reverseHash + (currentChar - 'a' + 1) * powerValue) % modValue`. - Update `powerValue` for the next character: - Compute `powerValue` as `(powerValue * hashBase) % modValue`. - If `forwardHash` matches `reverseHash`, update `palindromeEndIndex` to the current index `i`. - After the loop, find the suffix that follows the longest palindromic prefix: - Extract the suffix from the string `s` starting from `palindromeEndIndex + 1` to the end. - Reverse the suffix to prepare for prepending. - Concatenate the reversed suffix to the original string `s` and return the result: - Return `reversedSuffix + s`. Implementation Complexity Analysis Let $n$ be the length of the input string. - Time complexity: $O(n)$ The algorithm performs a single pass over the input string to compute rolling hashes and determine the longest palindromic prefix, resulting in $O(n)$ time complexity. This pass involves constant-time operations for each character, including hash updates and power calculations. After this, we perform an additional pass to reverse the suffix, which is also $O(n)$. The total time complexity remains $O(n)$. - Space complexity: $O(n)$ The space complexity is determined by the space used for the reversed suffix and the additional string manipulations. The space required for the forward and reverse hash values, power value, and palindrome end index is constant and does not scale with input size. However, storing the reversed suffix and the final result string both require $O(n)$ space. Thus, the space complexity is $O(n)$. Approach 5: Manacher's Algorithm Intuition > Note: This algorithm goes beyond what's typically expected in coding interviews. It's more for those who are curious and eager to explore advanced algorithms, simply out of personal interest or a desire to deepen their understanding of data structures and algorithms. If you're someone who loves learning new concepts beyond interview prep, this approach might be for you! Sometimes this is the only algorithm that can give you an $O(n)$ runtime.Developed to address the problem of finding palindromic substrings efficiently, Manachers algorithm preprocesses the string to handle both even and odd-length palindromes uniformly. By inserting special characters between each character of the original string, it computes the radius of the longest palindromic substring centered at each position. To handle palindromes of both even and odd lengths uniformly, the algorithm transforms the original string by inserting special characters (e.g., `\"\"`) between every character and at the boundaries. This way, every palindrome can be treated as if its surrounded by characters, making it easier to apply the same expansion logic for all cases. For example, the string `\"aacecaaa\"` is transformed into `\"^aacecaaa$\"`. Here, `^` and `$` are boundary markers that help avoid out-of-bound errors. `` helps to treat the string uniformly, making every palindrome appear with a single center. Manachers algorithm maintains an array `P` where `P[i]` denotes the radius of the longest palindromic substring centered at the position `i` in the transformed string.We divide Manacher's algorithm into three steps to achieve linear time complexity: 1. Center and Right Boundary: We track the center `C` and right boundary `R` of the rightmost palindrome found so far. For each position `i`, we check if it falls within the current right boundary. If it does, we use previously computed information to estimate the length of the palindrome centered at `i`. 2. Mirror Property: If a position `i` is within the right boundary of a known palindrome, we can infer the length of the palindrome centered at `i` from its mirrored position relative to the current center `C`. This way we reduce the need for direct expansion by leveraging previously computed palindromes to quickly estimate lengths. 3. Expand Around Center: For positions where the estimated palindrome length based on the mirror property is not accurate, we perform direct expansion to find the exact length of the palindrome centered at `i`. We update the center and right boundary if the newly found palindrome extends beyond the current right boundary.After computing the array `P`, we can determine the longest palindromic prefix of the original string. The longest palindromic substring in the transformed string that corresponds to a prefix of the original string gives us the longest palindromic prefix. To form the shortest palindrome, identify the part of the original string that does not contribute to this longest palindromic prefix. Reverse this non-matching segment and prepend it to the original string. With the string `\"aacecaaa\"`, after preprocessing to `\"aacecaaa\"`, Manachers algorithm identifies `\"aacecaaa\"` as the longest palindromic prefix. Reversing the remaining part (`\"a\"`) and prepending it results in `\"aaacecaaa\"`. We highly recommend solving the [longest palindromic substring problem using Manachers algorithm](https://leetcode.com/problems/longest-palindromic-substring/editorial/). It is extremely efficient and ideal for solving palindrome-related problems. This algorithm is complex, so review various sources to gain a better understanding. It's normal if you dont grasp it right away, so give yourself time. Algorithm - `shortestPalindrome` function: - If the input string `s` is null or empty, return `s` immediately. - Preprocess the string `s` by calling `preprocessString(s)` to handle edge cases and simplify palindrome detection. - `preprocessString` function: - Initialize a string with a starting character `^`. - Append a `` followed by each character in `s` to string. - Append a trailing `` and a dollar sign to complete the modified string. - Return the modified string which includes special boundary characters. - Initialize an integer array `palindromeRadiusArray` to store the radius of the palindrome centered at each character in the modified string. - Initialize `center` and `rightBoundary` to track the center and right boundary of the current longest palindrome found. - Initialize `maxPalindromeLength` to track the length of the longest palindrome that touches the start of the string. - Iterate through each character `i` in the modified string (excluding the boundary characters): - Calculate the `mirrorIndex` as `2 * center - i` to utilize previously computed palindromes. - If `rightBoundary` is greater than `i`, update `palindromeRadiusArray[i]` to the minimum of the remaining length to the `rightBoundary` or the radius of the palindrome at `mirrorIndex`. - Expand around the center `i` while the characters match and update `palindromeRadiusArray[i]` accordingly. - If the expanded palindrome extends beyond `rightBoundary`, update `center` and `rightBoundary` to the new values. - If the palindrome touches the start of the string (`i - palindromeRadiusArray[i] == 1`), update `maxPalindromeLength` with the maximum length found. - Extract the suffix of the original string starting from `maxPalindromeLength` and reverse it. - Concatenate the reversed suffix with the original string and return the result. Implementation Complexity Analysis Let $n$ be the length of the input string. - Time complexity: $O(n)$ The `preprocessString` method adds boundaries and separators to the input string. This takes linear time, $O(n)$, where $n$ is the length of the input string. The core algorithm iterates through the characters of the modified string once. The expansion step and the updates of the center and right boundary each take constant time in the average case for each character. Thus, this step has a time complexity of $O(m)$, where $m$ is the length of the modified string. Since the length of the modified string is $2n + 1 \\, (\\text{for separators}) + 2 \\, (\\text{for boundaries}) = 2n + 3$ , the time complexity of Manacher's algorithm is $O(n)$. Constructing the result involves reversing the suffix of the original string and concatenating it with the original string, both of which take linear time, $O(n)$. Combining these steps, the total time complexity is $O(n)$. - Space complexity: $O(n)$ The space used to store the modified string is proportional to its length, which is $2n + 3$. Therefore, the space complexity for storing this string is $O(n)$. The `palindromeRadiusArray` is used to store the radius of palindromes for each character in the modified string, which is $O(m)$. Since $m$ is $2n + 3$, the space complexity for this array is $O(n)$. The additional space used for temporary variables, and other operations is constant, $O(1)$. Combining these factors, the total space complexity is $O(n)$.",
    "constraints": [
      "0 <= s.length <= 5 * 104",
      "s consists of lowercase English letters only."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"aacecaaa\" Output: \"aaacecaaa\""
      },
      {
        "example_text": "Input: s = \"abcd\" Output: \"dcbabcd\""
      }
    ]
  },
  {
    "problem_slug": "kth-largest-element-in-an-array",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Divide and Conquer",
      "Sorting",
      "Heap (Priority Queue)",
      "Quickselect"
    ],
    "description": "Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting? Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= k <= nums.length <= 105",
      "-104 <= nums[i] <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [3,2,1,5,6,4], k = 2 Output: 5"
      },
      {
        "example_text": "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4"
      }
    ]
  },
  {
    "problem_slug": "combination-sum-iii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Backtracking"
    ],
    "description": "Find all valid combinations of k numbers that sum up to n such that the following conditions are true: Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "2 <= k <= 9",
      "1 <= n <= 60"
    ],
    "examples": [
      {
        "example_text": "Input: k = 3, n = 7 Output: [[1,2,4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations."
      },
      {
        "example_text": "Input: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations."
      },
      {
        "example_text": "Input: k = 4, n = 1 Output: [] Explanation: There are no valid combinations. Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination."
      }
    ]
  },
  {
    "problem_slug": "contains-duplicate",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Hash Table",
      "Sorting"
    ],
    "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 105",
      "-109 <= nums[i] <= 109"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,2,3,1] Output: true Explanation: The element 1 occurs at the indices 0 and 3."
      },
      {
        "example_text": "Input: nums = [1,2,3,4] Output: false Explanation: All elements are distinct."
      },
      {
        "example_text": "Input: nums = [1,1,1,3,3,4,3,2,4,2] Output: true"
      }
    ]
  },
  {
    "problem_slug": "the-skyline-problem",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Divide and Conquer",
      "Binary Indexed Tree",
      "Segment Tree",
      "Line Sweep",
      "Heap (Priority Queue)",
      "Ordered Set"
    ],
    "description": "A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively. The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]: You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. The skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form [[x1,y1],[x2,y2],...]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour. Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...] Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= buildings.length <= 104",
      "0 <= lefti < righti <= 231 - 1",
      "1 <= heighti <= 231 - 1",
      "buildings is sorted by lefti in non-decreasing order."
    ],
    "examples": [
      {
        "example_text": "Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]] Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]] Explanation: Figure A shows the buildings of the input. Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list."
      },
      {
        "example_text": "Input: buildings = [[0,2,3],[2,5,3]] Output: [[0,3],[5,0]]"
      }
    ]
  },
  {
    "problem_slug": "contains-duplicate-ii",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Hash Table",
      "Sliding Window"
    ],
    "description": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 105",
      "-109 <= nums[i] <= 109",
      "0 <= k <= 105"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,2,3,1], k = 3 Output: true"
      },
      {
        "example_text": "Input: nums = [1,0,1,1], k = 1 Output: true"
      },
      {
        "example_text": "Input: nums = [1,2,3,1,2,3], k = 2 Output: false"
      }
    ]
  },
  {
    "problem_slug": "contains-duplicate-iii",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Sliding Window",
      "Sorting",
      "Bucket Sort",
      "Ordered Set"
    ],
    "description": "You are given an integer array nums and two integers indexDiff and valueDiff. Find a pair of indices (i, j) such that: Return true if such pair exists or false otherwise. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "2 <= nums.length <= 105",
      "-109 <= nums[i] <= 109",
      "1 <= indexDiff <= nums.length",
      "0 <= valueDiff <= 109"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0 Output: true Explanation: We can choose (i, j) = (0, 3). We satisfy the three conditions: i != j --> 0 != 3 abs(i - j) <= indexDiff --> abs(0 - 3) <= 3 abs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0"
      },
      {
        "example_text": "Input: nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3 Output: false Explanation: After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false."
      }
    ]
  },
  {
    "problem_slug": "maximal-square",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Matrix"
    ],
    "description": "Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 300",
      "matrix[i][j] is '0' or '1'."
    ],
    "examples": [
      {
        "example_text": "Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] Output: 4"
      },
      {
        "example_text": "Input: matrix = [[\"0\",\"1\"],[\"1\",\"0\"]] Output: 1"
      },
      {
        "example_text": "Input: matrix = [[\"0\"]] Output: 0"
      }
    ]
  },
  {
    "problem_slug": "count-complete-tree-nodes",
    "difficulty": "Easy",
    "topics": [
      "Binary Search",
      "Bit Manipulation",
      "Tree",
      "Binary Tree"
    ],
    "description": "Given the root of a complete binary tree, return the number of the nodes in the tree. According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Design an algorithm that runs in less than O(n) time complexity. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 5 * 104].",
      "0 <= Node.val <= 5 * 104",
      "The tree is guaranteed to be complete."
    ],
    "examples": [
      {
        "example_text": "Input: root = [1,2,3,4,5,6] Output: 6"
      },
      {
        "example_text": "Input: root = [] Output: 0"
      },
      {
        "example_text": "Input: root = [1] Output: 1"
      }
    ]
  },
  {
    "problem_slug": "rectangle-area",
    "difficulty": "Medium",
    "topics": [
      "Math",
      "Geometry"
    ],
    "description": "Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles. The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2). The second rectangle is defined by its bottom-left corner (bx1, by1) and its top-right corner (bx2, by2). Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "-104 <= ax1 <= ax2 <= 104",
      "-104 <= ay1 <= ay2 <= 104",
      "-104 <= bx1 <= bx2 <= 104",
      "-104 <= by1 <= by2 <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2 Output: 45"
      },
      {
        "example_text": "Input: ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2 Output: 16"
      }
    ]
  },
  {
    "problem_slug": "basic-calculator",
    "difficulty": "Hard",
    "topics": [
      "Math",
      "String",
      "Stack",
      "Recursion"
    ],
    "description": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval(). Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 3 * 105",
      "s consists of digits, '+', '-', '(', ')', and ' '.",
      "s represents a valid expression.",
      "'+' is not used as a unary operation (i.e., \"+1\" and \"+(2 + 3)\" is invalid).",
      "'-' could be used as a unary operation (i.e., \"-1\" and \"-(2 + 3)\" is valid).",
      "There will be no two consecutive operators in the input.",
      "Every number and running calculation will fit in a signed 32-bit integer."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"1 + 1\" Output: 2"
      },
      {
        "example_text": "Input: s = \" 2-1 + 2 \" Output: 3"
      },
      {
        "example_text": "Input: s = \"(1+(4+5+2)-3)+(6+8)\" Output: 23"
      }
    ]
  },
  {
    "problem_slug": "implement-stack-using-queues",
    "difficulty": "Easy",
    "topics": [
      "Stack",
      "Design",
      "Queue"
    ],
    "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: Notes: Example 1: Constraints: Follow-up: Can you implement the stack using only one queue?",
    "solution": "",
    "constraints": [
      "1 <= x <= 9",
      "At most 100 calls will be made to push, pop, top, and empty.",
      "All the calls to pop and top are valid."
    ],
    "examples": [
      {
        "example_text": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False"
      }
    ]
  },
  {
    "problem_slug": "invert-binary-tree",
    "difficulty": "Easy",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, invert the tree, and return its root. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1]"
      },
      {
        "example_text": "Input: root = [2,1,3] Output: [2,3,1]"
      },
      {
        "example_text": "Input: root = [] Output: []"
      }
    ]
  },
  {
    "problem_slug": "basic-calculator-ii",
    "difficulty": "Medium",
    "topics": [
      "Math",
      "String",
      "Stack"
    ],
    "description": "Given a string s which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1]. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval(). Example 1: Example 2: Example 3: Constraints:",
    "solution": "Solution Overview There are multiple variations of this problem like [Basic Calculator](https://leetcode.com/problems/basic-calculator/) and [Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/). This problem is relatively simpler to solve, as we don't have to take care of the parenthesis. The aim is to evaluate the given mathematical expression by applying the basic mathematical rules. The expressions are evaluated from left to right and the order of evaluation depends on the [Operator Precedence](https://en.wikipedia.org/wiki/Order_of_operations). Let's understand how we could implement the problem using different approaches. Approach 1: Using Stack Intuition We know that there could be 4 types of operations - addition `(+)`, subtraction `(-)`, multiplication `(*)` and division `(/)`. Without parenthesis, we know that, multiplication `(*)` and `(\\)` operations would always have higher precedence than addition `(+)` and subtraction `(-)` based on operator precedence rules. ![img](../Figures/227/calculator_overview.png) If we look at the above examples, we can make the following observations - - If the current operation is addition `(+)` or subtraction `(-)`, then the expression is evaluated based on the precedence of the next operation. In example 1, `4+3` is evaluated later because the next operation is multiplication `(3*5)` which has higher precedence. But, in example 2, `4+3` is evaluated first because the next operation is subtraction `(3-5)` which has equal precedence. - If the current operator is multiplication `(*)` or division `(/)`, then the expression is evaluated irrespective of the next operation. This is because in the given set of operations `(+,-,*,/)`, the `*` and `/` operations have the highest precedence and therefore must be evaluated first. In the above examples 3 and 4, `4*3` is always evaluated first irrespective of the next operation. Using this intuition let's look at the algorithm to implement the problem. Algorithm Scan the input string `s` from left to right and evaluate the expressions based on the following rules 1) If the current character is a digit `0-9` ( operand ), add it to the number `currentNumber`. 2) Otherwise, the current character must be an operation `(+,-,*, /)`. Evaluate the expression based on the type of operation. - Addition `(+)` or Subtraction `(-)`: We must evaluate the expression later based on the next operation. So, we must store the `currentNumber` to be used later. Let's push the currentNumber in the Stack. >[Stack data structure](https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/) follows Last In First Out (LIFO) principle. Hence, the last pushed number in the stack would be popped out first for evaluation. In addition, when we pop from the stack and evaluate this expression in the future, we need a way to determine if the operation was Addition `(+)` or Subtraction `(-)`. To simplify our evaluation, we can push `-currentNumber` in a stack if the current operation is subtraction (`-`) and assume that the operation for all the values in the stack is addition `(+)`. This works because `(a - currentNumber)` is equivalent to `(a + (-currentNumber))`. - Multiplication `(*)` or Division `(/)`: Pop the top values from the stack and evaluate the current expression. Push the evaluated value back to the stack. Once the string is scanned, pop from the stack and add to the `result`. !?!../Documents/227_LIS.json:1414,716!?! Implementation Complexity Analysis * Time Complexity: \\mathcal{O}(n), where n is the length of the string s. We iterate over the string s at most twice. * Space Complexity: \\mathcal{O}(n), where n is the length of the string s. Approach 2: Optimised Approach without the stack Intuition In the previous approach, we used a stack to track the values of the evaluated expressions. In the end, we pop all the values from the stack and add to the result. Instead of that, we could add the values to the result beforehand and keep track of the last calculated number, thus eliminating the need for the stack. Let's understand the algorithm in detail. Algorithm The approach works similar to _Approach 1_ with the following differences : - Instead of using a `stack`, we use a variable `lastNumber` to track the value of the last evaluated expression. - If the operation is Addition `(+)` or Subtraction `(-)`, add the `lastNumber` to the result instead of pushing it to the stack. The `currentNumber` would be updated to `lastNumber` for the next iteration. - If the operation is Multiplication `(*)` or Division `(/)`, we must evaluate the expression `lastNumber * currentNumber` and update the `lastNumber` with the result of the expression. This would be added to the result after the entire string is scanned. Implementation Complexity Analysis * Time Complexity: \\mathcal{O}(n), where n is the length of the string s. * Space Complexity: \\mathcal{O}(1), as we use constant extra space to store `lastNumber`, `result` and so on.",
    "constraints": [
      "1 <= s.length <= 3 * 105",
      "s consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces.",
      "s represents a valid expression.",
      "All the integers in the expression are non-negative integers in the range [0, 231 - 1].",
      "The answer is guaranteed to fit in a 32-bit integer."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"3+2*2\" Output: 7"
      },
      {
        "example_text": "Input: s = \" 3/2 \" Output: 1"
      },
      {
        "example_text": "Input: s = \" 3+5 / 2 \" Output: 5"
      }
    ]
  },
  {
    "problem_slug": "summary-ranges",
    "difficulty": "Easy",
    "topics": [
      "Array"
    ],
    "description": "You are given a sorted unique integer array nums. A range [a,b] is the set of all integers from a to b (inclusive). Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums. Each range [a,b] in the list should be output as: Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "0 <= nums.length <= 20",
      "-231 <= nums[i] <= 231 - 1",
      "All the values of nums are unique.",
      "nums is sorted in ascending order."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [0,1,2,4,5,7] Output: [\"0->2\",\"4->5\",\"7\"] Explanation: The ranges are: [0,2] --> \"0->2\" [4,5] --> \"4->5\" [7,7] --> \"7\""
      },
      {
        "example_text": "Input: nums = [0,2,3,4,6,8,9] Output: [\"0\",\"2->4\",\"6\",\"8->9\"] Explanation: The ranges are: [0,0] --> \"0\" [2,4] --> \"2->4\" [6,6] --> \"6\" [8,9] --> \"8->9\""
      }
    ]
  },
  {
    "problem_slug": "majority-element-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Hash Table",
      "Sorting",
      "Counting"
    ],
    "description": "Given an integer array of size n, find all elements that appear more than  n/3  times. Example 1: Example 2: Example 3: Constraints: Follow up: Could you solve the problem in linear time and in O(1) space?",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 5 * 104",
      "-109 <= nums[i] <= 109"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [3,2,3] Output: [3]"
      },
      {
        "example_text": "Input: nums = [1] Output: [1]"
      },
      {
        "example_text": "Input: nums = [1,2] Output: [1,2]"
      }
    ]
  },
  {
    "problem_slug": "kth-smallest-element-in-a-bst",
    "difficulty": "Medium",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree. Example 1: Example 2: Constraints: Follow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is n.",
      "1 <= k <= n <= 104",
      "0 <= Node.val <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: root = [3,1,4,null,2], k = 1 Output: 1"
      },
      {
        "example_text": "Input: root = [5,3,6,2,4,null,null,1], k = 3 Output: 3"
      }
    ]
  },
  {
    "problem_slug": "power-of-two",
    "difficulty": "Easy",
    "topics": [
      "Math",
      "Bit Manipulation",
      "Recursion"
    ],
    "description": "Given an integer n, return true if it is a power of two. Otherwise, return false. An integer n is a power of two, if there exists an integer x such that n == 2x. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "-231 <= n <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: n = 1 Output: true Explanation: 20 = 1"
      },
      {
        "example_text": "Input: n = 16 Output: true Explanation: 24 = 16"
      },
      {
        "example_text": "Input: n = 3 Output: false"
      }
    ]
  },
  {
    "problem_slug": "implement-queue-using-stacks",
    "difficulty": "Easy",
    "topics": [
      "Stack",
      "Design",
      "Queue"
    ],
    "description": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: Notes: Example 1: Constraints: Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer.",
    "solution": "Summary This article is for beginners. It introduces the following ideas: Queue, Stack. Solution Queue is FIFO (first in - first out) data structure, in which the elements are inserted from one side - `rear` and removed from the other - `front`. The most intuitive way to implement it is with linked lists, but this article will introduce another approach using stacks. Stack is LIFO (last in - first out) data structure, in which elements are added and removed from the same end, called `top`. To satisfy FIFO property of a queue we need to keep two stacks. They serve to reverse arrival order of the elements and one of them store the queue elements in their final order. Approach 1 (Two Stacks) Push - $O(n)$ per operation, Pop - $O(1)$ per operation. Push A queue is FIFO (first-in-first-out) but a stack is LIFO (last-in-first-out). This means the newest element must be pushed to the bottom of the stack. To do so we first transfer all `s1` elements to auxiliary stack `s2`. Then the newly arrived element is pushed on top of `s2` and all its elements are popped and pushed to `s1`. ![Push an element in queue](https://leetcode.com/media/original_images/232_queue_using_stacksBPush.png){:width=\"539px\"} *Figure 1. Push an element in queue* Complexity Analysis * Time complexity : $O(n)$. Each element, with the exception of the newly arrived, is pushed and popped twice. The last inserted element is popped and pushed once. Therefore this gives $4 n + 2$ operations where $n$ is the queue size. The `push` and `pop` operations have $O(1)$ time complexity. * Space complexity : $O(n)$. We need additional memory to store the queue elements Pop The algorithm pops an element from the stack `s1`, because `s1` stores always on its top the first inserted element in the queue. The front element of the queue is kept as `front`. ![Pop an element from queue](https://leetcode.com/media/original_images/232_queue_using_stacksBPop.png){:width=\"539px\"} *Figure 2. Pop an element from queue* Complexity Analysis * Time complexity : $O(1)$. * Space complexity : $O(1)$. Empty Stack `s1` contains all stack elements, so the algorithm checks `s1` size to return if the queue is empty. Complexity Analysis * Time complexity : $O(1)$. * Space complexity : $O(1)$. Peek The `front` element is kept in constant memory and is modified when we push or pop an element. Complexity Analysis * Time complexity : $O(1)$. The `front` element has been calculated in advance and only returned in `peek` operation. * Space complexity : $O(1)$. Approach 2 (Two Stacks) Push - $O(1)$ per operation, Pop - Amortized $O(1)$ per operation. Push The newly arrived element is always added on top of stack `s1` and the first element is kept as `front` queue element ![Push an element in queue](https://leetcode.com/media/original_images/232_queue_using_stacksAPush.png){:width=\"539px\"} *Figure 3. Push an element in queue* Complexity Analysis * Time complexity : $O(1)$. ppending an element to a stack is an O(1) operation. * Space complexity : $O(n)$. We need additional memory to store the queue elements Pop We have to remove element in front of the queue. This is the first inserted element in the stack `s1` and it is positioned at the bottom of the stack because of stack's `LIFO (last in - first out)` policy. To remove the bottom element from `s1`, we have to pop all elements from `s1` and to push them on to an additional stack `s2`, which helps us to store the elements of `s1` in reversed order. This way the bottom element of `s1` will be positioned on top of `s2` and we can simply pop it from stack `s2`. Once `s2` is empty, the algorithm transfer data from `s1` to `s2` again. ![Pop an element from stack](https://leetcode.com/media/original_images/232_queue_using_stacksAPop.png){:width=\"539px\"} *Figure 4. Pop an element from stack* Complexity Analysis * Time complexity: Amortized $O(1)$, Worst-case $O(n)$. In the worst case scenario when stack `s2` is empty, the algorithm pops $n$ elements from stack s1 and pushes $n$ elements to `s2`, where $n$ is the queue size. This gives $2n$ operations, which is $O(n)$. But when stack `s2` is not empty the algorithm has $O(1)$ time complexity. So what does it mean by Amortized $O(1)$? Please see the next section on Amortized Analysis for more information. * Space complexity : $O(1)$. Amortized Analysis Amortized analysis gives the average performance (over time) of each operation in the worst case. The basic idea is that a worst case operation can alter the state in such a way that the worst case cannot occur again for a long time, thus amortizing its cost. Consider this example where we start with an empty queue with the following sequence of operations applied: push_1, push_2, \\ldots, push_n, pop_1,pop_2 \\ldots, pop_n The worst case time complexity of a single pop operation is $O(n)$. Since we have $n$ pop operations, using the worst-case per operation analysis gives us a total of $O(n^2)$ time. However, in a sequence of operations the worst case does not occur often in each operation - some operations may be cheap, some may be expensive. Therefore, a traditional worst-case per operation analysis can give overly pessimistic bound. For example, in a dynamic array only some inserts take a linear time, though others - a constant time. In the example above, the number of times pop operation can be called is limited by the number of push operations before it. Although a single pop operation could be expensive, it is expensive only once per `n` times (queue size), when `s2` is empty and there is a need for data transfer between `s1` and `s2`. Hence the total time complexity of the sequence is : `n` (for push operations) + `2*n` (for first pop operation) + `n - 1` ( for pop operations) which is $O(2*n)$.This gives $O(2n/2n)$ = $O(1)$ average time per operation. Empty Both stacks `s1` and `s2` contain all stack elements, so the algorithm checks `s1` and `s2` size to return if the queue is empty. Complexity Analysis * Time complexity : $O(1)$. * Space complexity : $O(1)$. Peek The `front` element is kept in constant memory and is modified when we push an element. When `s2` is not empty, front element is positioned on the top of `s2` Complexity Analysis * Time complexity : $O(1)$. The `front` element was either previously calculated or returned as a top element of stack `s2`. Therefore complexity is $O(1)$ * Space complexity : $O(1)$.",
    "constraints": [
      "1 <= x <= 9",
      "At most 100 calls will be made to push, pop, peek, and empty.",
      "All the calls to pop and peek are valid."
    ],
    "examples": [
      {
        "example_text": "Input [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false"
      }
    ]
  },
  {
    "problem_slug": "number-of-digit-one",
    "difficulty": "Hard",
    "topics": [
      "Math",
      "Dynamic Programming",
      "Recursion"
    ],
    "description": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example 1: Example 2: Constraints:",
    "solution": "Solution Approach 1 Brute force [Time Limit Exceeded] Intuition Do as directed in question. Algorithm * Iterate over i from 1 to n: + Convert i to string and count \\text{'1'} in each integer string + Add count of \\text{'1'} in each string to the sum, say countrComplexity Analysis * Time complexity: O(n*log_{10}(n)). + We iterate from 1 to n + In each iteration, we convert integer to string and count '1' in string which takes linear time in number of digits in i, which is log_{10}(n). * Space complexity: O(log_{10}(n)) Extra space for the countr and the converted string \\text{str}. Approach 2 Solve it mathematically [Accepted] Intuition In Approach 1, we manually calculated the number of all the '1's in the digits, but this is very slow. Hence, we need a way to find a pattern in the way '1's (or for that matter any digit) appears in the numbers. We could then use the pattern to formulate the answer. Consider the 1s in \\text{ones} place , \\text{tens} place, \\text{hundreds} place and so on... An analysis has been performed in the following figure. ![Number of digit one](../Figures/233/number_of_digit_one.png){:width=\"800px\"} From the figure, we can see that from digit '1' at \\text{ones} place repeat in group of 1 after interval of 10. Similarly, '1' at \\text{tens} place repeat in group of 10 after interval of 100. This can be formulated as (n/(i*10))*i. Also, notice that if the digit at \\text{tens} place is \\text{'1'}, then the number of terms with \\text{'1's} is increased by x+1, if the number is say \\text{\"ab1x\"}. As if digits at \\text{tens} place is greater than 1, then all the 10 occurances of numbers with '1' at \\text{tens} place have taken place, hence, we add 10. This is formluated as {\\min(\\max((\\text{n mod (i*10)} )-i+1,0),i)}. Lets take an example, say n= 1234. No of \\text{'1'} in \\text{ones} place = 1234/10(corresponding to 1,11,21,...1221) + \\min(4,1)(corresponding to 1231) =124 No of \\text{'1'} in \\text{tens} place = (1234/100)*10(corresponding to 10,11,12,...,110,111,...1919) +\\min(21,10)(corresponding to 1210,1211,...1219)=130 No of \\text{'1'} in \\text{hundreds} place = (1234/1000)*100(corresponding to 100,101,12,...,199) +\\min(135,100)(corresponding to 1100,1101...1199)=200 No of \\text{'1'} in \\text{thousands} place = (1234/10000)*10000 +\\min(235,1000)(corresponding to 1000,1001,...1234)=235 Therefore, Total = 124+130+200+235 = 689. Herein, one formula has been devised, but many other formulae can be devised for faster implementations, but the essence and complexity remains the same. The users are encouraged to try to devise their own version of solution using the mathematical concepts. Algorithm * Iterate over i from 1 to n incrementing by 10 each time: - Add (n/(i*10))*i to \\text{countr} representing the repetition of groups of i sizes after each (i*10) interval. - Add {\\min(\\max((\\text{n mod (i*10)} )-i+1,0),i)} to \\text{countr} representing the additional digits dependant on the digit in ith place as described in intuition.Complexity analysis * Time complexity: O(log_{10}(n)). + No of iterations equal to the number of digits in n which is log_{10}(n) * Space complexity: O(1) space required.",
    "constraints": [
      "0 <= n <= 109"
    ],
    "examples": [
      {
        "example_text": "Input: n = 13 Output: 6"
      },
      {
        "example_text": "Input: n = 0 Output: 0"
      }
    ]
  },
  {
    "problem_slug": "palindrome-linked-list",
    "difficulty": "Easy",
    "topics": [
      "Linked List",
      "Two Pointers",
      "Stack",
      "Recursion"
    ],
    "description": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the list is in the range [1, 105].",
      "0 <= Node.val <= 9"
    ],
    "examples": [
      {
        "example_text": "Input: head = [1,2,2,1] Output: true"
      },
      {
        "example_text": "Input: head = [1,2] Output: false"
      }
    ]
  },
  {
    "problem_slug": "lowest-common-ancestor-of-a-binary-search-tree",
    "difficulty": "Medium",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Binary Search Tree",
      "Binary Tree"
    ],
    "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST. According to the definition of LCA on Wikipedia: The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself). Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [2, 105].",
      "-109 <= Node.val <= 109",
      "All Node.val are unique.",
      "p != q",
      "p and q will exist in the BST."
    ],
    "examples": [
      {
        "example_text": "Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6."
      },
      {
        "example_text": "Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition."
      },
      {
        "example_text": "Input: root = [2,1], p = 2, q = 1 Output: 2"
      }
    ]
  },
  {
    "problem_slug": "lowest-common-ancestor-of-a-binary-tree",
    "difficulty": "Medium",
    "topics": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself). Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [2, 105].",
      "-109 <= Node.val <= 109",
      "All Node.val are unique.",
      "p != q",
      "p and q will exist in the tree."
    ],
    "examples": [
      {
        "example_text": "Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3."
      },
      {
        "example_text": "Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition."
      },
      {
        "example_text": "Input: root = [1,2], p = 1, q = 2 Output: 1"
      }
    ]
  },
  {
    "problem_slug": "delete-node-in-a-linked-list",
    "difficulty": "Medium",
    "topics": [
      "Linked List"
    ],
    "description": "There is a singly-linked list head and we want to delete a node node in it. You are given the node to be deleted node. You will not be given access to the first node of head. All the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list. Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean: Custom testing: Example 1: Example 2: Constraints:",
    "solution": "Solution Overview To delete a node from a linked list, we typically redirect the previous node's `next` pointer to the subsequent node of the one being deleted. For example, to remove node 3 from a linked list, we would adjust node 2's `next` pointer to reference node 4 directly. This effectively excludes node 3 from the traversal path, rendering it inaccessible during iteration, and thus, it is considered deleted. ![initial_linkedlist](../Documents/237/237-Page-1.svg) ![changing_pointers](../Documents/237/237-Page-2.svg)However, a challenge arises when we cannot access the previous node, as is the case in this specific problem. Since we can only traverse forward from the node to be deleted, the conventional deletion method is not feasible. Key Observations: - We've been presented with a scenario where we can't access the entire linked list structure, forcing us to devise a strategy that works within those limitations. - This problem goes beyond rote memorization of DSA techniques. It emphasizes the importance of creative thinking under limitations. It highlights the assessment of the candidate's problem-solving approach. Approach: Data Overwriting Intuition To circumvent this limitation, we can employ an alternative strategy. By comparing the original linked list with the desired outcome post-deletion, we notice that the nodes following the target node appear to shift one position to the left. ![initial_linkedlist](../Documents/237/237-Page-3.svg) ![after_deletion](../Documents/237/237-Page-4.svg)We can replicate this effect by copying the data from each subsequent node into its predecessor, starting from the node to be deleted, and then unlinking the last node. ![overwrite_linkedlist](../Documents/237/237-Page-5.svg) ![after_overwrite](../Documents/237/237-Page-6.svg)This approach can be further optimized. Instead of shifting the data of all subsequent nodes, we only need to overwrite the data of the node to be deleted with that of its immediate successor. Subsequently, we update the `next` pointer of the node to be deleted to point to the successor's next node. This effectively removes the successor node, achieving the desired result with minimal operations. ![overwrite_linkedlist](../Documents/237/237-Page-7.svg) ![after_overwrite_1_node](../Documents/237/237-Page-8.svg) Let's take a simpler example to understand this approach. Imagine the linked list as a train with connected cars (nodes). We want to remove a specific car (target node), but the conductor (you) can only access the current car and not the engine (head). By shifting all passengers from current car (\"overwriting\" the data of the current node) with the data from the next car, and then connecting the current car to the car after the next (skipping the unwanted car), we achieve the deletion effect. Note: This method will not work if we need to delete the last node of the linked list since there is no immediate successor. However, the problem description explicitly states that the node to be deleted is not the tail node in the list. Algorithm 1. Copy the data from the successor node into the current node to be deleted. 2. Update the `next` pointer of the current node to reference the `next` pointer of the successor node. Implementation Complexity Analysis * Time Complexity: $O(1)$ - The method involves a constant number of operations: updating the data of the current node and altering its `next` pointer. Each of these operations requires a fixed amount of time, irrespective of the size of the linked list. * Space Complexity: $O(1)$ - This deletion technique does not necessitate any extra memory allocation, as it operates directly on the existing nodes without creating additional data structures.",
    "constraints": [
      "The number of the nodes in the given list is in the range [2, 1000].",
      "-1000 <= Node.val <= 1000",
      "The value of each node in the list is unique.",
      "The node to be deleted is in the list and is not a tail node."
    ],
    "examples": [
      {
        "example_text": "Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function."
      },
      {
        "example_text": "Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function."
      }
    ]
  },
  {
    "problem_slug": "product-of-array-except-self",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Prefix Sum"
    ],
    "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: Example 2: Constraints: Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)",
    "solution": "",
    "constraints": [
      "2 <= nums.length <= 105",
      "-30 <= nums[i] <= 30",
      "The input is generated such that answer[i] is guaranteed to fit in a 32-bit integer."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,2,3,4] Output: [24,12,8,6]"
      },
      {
        "example_text": "Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0]"
      }
    ]
  },
  {
    "problem_slug": "sliding-window-maximum",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Queue",
      "Sliding Window",
      "Heap (Priority Queue)",
      "Monotonic Queue"
    ],
    "description": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 105",
      "-104 <= nums[i] <= 104",
      "1 <= k <= nums.length"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max -- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7"
      },
      {
        "example_text": "Input: nums = [1], k = 1 Output: [1]"
      }
    ]
  },
  {
    "problem_slug": "search-a-2d-matrix-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Binary Search",
      "Divide and Conquer",
      "Matrix"
    ],
    "description": "Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= n, m <= 300",
      "-109 <= matrix[i][j] <= 109",
      "All the integers in each row are sorted in ascending order.",
      "All the integers in each column are sorted in ascending order.",
      "-109 <= target <= 109"
    ],
    "examples": [
      {
        "example_text": "Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 Output: true"
      },
      {
        "example_text": "Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20 Output: false"
      }
    ]
  },
  {
    "problem_slug": "different-ways-to-add-parentheses",
    "difficulty": "Medium",
    "topics": [
      "Math",
      "String",
      "Dynamic Programming",
      "Recursion",
      "Memoization"
    ],
    "description": "Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order. The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 104. Example 1: Example 2: Constraints:",
    "solution": "Solution Overview We are given a string `expression` containing: 1. Numbers from 0 - 99. 2. Operators (+, -, *) Our task is to determine all possible results obtainable by grouping the numbers and operators in various ways. Approach 1: Recursion Intuition When we add parentheses to an expression, they group parts of the expression, telling us to evaluate those parts first. To decide where to place these parentheses, we look at each operator in the expression. Each operator offers a chance to split the expression into two smaller parts: everything before the operator and everything after it. These smaller parts are similar to our original problem, so we use recursion to solve them. We start by defining our base cases, where we can return a result without further recursion: 1. If the expression is empty, return an empty list. 2. If the expression is a single digit, return a list with that number. 3. If the expression has two characters and the first is a digit, the second must also be a digit. We convert the expression to a number and return it in a list. For longer expressions, we find operators to split the expression. We iterate through each character, and when we find an operator, we recursively evaluate the parts before and after it. We store the results of these evaluations in separate lists. Then, we combine the results from the left and right parts using the operator and store the final values in a list. Heres a visual example of how a recursion subtree might look: ![](../Figures/241/subtree.png) By the end of the process, the `results` list will contain all possible results from grouping the numbers and operators in the expression. Algorithm - Initialize a list `results` to store the possible outcomes. - If the input string is empty, return the empty `results` list. - Check if `expression` is a single character: - If so, convert it to an integer and add it to `results`. - Return `results`. - Check if `expression` has only two characters and starts with a digit: - If so, convert the entire string to an integer and add it to `results`. - Return `results`. - Iterate through each character of `expression`: - Set the current character as `currentChar`. - If `currentChar` is a digit, continue to the next iteration. - Recursively call `diffWaysToCompute` for the left part of `expression` (from indices `0` to `i-1`) and set it to a list `leftResults`. - Recursively call `diffWaysToCompute` for the right part of `expression` (from indices `i+1` to the end) and set it to a list `rightResults`. - Iterate through `leftValue` in `leftResults`: - For each `leftValue`, iterate through each `rightValue` in the `rightResults`: - Initialize a variable `computedResult` to store the result of the current operation. - Perform the operation (addition, subtraction, or multiplication) based on the current character. - Add the `computedResult` to the `results` list. - Return `results` as our answer. Implementation Complexity Analysis Let $n$ be the the length of the input string `expression`. - Time complexity: $O(n \\cdot 2^n)$ For each sub-expression, we iterate through the string to identify the operators, which takes $O(n)$ time. However, the key aspect is the recursive combination of results from the left and right sub-expressions. The number of results grows exponentially because each sub-expression produces multiple results, and combining these results takes $O(k \\times l)$, where $k$ and $l$ are the numbers of results from the left and right sub-problems, respectively. There were some suggestions to model the number of results using Catalan numbers which we deemed as incorrect. Catalan numbers apply when counting distinct ways to fully parenthesize an expression or structure. In this problem, however, we're not just counting valid ways to split the expression but also calculating and combining all possible results. This introduces exponential growth in the number of possible results, not the polynomial growth typical of Catalan numbers. The number of combinations grows exponentially with the depth of recursive splitting, which means the overall complexity is driven by the exponential growth in results. Thus, the time complexity of the algorithm is $O(n \\cdot 2^n)$, where the $O(2^n)$ factor reflects the exponential growth in the number of ways to combine results from sub-expressions. - Space complexity: $O(2^n)$ The algorithm stores the intermediate results at each step. Since the total number of results can be equal to the $O(2^n)$, the space complexity of the algorithm is $O(2^n)$. Approach 2: Memoization Intuition When dealing with complex expressions, we often find ourselves repeating the same calculations. Take the expression `2 + 2 - 2 - 2 - 2`. You could group it in different ways: 1. `((2 + 2) - (2 - 2) - 2)` 2. `((2 + 2) - 2 - (2 - 2))` As you can see, the sub-expression (2 + 2) is evaluated more than once. To avoid this, we can store the results of these sub-calculations. This way, if we hit the same sub-problem again, we can use the stored result instead of recalculating it, which speeds things up. Another issue with the previous method was that it repeatedly created substrings of the expression. Since creating a substring takes $O(n)$ time, where $n$ is the length of the string, this can be quite slow. Instead, well pass the entire `expression` to each recursive call and use `start` and `end` indices to specify the part we're interested in. This avoids the costly substring operations. In our updated approach, each state in the recursion is defined by the `start` and `end` indices. We use a 2D array for memoization, where each cell `memo[i][j]` holds the list of possible results for the sub-expression from index `i` to index `j`. > Note: There is an alternative way to apply memoization in this problem. Consider the expression \"2-2-2\". This can be grouped in two ways: `(2 - 2) - 2` and `2 - (2 - 2)`. As you can see, the expression \"2 - 2\" is being evaluated repeatedly, even though the instances do not share the same indices. > > To memoize this, we need to store the substring itself as the state of the sub-problem. This can be achieved by using a map with the substring as the key and the list of results as the value. Whenever we encounter the same substring, we can return the result from the map. > > While this approach leads us to identify and cache more sub-problems, it forces us to use substrings in our recursion. In an interview setting, you can highlight both approaches and discuss their advantages and disadvantages for extra credit. Algorithm Main method `diffWaysToCompute`: - Initialize a 2D array `memo` to store computed results for sub-expressions. - Call the `computeResults` method with the full expression range and return the result. Helper method `computeResults(expression, memo, start, end)`: - Check if the result for the range `[start, end]` is memoized. If so, return the memoized result. - Initialize a list `results` to store computed values for the current sub-expression. - Check if the current range is a single digit: - - If so, convert `expression` to an integer and add it to `results`. - Return `results`. - Check if the current range is a two-digit number: - If so, compute its value and add it to `results`. - Return `results`. - Iterate through each character in the current range of the expression: - Skip the current iteration if the character is a digit. - Recursively call `computeResults` for the left part of the expression up to the current character (from `start` to `i-1`). Store the result in `leftResults`. - Recursively call `computeResults` for the right part of the expression after the current character (from `i+1` to `end`). Store the result in `rightResults`. - Iterate through each `leftValue` in the `leftResults`: - For each `leftValue`, iterate through each `rightValue` in `rightResults`: - Perform the operation (addition, subtraction, or multiplication) based on the current character. - Add the computed result to the `results` list. - Store the result in `memo` for the range `[start, end]`. - Return the `results` list. Implementation Complexity Analysis Let $n$ be the the length of the input string `expression`. * Time complexity: $O(n \\cdot 2^n)$ The algorithm uses memoization to store the results of sub-problems, ensuring that each sub-problem is evaluated exactly once. There are at most $O(n^2)$ possible sub-problems, as each sub-problem is defined by its start and end indices, both ranging from $0$ to $n-1$. Despite the efficiency gains from memoization, the time complexity is still dominated by the recursive nature of the algorithm. The recursion tree expands exponentially, with a growth factor of $O(2^n)$. Thus, the overall time complexity remains $O(n \\cdot 2^n)$. * Space complexity: $O(n^2 \\cdot 2^n)$ The space complexity is $O(n^2 \\cdot 2^n)$, where $O(n^2)$ comes from the memoization table storing results for all sub-problems, and $O(2^n)$ accounts for the space required to store the exponentially growing number of results for each sub-problem. The recursion stack depth is at most $O(n)$, which is dominated by the exponential complexity and can therefore be omitted from the overall space complexity analysis. Approach 3: Tabulation Intuition Recursive solutions can use up a lot of stack space, which might lead to stack overflow errors. To avoid this, we'll switch to an iterative approach and build our solution step by step. Well use a 2-D array, called `dp`, to keep track of intermediate results. This table will have dimensions `n x n`, where `n` is the length of our input `expression`. Each cell `dp[i][j]` will store all possible results for the sub-expression starting at index `i` and ending at index `j`. For instance, `dp[0][2]` will hold all possible results for the first three characters of the expression. First, we need to fill in our base cases. We loop through the `expression` to identify all single-digit and double-digit numbers. 1. For single-digit numbers, add the digit's value to `dp[i][i]`. 2. For double-digit numbers, add the number's value to `dp[i][i+1]`. Next, we handle longer sub-expressions. We start with lengths of 3 and go up to the length of the `expression`. For each length, we consider all possible starting points in the expression. This double loop structure ensures we consider all possible substrings of `expression`. For each sub-expression, we try different ways to split it. We go through each character and, when we find an operator, split the expression at that point. We then combine the results from the left and right parts using the operator. After we've filled our entire `dp` table, the cell `dp[0][n-1]` contains all possible results for the entire expression. We can return this list as our final answer. Algorithm Main method `diffWaysToCompute`: - Initialize a variable `n` to store the length of the input string `expression`. - Create a 2D array `dp` of lists to store the results of sub-problems. - Initialize the base cases using the `initializeBaseCases` method. - Iterate through all possible sub-expression lengths, starting from `3` up to `n`. - For each length, iterate through all possible `start` positions of the sub-expression. - Set `end` as `start + length - 1`. - Calculate the results for the sub-expression `[start, end]` using the `processSubexpression` method. - Return `dp[0][n-1]`, which contains all possible results for the entire `expression`. Helper method `initializeBaseCases(expression, dp)`: - Initialize the `dp` array. - Handle base cases by iterating through the `expression`: - For single digits, add the digit value to `dp[i][i]`. - For two-digit numbers, add the number value to `dp[i][i+1]`. Helper method `processSubexpression(expression, dp, start, end)`: - Try all possible `split` positions from `start` to `end`: - If the character is numeric, continue to the next iteration - If not, retrieve the results of the left sub-expression from `dp[start][split-1]` and assign it to `leftResults`. - Retrieve the results of the right sub-expression from `dp[split+1][end]` and assign it to `rightResults`. - Call `computeResults` with `leftResults`, `rightResults`, and the operator at the `split` position. Helper method `computeResults(op, leftResults, rightResults, results)`: - For each combination of `leftResults` and `rightResults`: - Perform the operation specified by `op`. - Add the result to `results`. Implementation Complexity Analysis Let $n$ be the the length of the input string `expression`. * Time complexity: $O(n \\cdot 2^n)$ Similar to the memoization approach, the algorithm evaluates each sub-problem exactly once. Thus, the time complexity remains the same as Approach 2: $O(n \\cdot 2^n)$. * Space complexity: $O(n^2 \\cdot 2^n)$ The space complexity is similar to the previous approach, with one key difference: the absence of the recursive stack space. However, the `dp` table dominates the space complexity anyway, keeping the overall space complexity as $O(n^2 \\cdot 2^n)$.",
    "constraints": [
      "1 <= expression.length <= 20",
      "expression consists of digits and the operator '+', '-', and '*'.",
      "All the integer values in the input expression are in the range [0, 99].",
      "The integer values in the input expression do not have a leading '-' or '+' denoting the sign."
    ],
    "examples": [
      {
        "example_text": "Input: expression = \"2-1-1\" Output: [0,2] Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2"
      },
      {
        "example_text": "Input: expression = \"2*3-4*5\" Output: [-34,-14,-10,-10,10] Explanation: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10"
      }
    ]
  },
  {
    "problem_slug": "valid-anagram",
    "difficulty": "Easy",
    "topics": [
      "Hash Table",
      "String",
      "Sorting"
    ],
    "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise. Example 1: Example 2: Constraints: Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?",
    "solution": "",
    "constraints": [
      "1 <= s.length, t.length <= 5 * 104",
      "s and t consist of lowercase English letters."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"anagram\", t = \"nagaram\" Output: true"
      },
      {
        "example_text": "Input: s = \"rat\", t = \"car\" Output: false"
      }
    ]
  },
  {
    "problem_slug": "binary-tree-paths",
    "difficulty": "Easy",
    "topics": [
      "String",
      "Backtracking",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "description": "Given the root of a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: root = [1,2,3,null,5] Output: [\"1->2->5\",\"1->3\"]"
      },
      {
        "example_text": "Input: root = [1] Output: [\"1\"]"
      }
    ]
  },
  {
    "problem_slug": "add-digits",
    "difficulty": "Easy",
    "topics": [
      "Math",
      "Simulation",
      "Number Theory"
    ],
    "description": "Given an integer num, repeatedly add all its digits until the result has only one digit, and return it. Example 1: Example 2: Constraints: Follow up: Could you do it without any loop/recursion in O(1) runtime?",
    "solution": "",
    "constraints": [
      "0 <= num <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: num = 38 Output: 2 Explanation: The process is 38 --> 3 + 8 --> 11 11 --> 1 + 1 --> 2 Since 2 has only one digit, return it."
      },
      {
        "example_text": "Input: num = 0 Output: 0"
      }
    ]
  },
  {
    "problem_slug": "single-number-iii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Bit Manipulation"
    ],
    "description": "Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order. You must write an algorithm that runs in linear runtime complexity and uses only constant extra space. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "2 <= nums.length <= 3 * 104",
      "-231 <= nums[i] <= 231 - 1",
      "Each integer in nums will appear twice, only two integers will appear once."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,2,1,3,2,5] Output: [3,5] Explanation: [5, 3] is also a valid answer."
      },
      {
        "example_text": "Input: nums = [-1,0] Output: [-1,0]"
      },
      {
        "example_text": "Input: nums = [0,1] Output: [1,0]"
      }
    ]
  },
  {
    "problem_slug": "trips-and-users",
    "difficulty": "Hard",
    "topics": [
      "Database"
    ],
    "description": "Table: Trips Table: Users The cancellation rate is computed by dividing the number of canceled (by client or driver) requests with unbanned users by the total number of requests with unbanned users on that day. Write a solution to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between \"2013-10-01\" and \"2013-10-03\" with at least one trip. Round Cancellation Rate to two decimal points. Return the result table in any order. The result format is in the following example. Example 1:",
    "solution": "Solution Overview Calculate the daily cancellation rate for taxi trip requests made by unbanned users between \"2013-10-01\" and \"2013-10-03\". The cancellation rate for a day is the number of canceled trips (either by client or driver) divided by the total number of trips requested by unbanned users. Visualized Output ![fig](../Figures/262/262.png) Tables and Fields 1. Trips: The table holds all taxi trips. - Fields: `id`, `client_id`, `driver_id`, `status`, `request_at` - We are interested in the `client_id`, `driver_id`, `status`, and `request_at` columns. 2. Users: The table holds all users. - Fields: id, client_id, driver_id, status, request_at - The `users_id` and `banned` columns are essential to filter out banned users. Relationships 1. `Trips.client_id` = `Users.users_id` 2. `Trips.driver_id` = `Users.users_id` pandas Approach 1: DataFrame Merging Intuition The algorithm merges trip information with user details, filters out trips with banned users and those outside a specific date range, and then calculates the daily cancellation rate for the selected trips. Algorithm 1. Preliminary Check: - Check if either the `trips` or `users` DataFrame is empty. - If either is empty, return a DataFrame with \"Day\" and \"Cancellation Rate\" columns. 2. Prepare Data for Client Merge: - Adjust the `users` DataFrame column names for clarity: - Rename `users_id` to `client_id`. - Rename `banned` to `client_banned`.client_idclient_bannedrole1Noclient2Yesclient3Noclient4Noclient3. Client Merge: - Merge `trips` with the modified `users` DataFrame using `client_id`. - Use a left merge to ensure retention of all trip records. - The outcome is the `trips_with_clients` DataFrame.idclient_iddriver_idcity_idstatusrequest_atclient_bannedrole11101completed2013-10-01Noclient22111cancelled_by_driver2013-10-01Yesclient4. Prepare Data for Driver Merge: - Modify column names in the `users` DataFrame to differentiate drivers: - Change `users_id` to `driver_id`. - Adjust `banned` to `driver_banned`.driver_iddriver_bannedrole10Nodriver11Nodriver12Nodriver13Nodriver5. Driver Merge: - Combine `trips_with_clients` with the modified `users` DataFrame based on `driver_id`. - Utilize a left merge once more. - The final merged data is stored as `full_trips`.idclient_iddriver_idcity_idstatusrequest_atclient_bannedclient_roledriver_banneddriver_role11101completed2013-10-01NoclientNodriver22111cancelled_by_driver2013-10-01YesclientNodriver6. Filtering: - Apply boolean indexing to `full_trips` to: - Omit entries with banned clients or drivers. - Retain rows where the `request_at` date falls between '2013-10-01' and '2013-10-03'. - The filtered data is saved as `filtered_trips`.idclient_iddriver_idcity_idstatusrequest_atclient_bannedclient_roledriver_banneddriver_role11101completed2013-10-01NoclientNodriver7. Calculate Cancellation Rate: - Group `filtered_trips` by the `request_at` column. - Within each group, determine the cancellation rate, which is the proportion of trips not marked as 'completed'. - Round the result to two decimal places.request_atCancellation Rate2013-10-010.332013-10-020.002013-10-030.508. Result Presentation: - If the computed result is empty after determining the cancellation rate, output an empty DataFrame with \"Day\" and \"Cancellation Rate\" columns. - Otherwise, reset the index of the result and rename the `request_at` column as \"Day\".DayCancellation Rate2013-10-010.332013-10-020.002013-10-030.50 Implementation Based on the understanding above, the solution can be implemented as: Approach 2: Utilizing Intermediate DataFrames Intuition The key idea here is to pinpoint the undesirable rows (or indices) and then discard them. Use boolean indexing to spot rows in the `users` DataFrame representing banned users. Subsequently, with the `isin` method, eliminate rows in the `trips` DataFrame associated with these users. Essentially, this method is about tagging certain rows or indices as \"unwanted\" and then bypassing them in the main operation. Algorithm 1. Data Verification: - Check if either `trips` or `users` DataFrames are empty. - If so, return a DataFrame with columns \"Day\" and \"Cancellation Rate\" without any data. 2. Isolating Banned Users: - Use boolean indexing on the `users` DataFrame to extract the IDs (`users_id`) of users who are banned. 3. Filtering Relevant Trip Data: - Discard rows from the `trips` DataFrame with `client_id` or `driver_id` matching the IDs of banned users. - Retain rows in the `trips` DataFrame with `request_at` dates from '2013-10-01' to '2013-10-03'. 4. Aggregating Data: - Group data in the `selected_trips` DataFrame by the `request_at` column. - For each group, compute the cancellation rate by finding the ratio of non-completed trips to the total trips, rounded to two decimal places. 5. Result Compilation: - If `aggregated_result` DataFrame isn't empty, reset its index and rename the `request_at` column to 'Date'. - If it's empty, return a DataFrame with columns \"Date\" and \"Cancellation Rate\" without any data. Implementation Based on the understanding above, the solution can be implemented as: ```python import pandas as pd def trips_and_users(trips: pd.DataFrame, users: pd.DataFrame) -> pd.DataFrame: Step 1: Data Verification Check if either `trips` or `users` DataFrames are empty. If so, return a DataFrame with columns \"Day\" and \"Cancellation Rate\" without any data. if trips.empty or users.empty: return pd.DataFrame(columns=[\"Day\", \"Cancellation Rate\"]) Step 2: Isolating Banned Users Using boolean indexing on the `users` DataFrame, extract the IDs (`users_id`) of users who are banned. banned_users_ids = users[users[\"banned\"] == \"Yes\"][\"users_id\"] Step 3: Filtering Relevant Trip Data Remove rows from `trips` DataFrame that have `client_id` or `driver_id` matching the IDs of banned users. Retain rows in the `trips` DataFrame that have `request_at` dates within the range of '2013-10-01' to '2013-10-03'. selected_trips = trips[ (~trips[\"client_id\"].isin(banned_users_ids)) & (~trips[\"driver_id\"].isin(banned_users_ids)) & (trips[\"request_at\"].between(\"2013-10-01\", \"2013-10-03\")) ] Step 4: Aggregating Data Group the data in the `selected_trips` DataFrame based on the `request_at` column. For each group, calculate the cancellation rate by determining the ratio of non-completed trips to the total number of trips, rounding to two decimal places. aggregated_result = selected_trips.groupby(\"request_at\").apply( lambda group: pd.Series( { \"Cancellation Rate\": round( (group[\"status\"] != \"completed\").sum() / len(group), 2 ) } ) ) Step 5: Result Compilation If the `aggregated_result` DataFrame isn't empty, reset its index and rename the `request_at` column to 'Date'. If it's empty, return a DataFrame with columns \"Date\" and \"Cancellation Rate\" without any data. if aggregated_result.empty: return pd.DataFrame(columns=[\"Day\", \"Cancellation Rate\"]) else: return aggregated_result.reset_index().rename(columns={\"request_at\": \"Day\"}) ``` Approach 3: DataFrame Transformations (Common Table Expression Equivalent) Intuition The idea is to filter out trips outside of the three-day window and those involving banned users. The cancellation status of trips is simplified into binary values for easy computation. Data is grouped by day to provide granular insights, and the results are structured for clarity, offering a straightforward representation of daily cancellation rates. Algorithm 1. Initial Check: - If either the `trips` or `users` DataFrames are empty, return an empty DataFrame with columns \"Day\" and \"Cancellation Rate\". 2. Date-based Filtering: - Filter the `trips` DataFrame to only include records between October 1st and October 3rd, 2013. 3. Merge with Non-Banned Clients: - Merge the filtered `trips` DataFrame with the `users` DataFrame, specifically targeting non-banned users (`banned` column value is 'No'). - This merge operation is based on the `client_id` from `trips` and `users_id` from `users`. - This ensures that trips with banned clients are excluded. 4. Merge with Non-Banned Drivers: - Merge the resultant DataFrame from step 3 with the `users` DataFrame again, focusing on non-banned users. - This time, the merge operation is based on the `driver_id` from the trips and `users_id` from `users`. - This ensures that trips with banned drivers are excluded. 5. Calculate Day-wise Cancellation Rate: - Group the DataFrame by the `request_at` column, which represents the day of the trip. - For each group, compute the cancellation rate by finding the ratio of non-completed trips to the total trips, rounded to two decimal places. 6. Format and Return the Result: - Reset the index of the resultant DataFrame for proper sequencing. - Rename the `request_at` column to 'Day'. - If the resulting DataFrame is empty, return an empty DataFrame with columns \"Day\" and \"Cancellation Rate\". Otherwise, return the computed results. Implementation Based on the understanding above, the solution can be implemented as: ```python import pandas as pd def trips_and_users(trips: pd.DataFrame, users: pd.DataFrame) -> pd.DataFrame: Step 1: Initial Check if trips.empty or users.empty: return pd.DataFrame(columns=[\"Day\", \"Cancellation Rate\"]) Step 2: Date-based Filtering filtered_trips = trips[trips[\"request_at\"].between(\"2013-10-01\", \"2013-10-03\")] Step 3: Merge with Non-Banned Clients trips_with_clients = filtered_trips.merge( users.loc[users[\"banned\"] == \"No\", [\"users_id\"]], left_on=\"client_id\", right_on=\"users_id\", how=\"inner\", ) Step 4: Merge with Non-Banned Drivers trip_status = trips_with_clients.merge( users.loc[users[\"banned\"] == \"No\", [\"users_id\"]], left_on=\"driver_id\", right_on=\"users_id\", how=\"inner\", ) Step 5: Calculate Day-wise Cancellation Rate result = trip_status.groupby(\"request_at\").apply( lambda group: pd.Series( {\"Cancellation Rate\": round( (group[\"status\"] != \"completed\").sum() / len(group), 2 ) } ) ) Step 6: Format and Return the Result if result.empty: return pd.DataFrame(columns=[\"Day\", \"Cancellation Rate\"]) else: return result.reset_index().rename(columns={\"request_at\": \"Day\"}) ``` Database Approach 1: Join Intuition The idea here is to bring all the related information together first, and then decide what we need. By joining the `Trips` table with the `Users `table twice (once for clients and once for drivers), we combine all the data we might need into one unified table. After this \"assembly\", we filter out the data that doesn't meet our criteria (e.g., banned users or dates outside our range). This method is very direct: get everything together, then sift through to keep what's relevant. Algorithm 1. Table Selection: - Begin with the `Trips` table. 2. Joins: - Perform a `LEFT JOIN` with the `Users` table (aliased as `Clients`). Join on the condition that `Trips.client_id` matches `Clients.users_id`. This combines each trip with information about its client. - Perform another `LEFT JOIN` with the `Users` table (aliased as `Drivers`). Join on the condition that `Trips.driver_id` matches `Drivers.users_id`. This combines each trip with information about its driver. 3. Filter Data: - `WHERE` clause: - Exclude trips where the client (`Clients.banned`) is banned (`='No'`). - Exclude trips where the driver (`Drivers.banned`) is banned (`='No'`). - Only consider trips requested between October 1, 2013, and October 3, 2013 (`request_at BETWEEN '2013-10-01' AND '2013-10-03'`). 4. Column Selection: - Select the date the trip was requested (`request_at`) and alias it as `Day`. - Calculate the cancellation rate: - The numerator is the sum of trips that are not completed (`SUM(status != 'completed')`). This counts trips with a status other than 'completed' as 1, and those with 'completed' status as 0. - The denominator is the total count of trips (`COUNT(*)`). - Divide the numerator by the denominator and round to two decimal places using `ROUND()`. Alias this calculated value as `'Cancellation Rate'`. 5. Grouping: - `GROUP BY Day`: This groups the result set by the date of the trip request, meaning the cancellation rate will be calculated for each day separately. 6. Final Result: - For each day between October 1, 2013, and October 3, 2013, where there are trips with non-banned clients and drivers, you will get: - The day. - The cancellation rate for that day, rounded to two decimal places. Implementation Based on the understanding above, the solution can be implemented as: ```sql SELECT request_at AS Day, ROUND( SUM(status != 'completed') / COUNT(*), 2 ) AS 'Cancellation Rate' FROM Trips LEFT JOIN Users AS Clients ON Trips.client_id = Clients.users_id LEFT JOIN Users AS Drivers ON Trips.driver_id = Drivers.users_id WHERE Clients.banned = 'No' AND Drivers.banned = 'No' AND request_at BETWEEN '2013-10-01' AND '2013-10-03' GROUP BY Day ``` Approach 2: Using Subqueries Intuition The idea here is to first identify the data we don't want, and then exclude them from the following calculation. Instead of gathering everything and then filtering, this approach starts by explicitly listing what to exclude. The subqueries identify banned users. The main query then fetches trips, ensuring that any trips involving these banned users are avoided. Algorithm 1. Initial Data Retrieval - From the table named `Trips`, retrieve rows (or records). 2. Filter by Date - Only consider rows where the `request_at` date is between the inclusive range from '2013-10-01' to '2013-10-03'. 3. Remove Banned Drivers - From the table named `Users`, retrieve all `users_id` values where `banned` is set to 'Yes'. These represent banned users. - From the `Trips` table, exclude all rows where the `driver_id` is among the list of banned users from the previous step. 4. Remove Banned Clients - Similarly, from the `Trips` table, exclude all rows where the `client_id` is among the list of banned users. 5. Grouping - Group the filtered rows from the `Trips` table by the `request_at` date. For simplicity, we're renaming `request_at` to `Day`. 6. Calculate Cancellation Rate for Each Group - For each group (or for each unique date): - Calculate the sum of statuses that are not 'completed'. This is done by evaluating the condition `(status != 'completed')`, which will return `1` if the status is not 'completed' and `0` otherwise. Summing this up will give the total number of non-completed statuses. - Calculate the total count of `status` for that group. - Divide the sum of non-completed statuses by the total count of statuses. - Round the resulting value to 2 decimal places. - The final result represents the \"Cancellation Rate\" for that date. 7. Output - For each date in the range, return: - The date (`Day`). - The corresponding cancellation rate (`Cancellation Rate`). Implementation Based on the understanding above, the solution can be implemented as: ```sql SELECT request_at AS Day, ROUND( SUM(status != 'completed') / COUNT(status), 2 ) AS 'Cancellation Rate' FROM Trips WHERE request_at BETWEEN '2013-10-01' AND '2013-10-03' AND driver_id NOT IN ( SELECT users_id FROM Users WHERE banned = 'Yes' ) AND client_id NOT IN ( SELECT users_id FROM Users WHERE banned = 'Yes' ) GROUP BY Day ``` Approach 3: Using Common Table Expression (CTE) Intuition The idea here is to prepare a clean workspace with only what we need, and then work on it. The CTE serves as this \"workspace\" or intermediary step. It pre-processes the data, filters out banned users, and selects only the desired date range. Once this clean, streamlined dataset (CTE) is ready, the main query can quickly compute the cancellation rate without distractions. Algorithm 1. Initialize CTE (Common Table Expression) `TripStatus`: - A CTE is like a temporary result set that you can reference within a `SELECT`, `INSERT`, `UPDATE`, or `DELETE` statement. 2. From the `Trips` table: - Select the `Request_at` column and rename it to `Day`. - Evaluate if the trip status is not 'completed'. If true, it will return 1 (true), otherwise 0 (false). This is represented by the column `cancelled`. 3. Join the `Trips` table with `Users` table for Clients: - The join condition is where `Client_Id` from the `Trips` table matches `Users_Id` from the `Users` table. - Furthermore, only consider those rows where the client is not banned. This means that the `Banned` column for the client should be 'No'. 4. Join the result with `Users` table again but now for Drivers: - Similarly, the join condition is where `Driver_Id` from the `Trips` table matches `Users_Id` from the `Users` table. - Again, only consider those rows where the driver is not banned. This implies that the `Banned` column for the driver should be 'No'. 5. Filter the data: - Only consider those trips which have the `Request_at` value between '2013-10-01' and '2013-10-03'. 6. Now, for the main query, using the CTE `TripStatus`: - Group the data by `Day`. 7. Calculate the Cancellation Rate for each day: - For each day, sum the `cancelled` column. This will give the total number of cancelled trips for that day because a cancelled trip is represented by 1. - For each day, count the `cancelled` column. This will give the total number of trips for that day, regardless of their status. - Divide the sum by the count to get the cancellation rate for each day. - Round this rate to 2 decimal places. 8. Final output: - Return the `Day` and the calculated 'Cancellation Rate' for each day. Implementation Based on the understanding above, the solution can be implemented as: ```sql WITH TripStatus AS ( SELECT Request_at AS Day, T.status != 'completed' AS cancelled FROM Trips T JOIN Users C ON Client_Id = C.Users_Id AND C.Banned = 'No' JOIN Users D ON Driver_Id = D.Users_Id AND D.Banned = 'No' WHERE Request_at BETWEEN '2013-10-01' AND '2013-10-03' ) SELECT Day, ROUND( SUM(cancelled) / COUNT(cancelled), 2 ) AS 'Cancellation Rate' FROM TripStatus GROUP BY Day; ```",
    "constraints": [],
    "examples": [
      {
        "example_text": "+-+-+ | Column Name | Type | +-+-+ | id | int | | client_id | int | | driver_id | int | | city_id | int | | status | enum | | request_at | varchar | +-+-+ id is the primary key (column with unique values) for this table. The table holds all taxi trips. Each trip has a unique id, while client_id and driver_id are foreign keys to the users_id at the Users table. Status is an ENUM (category) type of ('completed', 'cancelled_by_driver', 'cancelled_by_client')."
      },
      {
        "example_text": "+-+-+ | Column Name | Type | +-+-+ | users_id | int | | banned | enum | | role | enum | +-+-+ users_id is the primary key (column with unique values) for this table. The table holds all users. Each user has a unique users_id, and role is an ENUM type of ('client', 'driver', 'partner'). banned is an ENUM (category) type of ('Yes', 'No')."
      },
      {
        "example_text": "Input: Trips table: +-+--+--++++ | id | client_id | driver_id | city_id | status | request_at | +-+--+--++++ | 1 | 1 | 10 | 1 | completed | 2013-10-01 | | 2 | 2 | 11 | 1 | cancelled_by_driver | 2013-10-01 | | 3 | 3 | 12 | 6 | completed | 2013-10-01 | | 4 | 4 | 13 | 6 | cancelled_by_client | 2013-10-01 | | 5 | 1 | 10 | 1 | completed | 2013-10-02 | | 6 | 2 | 11 | 6 | completed | 2013-10-02 | | 7 | 3 | 12 | 6 | completed | 2013-10-02 | | 8 | 2 | 12 | 12 | completed | 2013-10-03 | | 9 | 3 | 10 | 12 | completed | 2013-10-03 | | 10 | 4 | 13 | 12 | cancelled_by_driver | 2013-10-03 | +-+--+--++++ Users table: +-+--+--+ | users_id | banned | role | +-+--+--+ | 1 | No | client | | 2 | Yes | client | | 3 | No | client | | 4 | No | client | | 10 | No | driver | | 11 | No | driver | | 12 | No | driver | | 13 | No | driver | +-+--+--+ Output: ++-+ | Day | Cancellation Rate | ++-+ | 2013-10-01 | 0.33 | | 2013-10-02 | 0.00 | | 2013-10-03 | 0.50 | ++-+ Explanation: On 2013-10-01: - There were 4 requests in total, 2 of which were canceled. - However, the request with Id=2 was made by a banned client (User_Id=2), so it is ignored in the calculation. - Hence there are 3 unbanned requests in total, 1 of which was canceled. - The Cancellation Rate is (1 / 3) = 0.33 On 2013-10-02: - There were 3 requests in total, 0 of which were canceled. - The request with Id=6 was made by a banned client, so it is ignored. - Hence there are 2 unbanned requests in total, 0 of which were canceled. - The Cancellation Rate is (0 / 2) = 0.00 On 2013-10-03: - There were 3 requests in total, 1 of which was canceled. - The request with Id=8 was made by a banned client, so it is ignored. - Hence there are 2 unbanned request in total, 1 of which were canceled. - The Cancellation Rate is (1 / 2) = 0.50"
      }
    ]
  },
  {
    "problem_slug": "ugly-number",
    "difficulty": "Easy",
    "topics": [
      "Math"
    ],
    "description": "An ugly number is a positive integer which does not have a prime factor other than 2, 3, and 5. Given an integer n, return true if n is an ugly number. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "-231 <= n <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: n = 6 Output: true Explanation: 6 = 2  3"
      },
      {
        "example_text": "Input: n = 1 Output: true Explanation: 1 has no prime factors."
      },
      {
        "example_text": "Input: n = 14 Output: false Explanation: 14 is not ugly since it includes the prime factor 7."
      }
    ]
  },
  {
    "problem_slug": "ugly-number-ii",
    "difficulty": "Medium",
    "topics": [
      "Hash Table",
      "Math",
      "Dynamic Programming",
      "Heap (Priority Queue)"
    ],
    "description": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return the nth ugly number. Example 1: Example 2: Constraints:",
    "solution": "Solution Overview An ugly number is a positive integer whose prime factors are limited to `2`, `3`, and `5`. This means that for a number to be classified as ugly, it can only be divided by these primes without leaving a remainder. In Example 2, we observe that the number `1` is considered an ugly number, even though it lacks any prime factors of `2`, `3`, or `5`. This might seem confusing initially, but the explanation clarifies that \"`1` has no prime factors; therefore, all of its prime factors are limited to `2`, `3`, and `5`.\" This statement can be somewhat misleading if not properly understood. It implies that since `1` has no prime factors, it doesn't violate the rule that ugly numbers can only have prime factors of `2`, `3`, or `5`. In essence, `1` automatically meets the condition, as there are no prime factors to contradict the rule. > In short `1` is an ugly number because it can be expressed as $2^0 \\times 3^0 \\times 5^0$ Approach 1: Using Set Intuition We begin with a brute force approach where the goal is to count ugly numbers one by one until we reach the nth ugly number. We can create a helper function that checks if a number is ugly by repeatedly dividing it by `2`, `3`, and `5` until it's no longer divisible by these primes. If the result is `1`, the number is ugly. We then iterate through integers applying this check, and count the ugly numbers we encounter. While this method works, its inefficient as it checks every number sequentially, including those clearly not ugly (e.g., numbers divisible by other primes). This results in high time complexity, making it unsuitable for large values of `n`. To improve upon the brute force method, we can leverage a key property of ugly numbers: if a number is ugly, multiplying it by `2`, `3`, or `5` also yields an ugly number. This insight allows us to generate ugly numbers systematically rather than checking each number individually. We start with the first ugly number, which is `1`. From there, we generate the next candidates by multiplying `1` by `2`, `3`, and `5`. These candidates represent the next potential ugly numbers. To ensure we always process the smallest ugly numbers first (necessary to find the nth one), we use a set that keeps elements in sorted order and removes duplicates. We continue this process until we reach the nth ugly number. This approach is more efficient as it avoids unnecessary checks and focuses solely on generating and managing ugly numbers. However, it requires maintaining a set, which can grow large and impact memory usage. Algorithm - Initialize a set named `uglyNumbersSet` to store potential ugly numbers. - Insert the first ugly number, `1`, into the `uglyNumbersSet`. - Initialize a variable `currentUgly` to store the current smallest ugly number. - Loop `n` times to find the `n`th ugly number: - In each iteration: - Set `currentUgly` to the smallest number in the `uglyNumbersSet` by accessing the first element. - Remove this smallest number from the `uglyNumbersSet` using `erase`. - Insert the next potential ugly numbers by multiplying `currentUgly` by `2`, `3`, and `5`: - Insert `currentUgly * 2` into the `uglyNumbersSet`. - Insert `currentUgly * 3` into the `uglyNumbersSet`. - Insert `currentUgly * 5` into the `uglyNumbersSet`. - After the loop completes, `currentUgly` will hold the nth ugly number. - Return `currentUgly` as the result, casting it to `int`. Implementation Complexity Analysis Let $n$ be the given index value of the ugly number and $m$ be the size of set. - Time complexity: $O(n \\log m)$ Each insertion and removal operation in the set takes logarithmic time. > In Python, the `min` function has a time complexity of $O(n)$ due to the need to scan through all elements of the set to find the minimum. Since this function is called once per iteration of the loop and there are $n$ iterations, the overall time complexity is $O(n \\times m)$. - Space complexity: $O(m)$ The space required depends on the number of unique ugly numbers stored in the set. Approach 2: Min-Heap/Priority Queue Intuition To further streamline the process, we use a priority queue (min-heap) to efficiently manage and retrieve the smallest ugly number. We start with `1` as our base ugly number and insert it into the min-heap. The priority queue keeps the smallest element at the top, so we can easily access and remove it to get the next ugly number. After popping the smallest ugly number, we generate new ugly numbers by multiplying them by `2`, `3`, and `5`. These new numbers are then pushed back into the queue. To avoid duplicates, we use a set to track numbers that have already been added, ensuring each ugly number is processed only once. Algorithm - Create a min-heap (`minHeap`) to store ugly numbers and a set (`seenNumbers`) to track numbers already processed. - Push the first ugly number (1) into the heap and insert it into the set. - For `n` iterations: - Pop the smallest ugly number (`currentUgly`) from the heap. - Generate the next ugly numbers by multiplying `currentUgly` with 2, 3, and 5. - If a generated ugly number is not in the set, push it into the heap and add it to the set. - After `n` iterations, the last popped number from the heap is the nth ugly number. - Return the `n`th ugly number. Implementation Complexity Analysis Let $n$ be the given index value of the ugly number and $m$ be the size of set. * Time complexity: $O(n \\log m)$ The operations on the priority queue (`push` and `pop`) take logarithmic time, and there are `m` such operations. * Space complexity: $O(m)$ The space is used by the heap and the set, which store up to `m` elements as it depends on the number of unique ugly numbers stored in the set. Approach 3: Dynamic Programming (DP) Intuition The dynamic programming (DP) approach to finding ugly numbers is based on an idea: every ugly number, except for `1`, is generated by multiplying a smaller ugly number by either `2`, `3`, or `5`. This insight allows us to systematically generate ugly numbers in order. We start with `1`, the smallest ugly number. To find the next ugly number, we have three options: $1 \\times 2$, $1 \\times 3$, and $1 \\times 5$. The smallest of these, $1 \\times 2 = 2$, becomes our second ugly number. For the third ugly number, we again have three choices: the next multiple of `2` ($2 \\times 2 = 4$), and the unused multiples of `3` and `5` from before ($1 \\times 3 = 3$ and $1 \\times 5 = 5$). We select the smallest of these (which is $3$) and continue this process. This approach naturally leads to using three pointers, one each for multiplying by `2`, `3`, and `5`. These pointers track which ugly number should be multiplied by `2`, `3`, and `5` next. Each time, we choose the smallest of these three possible next ugly numbers, add it to our list, and move the pointer that produced this number. The efficiency and cleverness of this method lie in its simplicity. We build our list of ugly numbers using the same list we are creating. This self-referencing nature characterizes it as dynamic programming. By maintaining the list in order and using pointers, we avoid the need for sorting or removing duplicates, making the algorithm both fast ($O(n)$) and memory-efficient. Now, let's think about why this method works for all ugly numbers: We always start by choosing the smallest number available and manage the process of multiplying by `2`, `3`, and `5` separately. This approach ensures that no ugly numbers are missed. Specifically, any ugly number must be derived from a previously found smaller ugly number, multiplied by `2`, `3`, or `5`. By maintaining pointers to track these multiplications, we ensure that every number in our list is properly considered for these multiplications. By always selecting the smallest number first from the available multiplications, we prevent the introduction of larger numbers before smaller ones. This strategy eliminates the possibility of missing any ugly numbers, ensuring a consistent and complete generation of ugly numbers.For A Formal Proof Click Here:Proof: 1. Base Case: - We start with `1`, which is an ugly number because it can be expressed as $2^0 \\times 3^0 \\times 5^0$. This is our starting point and is correctly included in the list. 2. Inductive Hypothesis: - Assume that after generating $k$ ugly numbers, denoted as $U_1, U_2, \\ldots, U_k$, our list contains all ugly numbers up to the $k$-th position in ascending order. 3. Inductive Step: - Goal: Show that the algorithm correctly generates the $(k+1)$-th ugly number. - Given our current list $U_1, U_2, \\ldots, U_k$, we consider the next possible ugly numbers by multiplying each number in the list by 2, 3, and 5. These potential numbers are $U_i \\times 2$, $U_i \\times 3$, and $U_i \\times 5$, where $U_i$ is the smallest number in the list at that step. - We always select the smallest number from these candidates and add it to our list. Lets denote this smallest number as $N$. By design, $N$ is the next smallest ugly number that hasn't been added to the list yet. - Exhaustiveness: - We ensure that every ugly number is generated by considering all possible multiplications of the smallest numbers. This way, we don't miss any possible ugly number. - Non-Redundancy: - By selecting the smallest number each time, we avoid adding duplicate numbers. This ensures that each number added to the list is unique and correctly ordered. - Completeness: - Every ugly number must be derived from previously generated ugly numbers through multiplication by 2, 3, or 5. Our method covers all such possible combinations, so it will eventually generate every ugly number. 4. Termination: - The algorithm stops once we have generated the desired number of ugly numbers. Since we are systematically adding the smallest possible ugly number at each step, our list will be complete and correctly ordered. Conclusion: By using induction, we see that starting from the base case of `1`, and ensuring each subsequent number is the smallest possible ugly number, we guarantee that our algorithm will generate all ugly numbers in ascending order. This method is both correct and complete, as it ensures that no ugly numbers are missed or duplicated. Algorithm 1. Initialize a vector `uglyNumbers` of size `n` to store the ugly numbers, with the first ugly number set to `1`. 2. Set up three pointers (`indexMultipleOf2`, `indexMultipleOf3`, `indexMultipleOf5`) to track the next multiples of 2, 3, and 5, respectively. 3. Assign initial values to `nextMultipleOf2`, `nextMultipleOf3`, and `nextMultipleOf5` (i.e., `2`, `3`, and `5`). 4. For `i` from `1` to `n-1`: - Determine the next ugly number by taking the minimum of `nextMultipleOf2`, `nextMultipleOf3`, and `nextMultipleOf5`. - Store this value in `uglyNumbers[i]`. - Update the corresponding pointer and multiple: - If the next ugly number equals `nextMultipleOf2`, increment `indexMultipleOf2` and update `nextMultipleOf2`. - If the next ugly number equals `nextMultipleOf3`, increment `indexMultipleOf3` and update `nextMultipleOf3`. - If the next ugly number equals `nextMultipleOf5`, increment `indexMultipleOf5` and update `nextMultipleOf5`. 5. After completing the loop, return the last element in `uglyNumbers`, which is the `n`th ugly number. The algorithm is visualized below: !?!../Documents/264/dp.json:975,595!?! Implementation Complexity Analysis Let $n$ be the given index value of the ugly number. * Time complexity: $O(n)$ This approach is linear because we generate each ugly number directly using the three pointers. * Space complexity: $O(n)$ We need space to store the first `n` ugly numbers.",
    "constraints": [
      "1 <= n <= 1690"
    ],
    "examples": [
      {
        "example_text": "Input: n = 10 Output: 12 Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers."
      },
      {
        "example_text": "Input: n = 1 Output: 1 Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5."
      }
    ]
  },
  {
    "problem_slug": "missing-number",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Hash Table",
      "Math",
      "Binary Search",
      "Bit Manipulation",
      "Sorting"
    ],
    "description": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Example 1: Example 2: Example 3: Constraints: Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?",
    "solution": "",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 104",
      "0 <= nums[i] <= n",
      "All the numbers of nums are unique."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3] . 2 is the missing number in the range since it does not appear in nums ."
      },
      {
        "example_text": "Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2] . 2 is the missing number in the range since it does not appear in nums ."
      },
      {
        "example_text": "Input: nums = [9,6,4,2,3,5,7,0,1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9] . 8 is the missing number in the range since it does not appear in nums ."
      }
    ]
  },
  {
    "problem_slug": "integer-to-english-words",
    "difficulty": "Hard",
    "topics": [
      "Math",
      "String",
      "Recursion"
    ],
    "description": "Convert a non-negative integer num to its English words representation. Example 1: Example 2: Example 3: Constraints:",
    "solution": "Solution Overview We need to create a program that converts any non-negative integer into its English word representation. The program must handle the English numbering system accurately, including terms like thousands, millions, and billions, and must follow the rules for numbers below one hundred to ensure correct phrasing. Key Points: - The input can range from `0` to `2,147,483,647` (i.e., the maximum value for a 32-bit signed integer). - The first letter of each word must be capitalized. - Words should be separated by a single space, with no trailing spaces. Observe the tree diagram below to understand how numbers are spelled out in English, along with their corresponding units and scales. This will help us see the repetitive patterns and their resemblance to a tree data structure, which lends itself to a recursive approach. ![Number_Tree](../Figures/273/273_Integer_to_english.png) Approach 1: Recursive Approach Intuition In the recursive approach, we break down the number into smaller parts based on place values such as ones, tens, hundreds, thousands, millions, and so on. We start with the largest place value and proceed downward. For example, with the number `1234567`, we first handle the millions part (`1 Million`). We use a helper function that recursively breaks down the number. If the number is less than `10`, we return the corresponding word from a predefined list (`belowTen`). For numbers less than `20`, we use another list (`belowTwenty`) due to their unique names. For numbers below `100`, we combine the word for the tens place (from `belowHundred`) with the word for the ones place, using further recursive calls. For numbers below `1000`, we break the number into hundreds and the remainder, processing each part recursively. For larger numbers like `1234567`, the function handles the millions part (`1 Million`), then the thousands (`234 Thousand`), and finally the hundreds and smaller units (`567`). Each chunk is processed using recursive calls, building the final English representation from smallest to largest units. The recursive function works as follows: - Base Case: For numbers less than 10, the function directly maps to a word using `belowTen`. For numbers between 10 and 19, `belowTwenty` handles these unique cases. For numbers between 20 and 99, it combines words from `belowHundred` for tens and recursively processes the remainder for units. - Recursive Case: For numbers 100 and above, the function processes hundreds, thousands, millions, and billions by breaking the number into smaller parts. For example, for `1234567`, it processes the millions part (`1 Million`), then the thousands part (`234 Thousand`), and finally the remainder (`567`). Each part is processed recursively to ensure accurate conversion. After processing each chunk, we combine the results, handling the hierarchical structure from the smallest unit up to the largest (like billions), ensuring that each segment is correctly represented in English. Algorithm - Initialize arrays to store words for different ranges of numbers: - `belowTen` for numbers 1-9. - `belowTwenty` for numbers 10-19. - `belowHundred` for multiples of ten from 20-90. - Define the main function `numberToWords` to handle the conversion: - If the number is zero, return `\"Zero\"`. - Otherwise, call the helper function `convertToWords` to start the conversion process. - Implement the helper function `convertToWords` to convert numbers to words recursively: - Base Case 1: Numbers less than 10: - Return the corresponding word from `belowTen`. - Base Case 2: Numbers less than 20: - Return the corresponding word from `belowTwenty`. - Numbers from 20 to 99: - Combine the word for the tens place from `belowHundred` with the recursive result for the units place. - Numbers from 100 to 999: - Combine the recursive result for the hundreds place with `\"Hundred\"`, and the recursive result for the remaining part. - Numbers from 1000 to 999,999: - Combine the recursive result for thousands with `\"Thousand\"`, and the recursive result for the remaining part. - Numbers from 1,000,000 to 999,999,999: - Combine the recursive result for millions with `\"Million\"`, and the recursive result for the remaining part. - Numbers 1,000,000,000 and above: - Combine the recursive result for billions with `\"Billion\"`, and the recursive result for the remaining part. Implementation Complexity Analysis Let $N$ be the number. - Time complexity: $O(\\log_{10} N)$ The time complexity is $O(\\log_{10} N)$ because the number of recursive calls is proportional to the number of digits in the number, which grows logarithmically with the size of the number. - Space complexity: $O(\\log_{10} N)$ The space complexity is $O(\\log_{10} N)$, mainly because of the recursion stack. Each recursive call adds a frame to the stack until the base case is reached, leading to space usage proportional to the number of digits in the number. Approach 2: Iterative Approach Intuition In the iterative approach, we convert a number into English words by processing it in chunks of three digits, corresponding to thousands, millions, billions, etc. We initialize arrays for place value words (like thousand, million, billion) and for digit and tens names. A loop processes the number from the least significant chunk (ones, tens, hundreds) to the most significant chunk (thousands, millions, billions). For instance, with the number `1234567`, we repeatedly use the modulus operation `% 1000` to extract chunks of three digits. We start by using `1234567 % 1000` to get `567`, then `1234 % 1000` to get `234`, and finally `1 % 1000` to get `1`. Each chunk is then converted to English words.\" To convert each chunk: 1. Handle the hundreds place if present (e.g., `567` becomes \"Five Hundred\"). 2. Process the tens and ones (e.g., `67` becomes \"Sixty-Seven\"). 3. Append the appropriate scale word (e.g., thousand, million) based on the chunk's position (e.g., `234` becomes \"Two Hundred Thirty-Four Thousand\"). We track the scale by using an index (`groupIndex`) that increments with each chunk processed. This index is used to fetch the correct scale word (thousand, million, billion) from the thousands array. For example: - `groupIndex = 0`: No scale word (ones place). - `groupIndex = 1`: \"Thousand\". - `groupIndex = 2`: \"Million\". - `groupIndex = 3`: \"Billion\". We build the final result by concatenating the words for each chunk, starting from the least significant chunk and moving to the most significant. This ensures the correct placement of scale words and produces the final English representation of the entire number. Algorithm - Handle the special case where the number is zero by returning `\"Zero\"`. - Initialize arrays to store words for single digits, tens, and thousands: - `ones` for numbers 1-19. - `tens` for multiples of ten from 20-90. - `thousands` for scales (`\"Thousand\"`, `\"Million\"`, `\"Billion\"`). - Process the number in chunks of 1000. - Extract the last three digits of the number and handle hundreds, tens, and units: - Handle hundreds place by adding the corresponding word from `ones` and `\"Hundred\"`. - Handle tens and units place by combining the word from `tens` and `ones`. - Append the scale (`\"Thousand\"`, `\"Million\"`, `\"Billion\"`) for the current group. - Insert the group result at the beginning of the final result. - Move to the next chunk of 1000 by dividing the number by 1000. - Return the result after removing trailing spaces. Implementation Complexity Analysis Let $N$ be the number. * Time complexity: $O(\\log_{10} N)$ $O(\\log_{10} N)$, because the number is divided by 1000 in each iteration, making the number of iterations proportional to the number of chunks, which is logarithmic. * Space complexity: $O(1)$ $O(1)$, constant space. The space used is independent of the number's size, as it involves only a few string builders and arrays. Approach 3: Pair-Based Approach Intuition In the pair-based approach, we use a predefined list of numeric values and their corresponding English words to convert a number. We process the number by matching it against these pairs from largest to smallest, dividing the number, and converting each part recursively. We start by defining a list of pairs where each pair consists of a numeric value and its English word, such as `1000000000` for \"Billion\", `1000000` for \"Million\", and down to `1` for \"One\". This list facilitates conversion by identifying which value fits into the current number. For a number like `1234567`, we iterate through the list from the largest value to the smallest. We check if the number is greater than or equal to each value. If it is: - Divide the Number: Determine how many times the value fits into the number (the quotient) and calculate the remainder. For `1234567`, we match `1 Million`, resulting in \"One Million\", and then process the remainder (`234567`). - Recursive Conversion: Convert the quotient to words and recursively process the remainder using the same list of pairs. We concatenate the word for the current pair with the results from the recursive call for the remainder. This process builds the final English word representation from the largest units (like billion) to the smallest (like one), ensuring an accurate representation of every part of the number. Algorithm - Initialize a pair `numberToWordsMap` that maps numeric values to their corresponding English words: - Includes large scales (`\"Billion\"`, `\"Million\"`, `\"Thousand\"`, `\"Hundred\"`) and individual numbers (1-19, and multiples of ten from 20 to 90). - Handle the special case where the number is zero by returning `\"Zero\"`. - Call the function `numberToWords` to convert the number to English words: - Iterate over the `numberToWordsMap`: - For each pair `(value, word)` in `numberToWordsMap`, check if the number `num` is greater than or equal to `value`. - If `num` is greater than or equal to `value`: - Compute the `prefix`: - If `num` is 100 or greater, recursively convert the quotient (`num / value`) to words and append `\" \"` (a space). If `num` is less than 100, set `prefix` to an empty string. - Get the `unit` as the current `word` from `numberToWordsMap`. - Compute the `suffix`: - If the remainder (`num % value`) is zero, set `suffix` to an empty string. Otherwise, recursively convert the remainder to words and prepend `\" \"` (a space). - Return the combined result: `prefix + unit + suffix`. - If the number is not zero, the function will return the complete English representation by combining the `prefix`, `unit`, and `suffix`. Implementation Complexity Analysis Let $K$ be the number of pairs in `numberToWordsMap` and $N$ be the number. - Time complexity: $O(K)$ The time complexity is $O(K)$ because the loop iterates through the pairs until it finds a match. This complexity is linear with respect to the number of pairs, which is constant in practice as the number of pairs is fixed. - Space complexity: $O(\\log_{10} N)$ $O(\\log_{10} N)$, mainly due to the recursion stack in the `convert` function. The space used is proportional to the number of recursive calls made.",
    "constraints": [
      "0 <= num <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: num = 123 Output: \"One Hundred Twenty Three\""
      },
      {
        "example_text": "Input: num = 12345 Output: \"Twelve Thousand Three Hundred Forty Five\""
      },
      {
        "example_text": "Input: num = 1234567 Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\""
      }
    ]
  },
  {
    "problem_slug": "h-index",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Sorting",
      "Counting Sort"
    ],
    "description": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index. According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "n == citations.length",
      "1 <= n <= 5000",
      "0 <= citations[i] <= 1000"
    ],
    "examples": [
      {
        "example_text": "Input: citations = [3,0,6,1,5] Output: 3 Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3."
      },
      {
        "example_text": "Input: citations = [1,3,1] Output: 1"
      }
    ]
  },
  {
    "problem_slug": "h-index-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Binary Search"
    ],
    "description": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in non-descending order, return the researcher's h-index. According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. You must write an algorithm that runs in logarithmic time. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "n == citations.length",
      "1 <= n <= 105",
      "0 <= citations[i] <= 1000",
      "citations is sorted in ascending order."
    ],
    "examples": [
      {
        "example_text": "Input: citations = [0,1,3,5,6] Output: 3 Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3."
      },
      {
        "example_text": "Input: citations = [1,2,100] Output: 2"
      }
    ]
  },
  {
    "problem_slug": "first-bad-version",
    "difficulty": "Easy",
    "topics": [
      "Binary Search",
      "Interactive"
    ],
    "description": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= bad <= n <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: n = 5, bad = 4 Output: 4 Explanation: call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true Then 4 is the first bad version."
      },
      {
        "example_text": "Input: n = 1, bad = 1 Output: 1"
      }
    ]
  },
  {
    "problem_slug": "perfect-squares",
    "difficulty": "Medium",
    "topics": [
      "Math",
      "Dynamic Programming",
      "Breadth-First Search"
    ],
    "description": "Given an integer n, return the least number of perfect square numbers that sum to n. A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4."
      },
      {
        "example_text": "Input: n = 13 Output: 2 Explanation: 13 = 4 + 9."
      }
    ]
  },
  {
    "problem_slug": "expression-add-operators",
    "difficulty": "Hard",
    "topics": [
      "Math",
      "String",
      "Backtracking"
    ],
    "description": "Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value. Note that operands in the returned expressions should not contain leading zeros. Note that a number can contain multiple digits. Example 1: Example 2: Example 3: Constraints:",
    "solution": "Solution Approach 1: Backtracking Intuition Let us first look at what the question asks us to do before getting at the approach to solve it. So, we are given a string of numbers and 3 different operators: * `+` Addition, * `-` Subtraction or * `*` Multiplication We have to find all possible combinations of binary operators between the digits so that the overall value of the resulting expression becomes equal to a given target value. Let us look at a few possibilities of what it means exactly to *place the operators between digits* so that the question becomes clearer. Let's say we are given the following set of digits `\"123456789\"` and the target value given to us is `45`. Let us see some of the possible resulting expressions that we can get by placing the operators in different locations.1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45 1 + 2 - 3 + 4 - 5 + 6 - 7 + 8 - 9 = -3 1 + 2 * 3 - 4 + 5 + 6 - 7 * 8 - 9 = -51 1 + 2 + 3 + 4 + 5 - 6 * 7 + 8 * 9 = 45These are just 4 of the many resulting expressions that are possible by using the given string of digits and the three operators. By looking at the above examples we can't really figure out any specific pattern among the resulting expressions that tells us which of them will give us the resulting target. Since the question explicitly states that we are given binary operators, this means that each of the operator would require two operands. > We can consider each of our digits as an operand. This means that between every pair of digits we can have any of the three operators i.e. +, - or \\times. If you've looked at the question's statement and the examples that are given in the question, you would realize that there is an example where the digits are `\"105\"` and the target value is `5`. For this particular example, there are two expressions given to us and they are `1*0+5` and `10-5`. The second expression is something that you need to look out for before getting to solve this question because this complicates things a bit. It would have been an easier question to solve if we just had to consider those expressions that simply had *digits as operands*. But, in this question, we can have all sorts of digits getting together and forming a bigger number that becomes a part of the expression. Let us look at some example expressions for the digits `\"123456\"` and target `30`.1 * 23 - 4 + 5 + 6 = 30 12 - 3 * 4 + 5 * 6 = 30 1 - 23 - 4 + 56 = 30So this means that although the number of operators are defined for us i.e. 3 different binary operators, but the number of operands are not really well defined for us. This is a big portion of the original problem that we need to address in our solution. Since we are asked to find out all of the valid expressions whose value equals the given target and we don't really know what specific operator between two operands would eventually give us a valid expression, > We try out all of the options. This means once we have defined what the operands are for our given expression, we would have three possible choices of operators between each consecutive pair of operands. From an implementation perspective, what would an operand imply with respect to our original string? > An operand would be an integer formed from a substring of our original string. Let's look at two different array partitions for the given string `\"123456789\"`Since we are required to return all of the valid expressions that evaluate to a given target value, we have to try all possible partitions of the given array thereby considering all of the possible operands that can be formed from the digits. There is a very simple way of incorporating this into our algorithm. Right now, at every point in the algorithm, we have three different choices corresponding to the three different operators. >The way we incorporate these partitions is by considering a 4th operator as well which simply moves one step forward and extends the current operand by one digit. Essentially, going from 12 --> 123 is a NO OP operand in our implementation. (12 * 10) + 3. Now we have 4 different recursion paths in our algorithm and we have to try out all of them to see which ones lead to a potential solution. This `try out everything` hints at a backtracking solution and that is exactly what we are going to look at here. Algorithm Let's quickly look at the steps involved in our backtracking algorithm before looking at the pseudo-code. 1. As discussed above, we have multiple choices of what operators to use and what the operands can be and hence, we have to look at all the possibilities to find *all* valid expressions. 2. Our recursive call will have an `index` which represents the current digit we're looking at in the original `nums` string and also the expression string built till now. 3. At every step, we have exactly 4 different recursive calls. The `NO OP` call simply extends the `current_operand` by the current digit and moves ahead. Rest of the recursive calls correspond to `+`, `-`, and `*`. 4. We keep on building our expression like this and eventually, the entire `nums` string would be processed. At that time we check if the expression we built till now is a valid expression or not and we record it if it is a valid one.1. procedure recurse(digits, index, expression): 2. if we have reached the end of the string: 3. if the expression evaluates to the target: 4. Valid Expression found! 5. else: 6. try out operator 'NO OP' and recurse 7. try out operator * and recurse 8. try out operator + and recurse 9. try out operator - and recurseThe algorithm now looks pretty straightforward. However, the implementation is something that needs more thought and there are some things that we need to address before actually looking at the implementation. When we are done building an expression out of all of the digits in our original string i.e. the base case, then we check if the expression is a valid expression or not. Right ? > How do we actually check if an expression is a valid one or not if all we have is a string representing the expression and not the integer value for the same? Well, one way to go about this is to write a custom `eval` function that takes in a string and returns the value of that expression. If you do that (Python people can use the inbuilt function `eval` for this), you will get a TLE i.e. time limit exceeded error.Can't we keep track of the expression's value on the fly? Well yes. That's the idea we will go with. Instead of just keeping track of what the expression string is, we will also keep track of it's value along the way so that when the recursion hits the base case, we can check in O(1) time if the expression's value equals the target value or not. The implementation would have been straightforward had it just been `+` and `-` operators involved. This is because both these operators have an equal precedence. That means that we can continue to evaluate the expression on the fly without any problems. Have a look at the following example.So far so good. Now let us add the `*` operator as well and see how building the expression on the fly like this breaks.What we mean by building the expression on the fly is that we keep track of the expression's value till now and we simply consider that value as one of the two operands for our operators. As we can see from the two examples above, this would have worked had it just been `+` and `-` operators. But, this approach is bound to fail because the `*` operator takes precedence over `+` and `-`. The `*` operator would require the *actual* previous operand in our expression rather than the current value of the expression. i.e. In the above example, the `*` operator needed `2` rather than `12` to get us the correct value of `18`.How to handle this? The idea on how to handle this problem springs from the discussion above. We simply need to keep track of the last operand in our expression and how it modified the expression's value overall so that when we consider the `*` operator, we can reverse the effects of the previous operand and consider it for multiplication. Let's take a look at the example that was breaking before.Now we can look at the actual implementation of this algorithm.Complexity Analysis * Time Complexity: * At every step along the way, we consider exactly 4 different choices or 4 different recursive paths. The base case is when the value of `index` reaches N i.e. the length of the `nums` array. Hence, our complexity would be O(4^N). * For the base case we use a `StringBuilder::toString` operation in Java and `.join()` operation in Python and that takes O(N) time. Here N represents the length of our expression. In the worst case, each digit would be an operand and we would have N digits and N - 1 operators. So O(N). This is for one expression. In the worst case, we can have O(4^N) valid expressions. * Overall time complexity = O(N \\times 4^N). * Space Complexity: * For both Python and Java implementations we have a list data structure that we update on the fly and only for valid expressions do we create a new string and add to our `answers` array. So, the space occupied by the intermediate list would be O(N) since in the worst case the expression would be built out of all the digits as operands. * Additionally, the space used up by the recursion stack would also be O(N) since the size of recursion stack is determined by the value of `index` and it goes from 0 all the way to N. * We don't consider the space occupied by the `answers` array since that is a part of the question's requirement and we can't reduce that in any way EDIT: The previous implementation of the algorithm, although correct, lead me to write an incorrect complexity analysis section. I've re-written the algorithm from scratch and corrected the complexity analysis as well. Sorry for the inconvenience to all the readers. The core idea of the algorithm is still the same. That hasn't changed. Special thanks to [@ufarooqi](https://leetcode.com/ufarooqi/), [@vortexwolf](https://leetcode.com/vortexwolf) for providing correct complexity analysis in the discussion forum leading to corrections in the article. Pardon me if I've missed out on any other names :)",
    "constraints": [
      "1 <= num.length <= 10",
      "num consists of only digits.",
      "-231 <= target <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: num = \"123\", target = 6 Output: [\"1*2*3\",\"1+2+3\"] Explanation: Both \"1*2*3\" and \"1+2+3\" evaluate to 6."
      },
      {
        "example_text": "Input: num = \"232\", target = 8 Output: [\"2*3+2\",\"2+3*2\"] Explanation: Both \"2*3+2\" and \"2+3*2\" evaluate to 8."
      },
      {
        "example_text": "Input: num = \"3456237490\", target = 9191 Output: [] Explanation: There are no expressions that can be created from \"3456237490\" to evaluate to 9191."
      }
    ]
  },
  {
    "problem_slug": "move-zeroes",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Two Pointers"
    ],
    "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. Example 1: Example 2: Constraints:",
    "solution": "Video Solution Solution This question comes under a broad category of \"Array Transformation\". This category is the meat of tech interviews. Mostly because arrays are such a simple and easy to use data structure. Traversal or representation doesn't require any boilerplate code and most of your code will look like the Pseudocode itself. The 2 requirements of the question are: 1. Move all the 0's to the end of array. 2. All the non-zero elements must retain their original order. It's good to realize here that both the requirements are mutually exclusive, i.e., you can solve the individual sub-problems and then combine them for the final solution. Approach 1 (Space Sub-Optimal) [Accepted] Traverse the `nums` list first to count the number of zeroes. Then traverse the `nums` list again to store all non-zero elements in `ans`. Algorithm: - Determine the size of the `nums` array and store it in `n`. - Count the number of zeroes in `nums`: - Initialize `numZeroes` to 0. - Iterate through each element in `nums`: - Increment `numZeroes` for each zero encountered. - Create a new vector `ans` to store non-zero elements in their original order: - Iterate through each element in `nums`: - Add non-zero elements to `ans`. - Append all zeroes to the end of the `ans` vector: - Append `numZeroes` zeroes to `ans`. - Update the original `nums` array with the elements from `ans`: - Copy each element from `ans` back to `nums`.Complexity Analysis Space Complexity : O(n). Since we are creating the \"ans\" array to store results. Time Complexity: O(n). We traverse the nums list first to count the number of zeroes using $O(n)$ time. Then, we traverse the nums list again to store all non-zero elements in ans which also costs $O(n)$ time. Hence, the overall time complexity is $O(2n)$, which is simplified to $O(n)$. However, the total number of operations are sub-optimal. We can achieve the same result in less number of operations. If asked in an interview, the above solution would be a good start. You can explain the interviewer(not code) the above and build your base for the next Optimal Solution. Approach 2 (Space Optimal, Operation Sub-Optimal) [Accepted] This approach works the same way as above, i.e. , first fulfills one requirement and then another. The catch? It does it in a clever way. The above problem can also be stated in alternate way, \" Bring all the non 0 elements to the front of array keeping their relative order same\". This is a 2 pointer approach. The fast pointer(`nums[i]`) does the job of processing new elements. If the newly found element is not a 0, we record it just after the last found non-0 element. The position of last found non-0 element is denoted by the slow pointer `lastNonZeroFoundAt` variable. As we keep finding new non-0 elements, we just overwrite them at the `lastNonZeroFoundAt + 1` 'th index. This overwrite will not result in any loss of data because we already processed what was there(if it were non-0,it already is now written at it's corresponding index,or if it were 0 it will be handled later in time). After the `nums[i]` reaches the end of array, we now know that all the non-0 elements have been moved to beginning of array in their original order. Now comes the time to fulfil other requirement, \"Move all 0's to the end\". We now simply need to fill all the indexes after the `lastNonZeroFoundAt` index with 0. Algorithm: - Initialize `lastNonZeroFoundAt` to 0: - This variable tracks the position where the next non-zero element should be placed. - Iterate through each element in `nums`: - If the current element `nums[i]` is not zero: - Place `nums[i]` at index `lastNonZeroFoundAt`. - Increment `lastNonZeroFoundAt` to move to the next position for future non-zero elements. - After processing all elements: - Fill the remaining positions in the array (from `lastNonZeroFoundAt` to the end) with zeros. - This ensures that all non-zero elements are moved to the beginning of the array and all zeros are placed at the end.Complexity Analysis Space Complexity : O(1). Only constant space is used. Time Complexity: O(n). We traverse the nums list first to move all non-zero elements to the beginning of array which costs $O(n)$ time. At the worst case when the original array only consists of 0s, we will use $O(n)$ time to fill all remaining elements with 0s. Hence, the overall time complexity is $O(2n)$, which is simplified to $O(n)$. However, the total number of operations are still sub-optimal. The total operations (array writes) that code does is n (Total number of elements). Approach 3 (Optimal) [Accepted] The total number of operations of the previous approach is sub-optimal. For example, the array which has all (except last) leading zeroes: [0, 0, 0, ..., 0, 1].How many write operations to the array? For the previous approach, it writes 0's n-1 times, which is not necessary. We could have instead written just once. How? ..... By only fixing the non-0 element,i.e., 1. The optimal approach is again a subtle extension of above solution. A simple realization is if the current element is non-0, its' correct position can at best be it's current position or a position earlier. If it's the latter one, the current position will be eventually occupied by a non-0 ,or a 0, which lies at a index greater than 'cur' index. We fill the current position by 0 right away,so that unlike the previous solution, we don't need to come back here in next iteration. In other words, the code will maintain the following invariant: >1. All elements before the slow pointer (lastNonZeroFoundAt) are non-zeroes. > >2. All elements between the current and slow pointer are zeroes. Therefore, when we encounter a non-zero element, we need to swap elements pointed by current and slow pointer, then advance both pointers. If it's zero element, we just advance current pointer. With this invariant in-place, it's easy to see that the algorithm will work. Algorithm: - Initialize `lastNonZeroFoundAt` to 0 to track the position of the last non-zero element. - Iterate through each element in `nums` using `cur` as the index: - If `nums[cur]` is not zero: - Swap `nums[lastNonZeroFoundAt]` with `nums[cur]` to move the non-zero element to the correct position. - Increment `lastNonZeroFoundAt` to update the position for the next non-zero element. - Continue iterating until all elements are processed, ensuring all non-zero elements are moved to the front of the array and zeros are pushed to the end.Complexity Analysis Space Complexity : O(1). Only constant space is used. Time Complexity: O(n). However, the total number of operations are optimal. The total operations (array writes) that code does is Number of non-0 elements.This gives us a much better best-case (when most of the elements are 0) complexity than last solution. However, the worst-case (when all elements are non-0) complexity for both the algorithms is same. Analysis written by: @spandan.pathak",
    "constraints": [
      "1 <= nums.length <= 104",
      "-231 <= nums[i] <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0]"
      },
      {
        "example_text": "Input: nums = [0] Output: [0]"
      }
    ]
  },
  {
    "problem_slug": "peeking-iterator",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Design",
      "Iterator"
    ],
    "description": "Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations. Implement the PeekingIterator class: Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions. Example 1: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 1000",
      "1 <= nums[i] <= 1000",
      "All the calls to next and peek are valid.",
      "At most 1000 calls will be made to next, hasNext, and peek."
    ],
    "examples": [
      {
        "example_text": "Input [\"PeekingIterator\", \"next\", \"peek\", \"next\", \"next\", \"hasNext\"] [[[1, 2, 3]], [], [], [], [], []] Output [null, 1, 2, 2, 3, false] Explanation PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3] peekingIterator.next(); // return 1, the pointer moves to the next element [1,2,3]. peekingIterator.peek(); // return 2, the pointer does not move [1,2,3]. peekingIterator.next(); // return 2, the pointer moves to the next element [1,2,3] peekingIterator.next(); // return 3, the pointer moves to the next element [1,2,3] peekingIterator.hasNext(); // return False"
      }
    ]
  },
  {
    "problem_slug": "find-the-duplicate-number",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Two Pointers",
      "Binary Search",
      "Bit Manipulation"
    ],
    "description": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and using only constant extra space. Example 1: Example 2: Example 3: Constraints: Follow up:",
    "solution": "",
    "constraints": [
      "1 <= n <= 105",
      "nums.length == n + 1",
      "1 <= nums[i] <= n",
      "All the integers in nums appear only once except for precisely one integer which appears two or more times."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,3,4,2,2] Output: 2"
      },
      {
        "example_text": "Input: nums = [3,1,3,4,2] Output: 3"
      },
      {
        "example_text": "Input: nums = [3,3,3,3,3] Output: 3"
      }
    ]
  },
  {
    "problem_slug": "game-of-life",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "description": "According to Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\" The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): The next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the m x n grid board. In this process, births and deaths occur simultaneously. Given the current state of the board, update the board to reflect its next state. Note that you do not need to return anything. Example 1: Example 2: Constraints: Follow up:",
    "solution": "",
    "constraints": [
      "m == board.length",
      "n == board[i].length",
      "1 <= m, n <= 25",
      "board[i][j] is 0 or 1."
    ],
    "examples": [
      {
        "example_text": "Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"
      },
      {
        "example_text": "Input: board = [[1,1],[1,0]] Output: [[1,1],[1,1]]"
      }
    ]
  },
  {
    "problem_slug": "word-pattern",
    "difficulty": "Easy",
    "topics": [
      "Hash Table",
      "String"
    ],
    "description": "Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Specifically: Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= pattern.length <= 300",
      "pattern contains only lower-case English letters.",
      "1 <= s.length <= 3000",
      "s contains only lowercase English letters and spaces ' '.",
      "s does not contain any leading or trailing spaces.",
      "All the words in s are separated by a single space."
    ],
    "examples": [
      {
        "example_text": "Input: pattern = \"abba\", s = \"dog cat cat dog\" Output: true Explanation: The bijection can be established as:"
      },
      {
        "example_text": "Input: pattern = \"abba\", s = \"dog cat cat fish\" Output: false"
      },
      {
        "example_text": "Input: pattern = \"aaaa\", s = \"dog cat cat dog\" Output: false"
      }
    ]
  },
  {
    "problem_slug": "nim-game",
    "difficulty": "Easy",
    "topics": [
      "Math",
      "Brainteaser",
      "Game Theory"
    ],
    "description": "You are playing the following Nim Game with your friend: Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: n = 4 Output: false Explanation: These are the possible outcomes: 1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins. 2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins. 3. You remove 3 stones. Your friend removes the last stone. Your friend wins. In all outcomes, your friend wins."
      },
      {
        "example_text": "Input: n = 1 Output: true"
      },
      {
        "example_text": "Input: n = 2 Output: true"
      }
    ]
  },
  {
    "problem_slug": "find-median-from-data-stream",
    "difficulty": "Hard",
    "topics": [
      "Two Pointers",
      "Design",
      "Sorting",
      "Heap (Priority Queue)",
      "Data Stream"
    ],
    "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values. Implement the MedianFinder class: Example 1: Constraints: Follow up:",
    "solution": "",
    "constraints": [
      "-105 <= num <= 105",
      "There will be at least one element in the data structure before calling findMedian.",
      "At most 5 * 104 calls will be made to addNum and findMedian."
    ],
    "examples": [
      {
        "example_text": "Input [\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"] [[], [1], [2], [], [3], []] Output [null, null, null, 1.5, null, 2.0] Explanation MedianFinder medianFinder = new MedianFinder(); medianFinder.addNum(1); // arr = [1] medianFinder.addNum(2); // arr = [1, 2] medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2) medianFinder.addNum(3); // arr[1, 2, 3] medianFinder.findMedian(); // return 2.0"
      }
    ]
  },
  {
    "problem_slug": "serialize-and-deserialize-binary-tree",
    "difficulty": "Hard",
    "topics": [
      "String",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Design",
      "Binary Tree"
    ],
    "description": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 104].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "example_text": "Input: root = [1,2,3,null,null,4,5] Output: [1,2,3,null,null,4,5]"
      },
      {
        "example_text": "Input: root = [] Output: []"
      }
    ]
  },
  {
    "problem_slug": "bulls-and-cows",
    "difficulty": "Medium",
    "topics": [
      "Hash Table",
      "String",
      "Counting"
    ],
    "description": "You are playing the Bulls and Cows game with your friend. You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info: Given the secret number secret and your friend's guess guess, return the hint for your friend's guess. The hint should be formatted as \"xAyB\", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= secret.length, guess.length <= 1000",
      "secret.length == guess.length",
      "secret and guess consist of digits only."
    ],
    "examples": [
      {
        "example_text": "Input: secret = \"1807\", guess = \"7810\" Output: \"1A3B\" Explanation: Bulls are connected with a '|' and cows are underlined: \"1807\" | \"7810\""
      },
      {
        "example_text": "Input: secret = \"1123\", guess = \"0111\" Output: \"1A1B\" Explanation: Bulls are connected with a '|' and cows are underlined: \"1123\" \"1123\" | or | \"0111\" \"0111\" Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull."
      }
    ]
  },
  {
    "problem_slug": "longest-increasing-subsequence",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Binary Search",
      "Dynamic Programming"
    ],
    "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence. Example 1: Example 2: Example 3: Constraints: Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 2500",
      "-104 <= nums[i] <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4."
      },
      {
        "example_text": "Input: nums = [0,1,0,3,2,3] Output: 4"
      },
      {
        "example_text": "Input: nums = [7,7,7,7,7,7,7] Output: 1"
      }
    ]
  },
  {
    "problem_slug": "remove-invalid-parentheses",
    "difficulty": "Hard",
    "topics": [
      "String",
      "Backtracking",
      "Breadth-First Search"
    ],
    "description": "Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid. Return a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order. Example 1: Example 2: Example 3: Constraints:",
    "solution": "Solution Approach 1: Backtracking Intuition For this question, we are given an expression consisting of parentheses and there can be some misplaced or extra brackets in the expression that cause it to be invalid. An expression consisting of parentheses is considered valid only when every closing bracket has a corresponding opening bracket and vice versa. This means if we start looking at each of the bracket from left to right, as soon as we encounter a closing bracket, there should be an unmatched opening bracket available to match it. Otherwise the expression would become invalid. The expression can also become invalid if the number of opening parentheses i.e. `(` are more than the number of closing parentheses i.e. `)`. Let us look at an invalid expression and all the possible valid expressions that can be formed from it by removing some of the brackets. There is no restriction on which parentheses we can remove. We simply have to make the expression valid. > The only condition is that we should be removing the minimum number of brackets to make an invalid expression, valid. If this condition was not present, we could potentially remove most of the brackets and come down to say 2 brackets in the end which form `()` and that would be a valid expression.An important thing to observe in the above diagram is that there are multiple ways of reaching the same solution i.e. say the optimal number of parentheses to be removed to make the original expression valid is K. We can remove multiple different sets of K brackets that will eventually give us the same final expression. But, each valid expression should be recorded only once. We have to take care of this in our solution. Note that there are other possible ways of reaching one of the two valid expressions shown above. We have simply shown 3 ways each for the two valid expressions. Coming back to our problem, the question that now arises is, how to decide which of the parentheses to remove? > Since we don't know which of the brackets can possibly be removed, we try out all the options! For every bracket we have two choices: * Either it can be considered a part of the final expression OR * It can be ignored i.e. we can delete it from our final expression. Such kind of problems where we have multiple options and we have no strategy or metric of deciding greedily which option to take, we try out all of the options and see which ones lead to an answer. These type of problems are perfect candidates for the programming paradigm, `Recursion`. Algorithm 1. Initialize an array that will store all of our valid expressions finally. 2. Start with the leftmost bracket in the given sequence and proceed right in the recursion. 3. The state of recursion is defined by the index which we are currently processing in the original expression. Let this index be represented by the character `i`. Also, we have two different variables `left_count` and `right_count` that represent the number of left and right parentheses we have added to our expression till now. These are the parentheses that were considered. 4. If the current character i.e. `S[i]` (considering S is the expression string) is neither a closing or an opening parenthesis, then we simply add this character to our final solution string for the current recursion. 5. However, if the current character is either of the two brackets i.e. `S[i] == '(' or S[i] == ')'`, then we have two options. We can either discard this character by marking it an invalid character or we can consider this bracket to be a part of the final expression. 6. When all of the parentheses in the original expression have been processed, we simply check if the expression represented by `expr` i.e. the expression formed till now is valid one or not. The way we check if the final expression is valid or not is by looking at the values in `left_count` and `right_count`. For an expression to be valid `left_count == right_count`. If it is indeed valid, then it could be one of our possible solutions. * Even though we have a valid expression, we also need to keep track of the number of removals we did to get this expression. This is done by another variable passed in recursion called `rem_count`. * Once recursion finishes we check if the current value of `rem_count` is < the least number of steps we took to form a valid expression till now i.e. the global minima. If this is not the case, we don't record the new expression, else we record it. One small optimization that we can do from an implementation perspective is introducing some sort of pruning in our algorithm. Right now we simply go till the very end i.e. process all of the parentheses and when we are done processing all of them, we check if the expression we have can be considered or not. We have to wait till the very end to decide if the expression formed in recursion is a valid expression or not. Is there a way for us to cutoff from some of the recursion paths early on because they wouldn't lead to a solution? The answer to this is Yes! The optimization is based on the following idea. For a left bracket encountered during recursion, if we decide to consider it, then it may or may not lead to an invalid final expression. It may lead to an invalid expression eventually if there are no matching closing bracket available afterwards. But, we don't know for sure if this will happen or not. > However, for a closing bracket, if we decide to keep it as a part of our final expression (remember for every bracket we have two options, either to keep it or to remove it and recurse further) and there is no corresponding opening bracket to match it in the expression till now, then it will definitely lead to an invalid expression no matter what we do afterwards. e.g.( ( ) ) )In this case the third closing bracket will make the expression invalid. No matter what comes afterwards, this will give us an invalid expression and if such a thing happens, we shouldn't recurse further and simply prune the recursion tree. That is why, in addition to having the index in the original string/expression which we are currently processing and the expression string formed till now, we also keep track of the number of left and right parentheses. Whenever we keep a left parenthesis in the expression, we increment its counter. For a right parenthesis, we check if `right_count < left_count`. If this is the case then only we consider that right parenthesis and recurse further. Otherwise we don't as we know it will make the expression invalid. This simple optimization saves a lot of runtime. Now, let us look at the implementation for this algorithm.Complexity analysis * Time Complexity : O(2^N) since in the worst case we will have only left parentheses in the expression and for every bracket we will have two options i.e. whether to remove it or consider it. Considering that the expression has N parentheses, the time complexity will be O(2^N). * Space Complexity : O(N) because we are resorting to a recursive solution and for a recursive solution there is always stack space used as internal function states are saved onto a stack during recursion. The maximum depth of recursion decides the stack space used. Since we process one character at a time and the base case for the recursion is when we have processed all of the characters of the expression string, the size of the stack would be O(N). Note that we are not considering the space required to store the valid expressions. We only count the intermediate space here. Approach 2: Limited Backtracking! Although the previous solution does get accepted on the platform, it is a very inefficient solution because we try removing each and every possible parentheses from the expression and in the end we check two things: 1. if the expression is valid or not 2. if the total number of removed parentheses removed in the current recursion is less than the global minimum till now or not. We cannot determine which of the parentheses are misplaced because, as the problem statement puts across, we can remove multiple combinations of parentheses and end up with a valid expression. This means there can be multiple valid expressions from a single invalid expression and we have to find all of them. > The one thing all these valid expressions have in common is that they will all be of the same length i.e. as compared to the original expression, all of these expressions will have the same number of characters removed. What if we could determine this count? What if in addition to determining this count of characters to be removed, we could also determine the number of left parentheses and number of right parentheses to be removed from the original expression to get any valid expression? This would cut down the computations immensely and the runtime would plummet as a result. The reason for this is, if we knew how many left and right parentheses are to be removed from the original expression to get a valid expression, we would cut down on so many unwanted recursive calls. Imagine the original expression to be 1000 characters with only 3 misplaced `(` parentheses and 2 misplaced `)` parentheses. In our previous solution we would end up trying to remove each one of left and right parentheses and try to reach a valid expression in the end whereas we should only be trying out removing 3 `(` brackets and 2 `)` brackets. > This is the exact number of `(` and `)` that have to be removed to get a valid expression. No more, no less. Let us look at how we can find out the number of misplaced left and right parentheses in a given expression first and then we will slightly modify our original algorithm to incorporate these counts as well. 1. We process the expression one bracket at a time starting from the left. 2. Suppose we encounter an opening bracket i.e. `(`, it may or may not lead to an invalid expression because there can be a matching ending bracket somewhere in the remaining part of the expression. Here, we simply increment the counter keeping track of left parentheses till now. `left += 1` 3. If we encounter a closing bracket, this has two meanings: * Either there was no matching opening bracket for this closing bracket and in that case we have an invalid expression. This is the case when `left == 0` i.e. when there are no unmatched left brackets available. In such a case we increment another counter say `right += 1` to represent misplaced right parentheses. * Or, we had some unmatched opening bracket available to match this closing bracket. This is the case when `left > 0`. In this case we simply decrement the left counter we had i.e. `left -= 1` 4. Continue processing the string until all parentheses have been processed. 5. In the end the values of `left` and `right` would tell us the number of unmatched `(` and `)` parentheses respectively. Now that we have these two values available that tell us the total number of left i.e. `(` and right i.e. `)` parentheses that have to be removed to make the invalid expression valid, we will modify our original algorithm discussed in the previous session to avoid unwanted recursions. Algorithm The overall algorithm remains exactly the same as before. The changes that we will incorporate are listed below: * The state of the recursion is now defined by five different variables: 1. `index` which represents the current character that we have to process in the original string. 2. `left_count` which represents the number of left parentheses that have been added to the expression we are building. 3. `right_count` which represents the number of right parentheses that have been added to the expression we are building. 4. `left_rem` is the number of left parentheses that remain to be removed. 5. `right_rem` represents the number of right parentheses that remain to be removed. Overall, for the final expression to be valid, `left_rem == 0` and `right_rem == 0`. * When we decide to not consider a parenthesis i.e. delete a parenthesis, be it a left or a right parentheses, we have to consider their corresponding remaining counts as well. This means that we can only discard a left parentheses if `left_rem > 0` and similarly for the right one we will check for `right_rem > 0`. * There are no changes to checks for considering a parenthesis. Only the conditions change for discarding a parenthesis. * Condition for an expression being valid in the base case would now become `left_rem == 0 and right_rem == 0`. Note that we don't have to check if `left_count == right_count` anymore because in the case of a valid expression, we would have removed all the misplaced or invalid parenthesis by the time the recursion ends. So, the only check we need if `left_rem == 0 and right_rem == 0`. > The most important thing here is that we have completely gotten rid of checking if the number of parentheses removed is lesser than the current minimum or not. The reason for this is we always remove the same number of parentheses as defined by `left_rem + right_rem` at the start of recursion. Now let us look at the implementation for this modified version of algorithm.Complexity analysis * Time Complexity : The optimization that we have performed is simply a better form of pruning. Pruning here is something that will vary from one test case to another. In the worst case, we can have something like `(((((((((` and the `left_rem = len(S)` and in such a case we can discard all of the characters because all are misplaced. So, in the worst case we still have 2 options per parenthesis and that gives us a complexity of O(2^N). * Space Complexity : The space complexity remains the same i.e. O(N) as previous solution. We have to go to a maximum recursion depth of N before hitting the base case. Note that we are not considering the space required to store the valid expressions. We only count the intermediate space here.",
    "constraints": [
      "1 <= s.length <= 25",
      "s consists of lowercase English letters and parentheses '(' and ')'.",
      "There will be at most 20 parentheses in s."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"()())()\" Output: [\"(())()\",\"()()()\"]"
      },
      {
        "example_text": "Input: s = \"(a)())()\" Output: [\"(a())()\",\"(a)()()\"]"
      },
      {
        "example_text": "Input: s = \")(\" Output: [\"\"]"
      }
    ]
  },
  {
    "problem_slug": "range-sum-query-immutable",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Design",
      "Prefix Sum"
    ],
    "description": "Given an integer array nums, handle multiple queries of the following type: Implement the NumArray class: Example 1: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 104",
      "-105 <= nums[i] <= 105",
      "0 <= left <= right < nums.length",
      "At most 104 calls will be made to sumRange."
    ],
    "examples": [
      {
        "example_text": "Input [\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"] [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]] Output [null, 1, -1, -3] Explanation NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]); numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1 numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1 numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3"
      }
    ]
  },
  {
    "problem_slug": "range-sum-query-2d-immutable",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Design",
      "Matrix",
      "Prefix Sum"
    ],
    "description": "Given a 2D matrix matrix, handle multiple queries of the following type: Implement the NumMatrix class: You must design an algorithm where sumRegion works on O(1) time complexity. Example 1: Constraints:",
    "solution": "",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 200",
      "-104 <= matrix[i][j] <= 104",
      "0 <= row1 <= row2 < m",
      "0 <= col1 <= col2 < n",
      "At most 104 calls will be made to sumRegion."
    ],
    "examples": [
      {
        "example_text": "Input [\"NumMatrix\", \"sumRegion\", \"sumRegion\", \"sumRegion\"] [[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]] Output [null, 8, 11, 12] Explanation NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]); numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle) numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle) numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)"
      }
    ]
  },
  {
    "problem_slug": "additive-number",
    "difficulty": "Medium",
    "topics": [
      "String",
      "Backtracking"
    ],
    "description": "An additive number is a string whose digits can form an additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. Given a string containing only digits, return true if it is an additive number or false otherwise. Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid. Example 1: Example 2: Constraints: Follow up: How would you handle overflow for very large input integers?",
    "solution": "",
    "constraints": [
      "1 <= num.length <= 35",
      "num consists only of digits."
    ],
    "examples": [
      {
        "example_text": "Input: \"112358\" Output: true Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8"
      },
      {
        "example_text": "Input: \"199100199\" Output: true Explanation: The additive sequence is: 1, 99, 100, 199. 1 + 99 = 100, 99 + 100 = 199"
      }
    ]
  },
  {
    "problem_slug": "range-sum-query-mutable",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Design",
      "Binary Indexed Tree",
      "Segment Tree"
    ],
    "description": "Given an integer array nums, handle multiple queries of the following types: Implement the NumArray class: Example 1: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 3 * 104",
      "-100 <= nums[i] <= 100",
      "0 <= index < nums.length",
      "-100 <= val <= 100",
      "0 <= left <= right < nums.length",
      "At most 3 * 104 calls will be made to update and sumRange."
    ],
    "examples": [
      {
        "example_text": "Input [\"NumArray\", \"sumRange\", \"update\", \"sumRange\"] [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]] Output [null, 9, null, 8] Explanation NumArray numArray = new NumArray([1, 3, 5]); numArray.sumRange(0, 2); // return 1 + 3 + 5 = 9 numArray.update(1, 2); // nums = [1, 2, 5] numArray.sumRange(0, 2); // return 1 + 2 + 5 = 8"
      }
    ]
  },
  {
    "problem_slug": "best-time-to-buy-and-sell-stock-with-cooldown",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions: Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= prices.length <= 5000",
      "0 <= prices[i] <= 1000"
    ],
    "examples": [
      {
        "example_text": "Input: prices = [1,2,3,0,2] Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell]"
      },
      {
        "example_text": "Input: prices = [1] Output: 0"
      }
    ]
  },
  {
    "problem_slug": "minimum-height-trees",
    "difficulty": "Medium",
    "topics": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort"
    ],
    "description": "A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree. Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h)) are called minimum height trees (MHTs). Return a list of all MHTs' root labels. You can return the answer in any order. The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 2 * 104",
      "edges.length == n - 1",
      "0 <= ai, bi < n",
      "ai != bi",
      "All the pairs (ai, bi) are distinct.",
      "The given input is guaranteed to be a tree and there will be no repeated edges."
    ],
    "examples": [
      {
        "example_text": "Input: n = 4, edges = [[1,0],[1,2],[1,3]] Output: [1] Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT."
      },
      {
        "example_text": "Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] Output: [3,4]"
      }
    ]
  },
  {
    "problem_slug": "burst-balloons",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Dynamic Programming"
    ],
    "description": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons. If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it. Return the maximum coins you can collect by bursting the balloons wisely. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 300",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167"
      },
      {
        "example_text": "Input: nums = [1,5] Output: 10"
      }
    ]
  },
  {
    "problem_slug": "super-ugly-number",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Math",
      "Dynamic Programming"
    ],
    "description": "A super ugly number is a positive integer whose prime factors are in the array primes. Given an integer n and an array of integers primes, return the nth super ugly number. The nth super ugly number is guaranteed to fit in a 32-bit signed integer. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= n <= 105",
      "1 <= primes.length <= 100",
      "2 <= primes[i] <= 1000",
      "primes[i] is guaranteed to be a prime number.",
      "All the values of primes are unique and sorted in ascending order."
    ],
    "examples": [
      {
        "example_text": "Input: n = 12, primes = [2,7,13,19] Output: 32 Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19]."
      },
      {
        "example_text": "Input: n = 1, primes = [2,3,5] Output: 1 Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5]."
      }
    ]
  },
  {
    "problem_slug": "count-of-smaller-numbers-after-self",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Binary Search",
      "Divide and Conquer",
      "Binary Indexed Tree",
      "Segment Tree",
      "Merge Sort",
      "Ordered Set"
    ],
    "description": "Given an integer array nums, return an integer array counts where counts[i] is the number of smaller elements to the right of nums[i]. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 105",
      "-104 <= nums[i] <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: nums = [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element."
      },
      {
        "example_text": "Input: nums = [-1] Output: [0]"
      },
      {
        "example_text": "Input: nums = [-1,-1] Output: [0,0]"
      }
    ]
  },
  {
    "problem_slug": "remove-duplicate-letters",
    "difficulty": "Medium",
    "topics": [
      "String",
      "Stack",
      "Greedy",
      "Monotonic Stack"
    ],
    "description": "Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example 1: Example 2: Constraints: Note: This question is the same as 1081: https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/",
    "solution": "",
    "constraints": [
      "1 <= s.length <= 104",
      "s consists of lowercase English letters."
    ],
    "examples": [
      {
        "example_text": "Input: s = \"bcabc\" Output: \"abc\""
      },
      {
        "example_text": "Input: s = \"cbacdcbc\" Output: \"acdb\""
      }
    ]
  },
  {
    "problem_slug": "maximum-product-of-word-lengths",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "String",
      "Bit Manipulation"
    ],
    "description": "Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "2 <= words.length <= 1000",
      "1 <= words[i].length <= 1000",
      "words[i] consists only of lowercase English letters."
    ],
    "examples": [
      {
        "example_text": "Input: words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"] Output: 16 Explanation: The two words can be \"abcw\", \"xtfn\"."
      },
      {
        "example_text": "Input: words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"] Output: 4 Explanation: The two words can be \"ab\", \"cd\"."
      },
      {
        "example_text": "Input: words = [\"a\",\"aa\",\"aaa\",\"aaaa\"] Output: 0 Explanation: No such pair of words."
      }
    ]
  },
  {
    "problem_slug": "bulb-switcher",
    "difficulty": "Medium",
    "topics": [
      "Math",
      "Brainteaser"
    ],
    "description": "There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Return the number of bulbs that are on after n rounds. Example 1: Example 2: Example 3: Constraints:",
    "solution": "Solution Approach 1: Math Intuition The idea behind this problem is to find the number of bulbs that are on after `n` rounds. In each round, we toggle some of the bulbs. As all the bulbs are initially off, at the end only bulbs that are toggled an odd number of times will remain on. Now, whenever we are at a round `i` we know we toggle all bulbs having a factor `i`. Thus, we need to find the bulbs which have an odd number of factors, as those bulbs will be toggled an odd number of times (once by each factor). It might be unintuitive, but with a few examples, we can easily see that a perfect square number has an odd number of factors, since any number's factors come in pairs of two different numbers, but the square root of the number will be paired with itself. Let's take an example to make it more clear. Suppose `n = 10`. So, the number of rounds is `10`. In each round, we will toggle some of the bulbs. ![slide1](../Figures/319/Slide.PNG) Track of rounds in which each bulb is toggled: - Bulb 1: Round 1 (odd number of toggles) - Bulb 2: Round 1, Round 2 - Bulb 3: Round 1, Round 3 - Bulb 4: Round 1, Round 2, Round 4 (odd number of toggles) - Bulb 5: Round 1, Round 5 - Bulb 6: Round 1, Round 2, Round 3, Round 6 - Bulb 7: Round 1, Round 7 - Bulb 8: Round 1, Round 2, Round 4, Round 8 - Bulb 9: Round 1, Round 3, Round 9 (odd number of toggles) - Bulb 10: Round 1, Round 2, Round 5, Round10 So, the number of bulbs that are on after 10 rounds is 3: Bulb 1, Bulb 4, and Bulb 9.Now let's discuss, why do perfect squares have odd and non-perfect squares have an even number of factors? A factor is a number that can be multiplied by another number to produce a given result. Say for `12`, `1, 2, 3, 4, 6, 12` all are its factors as any factor `x` can be paired with another factor `12 / x` and when multiplied together it will result in `12`. When we factorize a number `y`, say we have one factor `x`, then the other factor whose multiplication will result in the original number will be `y / x`. Now comparing `x` and `y / x`, if `y` is a perfect square it means `y = a * a`, thus, here it is a possibility that `x` and `y / x` are same numbers, i.e. `a`. But if `y` is not a perfect square then for each `x` we will have a unique `y / x`, thus, it's factor pairs will always exist as two different numbers (e.g: for `12` -> `1 x 12`, `2 x 6`, `3 x 4`, (it has three factor pairs, so total `6` factors)), thus the total count of number of factors for non-perfect squares will be even, and for perfect square, all other `x` and `y / x` factor pairs will be two different numbers except for one case, i.e. `a` and `a` (e.g: for `16` -> `1 x 16`, `2 x 8`, `4 x 4` (`4` is paired with itself, it has three factor pairs, but one pair has both numbers same, so total `5` factors)). Thus, it will have odd number of total factors.Thus we just need to find how many numbers from `1` to `n` are perfect squares. We can iterate on each number and check if it's a perfect square or not, (i.e. `floor(sqrt(i)) * floor(sqrt(i)) == i`) Or, we can directly find the square root of `n` and its floor value will be equal to the count of numbers whose squares exist in this range `1` to `n`. The floor of the square root of `n` gives us the largest number whose square is less than or equal to `n`. For example, if `n = 26`, then the floor of square root of `n` is `5`, which means the largest number whose square is less than or equal to `26` is `5` thus for each number from `1` to `5`, its respective square will be present in the original range. So, there are `5` perfect squares in the range `1` to `25` `(1, 4, 9, 16, and 25)`. So, taking the floor value of the square root of `n` will give us the number of perfect squares in the range `1` to `n`. Hence, `sqrt(n)` is our answer to this problem. > Note: You can also implement a function to find the square root of a number on your own, but here will use the in-built STL methods provided by each language. Algorithm 1. Return the square root of `n`. Implementation Complexity Analysis Here, $n$ is the number of bulbs and rounds. * Time complexity: $O(1)$ - In general, the [fast inverse square root algorithm](https://en.wikipedia.org/wiki/Fast_inverse_square_root) is used to compute the square root of a number (which is typically represented using 32 bits) in most programming languages. The algorithm performs a series of bitwise and floating-point operations on the input value to compute an approximation of the inverse square root. The number of operations performed by the algorithm is fixed and does not depend on the input size. Thus, it makes each call to this method an $O(1)$ time operation.> Note: If we want to compute the square root of large numbers (e.g: 10^10000), it would be impractical to use the fast inverse square root algorithm. The fast inverse square root algorithm is designed to compute an approximation of the inverse square root of a 32-bit floating-point number, and it may not be accurate enough for very large numbers. > > Instead, the languages would need to use a different algorithm that is capable of handling very large numbers with high precision. The Newton-Raphson and Babylonina methods are such algorithms that can be used to compute the square root of large numbers with high precision in nearly log-linear time (also called linearithmic time) $O(d \\log d)$, where $d$ is the number of digits of the input number. * Space complexity: $O(1)$ - The implementation of the `sqrt` method doesn't use any additional space.",
    "constraints": [
      "0 <= n <= 109"
    ],
    "examples": [
      {
        "example_text": "Input: n = 3 Output: 1 Explanation: At first, the three bulbs are [off, off, off]. After the first round, the three bulbs are [on, on, on]. After the second round, the three bulbs are [on, off, on]. After the third round, the three bulbs are [on, off, off]. So you should return 1 because there is only one bulb is on."
      },
      {
        "example_text": "Input: n = 0 Output: 0"
      },
      {
        "example_text": "Input: n = 1 Output: 1"
      }
    ]
  },
  {
    "problem_slug": "create-maximum-number",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Two Pointers",
      "Stack",
      "Greedy",
      "Monotonic Stack"
    ],
    "description": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k. Create the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved. Return an array of the k digits representing the answer. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "m == nums1.length",
      "n == nums2.length",
      "1 <= m, n <= 500",
      "0 <= nums1[i], nums2[i] <= 9",
      "1 <= k <= m + n",
      "nums1 and nums2 do not have leading zeros."
    ],
    "examples": [
      {
        "example_text": "Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5 Output: [9,8,6,5,3]"
      },
      {
        "example_text": "Input: nums1 = [6,7], nums2 = [6,0,4], k = 5 Output: [6,7,6,0,4]"
      },
      {
        "example_text": "Input: nums1 = [3,9], nums2 = [8,9], k = 3 Output: [9,8,9]"
      }
    ]
  },
  {
    "problem_slug": "coin-change",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Breadth-First Search"
    ],
    "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= coins.length <= 12",
      "1 <= coins[i] <= 231 - 1",
      "0 <= amount <= 104"
    ],
    "examples": [
      {
        "example_text": "Input: coins = [1,2,5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1"
      },
      {
        "example_text": "Input: coins = [2], amount = 3 Output: -1"
      },
      {
        "example_text": "Input: coins = [1], amount = 0 Output: 0"
      }
    ]
  },
  {
    "problem_slug": "wiggle-sort-ii",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Divide and Conquer",
      "Greedy",
      "Sorting",
      "Quickselect"
    ],
    "description": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3].... You may assume the input array always has a valid answer. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 5 * 104",
      "0 <= nums[i] <= 5000",
      "It is guaranteed that there will be an answer for the given input nums."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [1,5,1,1,6,4] Output: [1,6,1,5,1,4] Explanation: [1,4,1,5,1,6] is also accepted."
      },
      {
        "example_text": "Input: nums = [1,3,2,2,3,1] Output: [2,3,1,3,1,2]"
      }
    ]
  },
  {
    "problem_slug": "power-of-three",
    "difficulty": "Easy",
    "topics": [
      "Math",
      "Recursion"
    ],
    "description": "Given an integer n, return true if it is a power of three. Otherwise, return false. An integer n is a power of three, if there exists an integer x such that n == 3x. Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "-231 <= n <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: n = 27 Output: true Explanation: 27 = 33"
      },
      {
        "example_text": "Input: n = 0 Output: false Explanation: There is no x where 3x = 0."
      },
      {
        "example_text": "Input: n = -1 Output: false Explanation: There is no x where 3x = (-1)."
      }
    ]
  },
  {
    "problem_slug": "count-of-range-sum",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Binary Search",
      "Divide and Conquer",
      "Binary Indexed Tree",
      "Segment Tree",
      "Merge Sort",
      "Ordered Set"
    ],
    "description": "Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "1 <= nums.length <= 105",
      "-231 <= nums[i] <= 231 - 1",
      "-105 <= lower <= upper <= 105",
      "The answer is guaranteed to fit in a 32-bit integer."
    ],
    "examples": [
      {
        "example_text": "Input: nums = [-2,5,-1], lower = -2, upper = 2 Output: 3 Explanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2."
      },
      {
        "example_text": "Input: nums = [0], lower = 0, upper = 0 Output: 1"
      }
    ]
  },
  {
    "problem_slug": "odd-even-linked-list",
    "difficulty": "Medium",
    "topics": [
      "Linked List"
    ],
    "description": "Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The first node is considered odd, and the second node is even, and so on. Note that the relative order inside both the even and odd groups should remain as it was in the input. You must solve the problem in O(1) extra space complexity and O(n) time complexity. Example 1: Example 2: Constraints:",
    "solution": "",
    "constraints": [
      "The number of nodes in the linked list is in the range [0, 104].",
      "-106 <= Node.val <= 106"
    ],
    "examples": [
      {
        "example_text": "Input: head = [1,2,3,4,5] Output: [1,3,5,2,4]"
      },
      {
        "example_text": "Input: head = [2,1,3,5,6,4,7] Output: [2,3,6,7,1,5,4]"
      }
    ]
  },
  {
    "problem_slug": "longest-increasing-path-in-a-matrix",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph",
      "Topological Sort",
      "Memoization",
      "Matrix"
    ],
    "description": "Given an m x n integers matrix, return the length of the longest increasing path in matrix. From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed). Example 1: Example 2: Example 3: Constraints:",
    "solution": "",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 200",
      "0 <= matrix[i][j] <= 231 - 1"
    ],
    "examples": [
      {
        "example_text": "Input: matrix = [[9,9,4],[6,6,8],[2,1,1]] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9]."
      },
      {
        "example_text": "Input: matrix = [[3,4,5],[3,2,6],[2,2,1]] Output: 4 Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed."
      },
      {
        "example_text": "Input: matrix = [[1]] Output: 1"
      }
    ]
  }
]